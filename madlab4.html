<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fill Translations → Shopify Import (XLSX)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, sans-serif; background:#0f1115; color:#e6e6e6; margin:0; padding:20px; }
    h1 { margin:0 0 8px; }
    .hint { color:#a9abb0; font-size:.92rem; margin:0 0 16px; }
    label { display:block; margin:12px 0 4px; }
    input[type="file"], input[type="text"] { width:100%; max-width:520px; }
    button { margin-top:16px; padding:10px 14px; border:0; border-radius:8px; background:#2b6cb0; color:#fff; cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    pre { background:#171a21; border:1px solid #2a2f3a; border-radius:8px; padding:12px; white-space:pre-wrap; margin-top:14px; color:#cfd2d6; }
  </style>
  <!-- SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <h1>Fill Translations → Shopify Import (XLSX)</h1>
  <p class="hint">
    Inputs:<br>
    A) Shopify import skeleton (<code>Type, Identification, Field, Locale, Market, Status, Default content, Translated content</code>)<br>
    B) SKU–Identification map (<code>SKU | Identification</code>)<br>
    C) PLGGR export (XLSX) with headers: <em>Webomschrijving</em> (title) &amp; <em>Uitgebreide omschrijving</em> (description).
  </p>

  <label for="skeleton">A) Shopify import skeleton (.xlsx)</label>
  <input id="skeleton" type="file" accept=".xlsx">

  <label for="skuIdent">B) SKU → Identification (.xlsx)</label>
  <input id="skuIdent" type="file" accept=".xlsx">

  <label for="plggr">C) PLGGR export (.xlsx)</label>
  <input id="plggr" type="file" accept=".xlsx">

  <label for="locale">Locale code to set in output (e.g. <code>de</code>)</label>
  <input id="locale" type="text" value="de" placeholder="de">

  <button id="process" disabled>Generate Filled XLSX</button>
  <pre id="report"></pre>

<script>
const $ = id => document.getElementById(id);
let fSkeleton=null, fSkuIdent=null, fPlggr=null;

['skeleton','skuIdent','plggr'].forEach(id => {
  $(id).addEventListener('change', e => {
    if (id==='skeleton') fSkeleton = e.target.files[0];
    if (id==='skuIdent') fSkuIdent = e.target.files[0];
    if (id==='plggr') fPlggr = e.target.files[0];
    updateReady();
  });
});

function updateReady(){
  $('process').disabled = !(fSkeleton && fSkuIdent && fPlggr);
}

function sheetToAOA(file){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = e => {
      try{
        const wb = XLSX.read(new Uint8Array(e.target.result), {type:'array'});
        const ws = wb.Sheets[wb.SheetNames[0]];
        const aoa = XLSX.utils.sheet_to_json(ws, {header:1, raw:false});
        resolve(aoa);
      }catch(err){ reject(err); }
    };
    r.onerror = reject;
    r.readAsArrayBuffer(file);
  });
}

function findHeaderIndex(headers, name){
  // case-insensitive match; trims; accepts minor diacritics differences
  const target = String(name).toLowerCase().trim();
  for (let i=0;i<headers.length;i++){
    if (!headers[i]) continue;
    const h = String(headers[i]).toLowerCase().trim();
    if (h === target) return i;
  }
  return -1;
}

function colLetterToIndex(letter){
  // e.g. "A"->0, "AE"->30, "AG"->32
  let s = String(letter).toUpperCase().trim();
  let n = 0;
  for (let i=0;i<s.length;i++){
    n = n*26 + (s.charCodeAt(i)-64);
  }
  return n-1;
}

$('process').addEventListener('click', async () => {
  const report = [];
  const locale = $('locale').value.trim();

  // Read all three files
  const [skeletonAOA, skuIdentAOA, plggrAOA] = await Promise.all([
    sheetToAOA(fSkeleton),
    sheetToAOA(fSkuIdent),
    sheetToAOA(fPlggr)
  ]);

  // Indices for Shopify skeleton columns (expected fixed order)
  const IDX = { Type:0, Identification:1, Field:2, Locale:3, Market:4, Status:5, Default:6, Translated:7 };

  // Build SKU -> Identification map
  let skuCount = 0;
  const skuToIdent = new Map();
  for (let i=1;i<skuIdentAOA.length;i++){
    const row = skuIdentAOA[i];
    if (!row) continue;
    const sku = String(row[0] ?? '').trim();
    const ident = String(row[1] ?? '').trim();
    if (!sku || !ident) continue;
    if (!skuToIdent.has(sku)) skuCount++;
    skuToIdent.set(sku, ident);
  }
  report.push(`SKU→Identification entries read: ${skuCount}`);

  // Determine PLGGR header row and indices
  const plHeader = plggrAOA[0] || [];
  const skuIdx = 0; // per your note: Column A has the SKU
  let titleIdx = findHeaderIndex(plHeader, 'webomschrijving');
  let descIdx  = findHeaderIndex(plHeader, 'uitgebreide omschrijving');

  // Fallback to AE/AG if header names aren’t found
  if (titleIdx === -1) { titleIdx = colLetterToIndex('AE'); report.push('Title header not found; using AE'); }
  if (descIdx  === -1) { descIdx  = colLetterToIndex('AG'); report.push('Description header not found; using AG'); }

  // Build Identification -> {title, body_html} via SKU map
  let plRows = 0, matchedSkus = 0, withTitle=0, withDesc=0;
  const identToContent = new Map();

  for (let i=1;i<plggrAOA.length;i++){
    const row = plggrAOA[i];
    if (!row) continue;
    plRows++;
    const sku = String(row[skuIdx] ?? '').trim();
    if (!sku) continue;
    const ident = skuToIdent.get(sku);
    if (!ident) continue;
    matchedSkus++;

    const title = String(row[titleIdx] ?? '').trim();
    const desc  = String(row[descIdx]  ?? '').trim();

    if (!identToContent.has(ident)) identToContent.set(ident, {title:'', body:''});
    const o = identToContent.get(ident);
    if (title) { o.title = title; withTitle++; }
    if (desc)  { o.body  = desc;  withDesc++;  }
  }

  report.push(`PLGGR rows read: ${plRows}`);
  report.push(`PLGGR rows with SKU matched to Identification: ${matchedSkus}`);
  report.push(`Identifications with title: ${withTitle}`);
  report.push(`Identifications with description: ${withDesc}`);

  // Create a new AOA for output (copy skeleton; fill Translated content for title/body_html; set Locale if provided)
  const out = skeletonAOA.map(r => (r ? r.slice() : r));
  let filledTitle=0, filledBody=0, totalRows=0;

  // Validate header or inject if absent
  const header = out[0] || [];
  const expected = ["Type","Identification","Field","Locale","Market","Status","Default content","Translated content"];
  if (header.length < 8 || String(header[0]).toLowerCase()!=='type') {
    // no proper header — insert one
    out.unshift(expected);
  } else {
    // normalise header to expected names (cosmetic)
    for (let i=0;i<expected.length;i++) out[0][i] = expected[i];
  }

  // Process data rows
  for (let i=1;i<out.length;i++){
    const row = out[i];
    if (!row || row.length<8) continue;
    const type  = String(row[IDX.Type]  ?? '').trim().toUpperCase();
    const ident = String(row[IDX.Identification] ?? '').trim();
    const field = String(row[IDX.Field] ?? '').trim().toLowerCase();

    if (type !== 'PRODUCT' || !ident) continue;

    const content = identToContent.get(ident);
    // Set locale if provided
    if (locale) row[IDX.Locale] = locale;

    if (field === 'title') {
      if (content && content.title) {
        row[IDX.Translated] = content.title;
        filledTitle++;
      }
      totalRows++;
    } else if (field === 'body_html') {
      if (content && content.body) {
        row[IDX.Translated] = content.body;
        filledBody++;
      }
      totalRows++;
    } else if (field === 'handle') {
      // leave handle rows as-is; they already have the handle in Default content
      totalRows++;
    }
  }

  report.push(`Title rows filled: ${filledTitle}`);
  report.push(`Body_html rows filled: ${filledBody}`);
  report.push(`Total rows processed: ${totalRows}`);

  // Emit workbook
  const ws = XLSX.utils.aoa_to_sheet(out);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Shopify Import");
  const fname = `shopify_import_filled_${locale || 'xx'}.xlsx`;
  XLSX.writeFile(wb, fname);

  $('report').textContent = report.join('\n');
});
</script>
</body>
</html>
