<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Procedural Battle Map Generator</title>
  <link 
    href="https://fonts.googleapis.com/css2?family=Almendra&family=Cinzel:wght@400;700&display=swap"
    rel="stylesheet"
  >
  <style>
    body {
      margin: 0;
      background: url('resources/mapgen.png') no-repeat center center fixed;
      background-size: cover;
      color: #FAF4E0;
      font-family: 'Almendra', serif;
      text-align: center;
      overscroll-behavior: none;
    }
    .container {
      margin: 2rem auto;
      background: rgba(0, 0, 0, 0.7);
      padding: 2rem;
      border-radius: 10px;
      max-width: 95vw;
    }
    h1, h2 {
      font-family: 'Cinzel', serif;
      margin: 0.5rem 0;
    }
    .description {
      font-size: 1.2rem;
      margin-top: 1rem;
    }
    .mapWrapper {
      width: 90vw;
      max-width: 1000px;
      height: 60vh;
      max-height: 700px;
      margin: 1rem auto;
      overflow: hidden;
      position: relative;
      display: block;
      border: 2px solid #660000;
      background: #202020;
    }
    #mapCanvas {
      width: 1000px;
      height: 1000px;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: top left;
      image-rendering: pixelated;
      touch-action: none;
    }
    .mapButton {
      display: inline-block;
      margin: 0.5rem;
      padding: 0.6rem 1rem;
      font-family: 'Cinzel', serif;
      background: #8B0000;
      color: #FAF4E0;
      border: 1px solid #660000;
      border-radius: 4px;
      cursor: pointer;
      text-decoration: none;
    }
    .mapButton:hover {
      background: #660000;
    }
    .controls {
      margin: 1rem auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .controls label {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Procedural Battle Map Generator</h1>
    <p class="description">
      "With thick cavern tunnels, optional roads/rivers, farmland & buildings, and city walls in a convex hull shape."
    </p>

    <div class="controls">
      <label>
        Map Biome:
        <select id="mapType">
          <option value="desert">Desert</option>
          <option value="city">City</option>
          <option value="grassland" selected>Grassland</option>
          <option value="mountain">Mountain</option>
          <option value="forest">Forest</option>
          <option value="cavern">Cavern</option>
          <option value="volcanic">Volcanic</option>
          <option value="mudlands">Mudlands</option>
          <option value="coastal">Coastal</option>
          <option value="riverlands">Riverlands</option>
          <option value="swamp">Swamp</option>
          <option value="jungle">Jungle</option>
          <option value="snow">Snow</option>
        </select>
      </label>

      <label>
        <input type="checkbox" id="buildingsCheck" />
        Generate Buildings
      </label>

      <label>
        <input type="checkbox" id="generateFields" />
        Generate Fields
      </label>

      <label>
        <input type="checkbox" id="cityWalls" />
        Add City Walls
      </label>

      <label>
        <input type="checkbox" id="roadsCheck" />
        Generate Roads
      </label>

      <label>
        <input type="checkbox" id="riversCheck" />
        Generate Rivers
      </label>

      <button class="mapButton" onclick="generateMap()">Generate Map</button>

      <label>
        Occupant Type:
        <select id="occupantType">
          <option value="none" selected>None</option>
          <option value="player">Player</option>
          <option value="enemy">Enemy</option>
          <option value="npc">NPC</option>
        </select>
      </label>

      <label>
        Sprite:
        <select id="occupantSprite">
          <option value="none" selected>None</option>
          <option value="paladin">paladin</option>
          <option value="fighter">fighter</option>
          <option value="guardian">guardian</option>
          <option value="halfblood">halfblood</option>
          <option value="berserker">berserker</option>
          <option value="assassin">assassin</option>
          <option value="warlock">warlock</option>
          <option value="sorcerer">sorcerer</option>
          <option value="priestess">priestess</option>
          <option value="cleric">cleric</option>
          <option value="druid">druid</option>
          <option value="demon">demon</option>
          <option value="mage">mage</option>
          <option value="serpent">serpent</option>
          <option value="chimera">chimera</option>
          <option value="ogre">ogre</option>
          <option value="edgelord">edgelord</option>
          <option value="fallenangel">fallenangel</option>
          <option value="darkpriestess">darkpriestess</option>
          <option value="darkguard">darkguard</option>
          <option value="cultist">cultist</option>
          <option value="goblin">goblin</option>
          <option value="spider">spider</option>
          <option value="bat">bat</option>
          <option value="zombie">zombie</option>
          <option value="orc">orc</option>
          <option value="orcbandit">orcbandit</option>
          <option value="orcchief">orcchief</option>
          <option value="orcshaman">orcshaman</option>
          <option value="orcfighter">orcfighter</option>
        </select>
      </label>

      <button class="mapButton" onclick="clearOccupantSelection()">Clear</button>
    </div>

    <div class="controls">
      <button class="mapButton" onclick="setMode('place')">Place</button>
      <button class="mapButton" onclick="setMode('delete')">Delete</button>
      <button class="mapButton" onclick="setMode('move')">Move</button>
    </div>

    <div class="mapWrapper">
      <canvas id="mapCanvas" width="1000" height="1000"></canvas>
    </div>

    <div style="margin-top: 1rem;">
      <a href="index.html" class="mapButton">Home</a>
    </div>
  </div>

  <script>
    /*******************************************************
     * BASIC CONFIG & GLOBALS
     *******************************************************/
    const TILE_SIZE=20, GRID_WIDTH=50, GRID_HEIGHT=50;
    let mapData=[], occupantInHand=null;
    const occupantColours={player:"#0f0",enemy:"#f00",npc:"#00f"};
    let currentMode='place';

    // Pan/Zoom
    let scale=1.0, offsetX=0, offsetY=0;
    const minScale=0.3, maxScale=3.0;
    let isDragging=false, dragStartX=0, dragStartY=0;
    let activePointers=new Map(), initialPinchDistance=0, initialPinchScale=1.0;

    /*******************************************************
     * TILE & SPRITE LOADING
     *******************************************************/
    const tileTextures={}, occupantSpritesMap={};

    // Full tileAssetMapping (shortened for brevity in this snippet, but 
    // imagine it's the same that includes desert, jungle, etc.):
    const tileAssetMapping={
      "grass": { folder:"grass", files:["grasstile1.png","grasstile2.png","grasstile3.png","grasstile4.png","grasstile5.png"] },
      "roadstone": { folder:"buildings/floors", files:["sandstonetile.png"] },
      "roaddirt": { folder:"dirt", files:["roadDirt.png"] },
      "farmland": { folder:"farmland", files:["corn.png","pumpkins.png","rye.png","sunflowers.png","vinyard.png","wheat.png"] },
      "cave_floor": { folder:"cavern", files:["cave1.png","cave2.png"] },
      "negative": { folder:"", files:[] },

      // Example for "lava","water","mud","marble1..4","wall","cobblestone", etc. 
      // Provide real references per your final version.
      "lava": { folder:"vulcanic", files:["lava1.png","lava2.png","lava3.png"] },
      "water": { folder:"water", files:["water.png"] },
      "mud": { folder:"dirt", files:["dirtMud1.png","dirtMud2.png","dirtMud3.png"] },
      "marble1": { folder:"buildings/floors", files:["marble1.png"] },
      "marble2": { folder:"buildings/floors", files:["marble2.png"] },
      "marble3": { folder:"buildings/floors", files:["marble3.png"] },
      "marble4": { folder:"buildings/floors", files:["marble4.png"] },
      "wall": { folder:"buildings/walls", files:["brick1.png","brick2.png","brick3.png","brick4.png","brick5.png"] }
    };

    function getColorForTileType(tt){
      const fallback={
        grass:"#9AE582", roadstone:"#777", roaddirt:"#a37e4c", farmland:"#9fc648",
        cave_floor:"#666", negative:"#000", lava:"#c33", water:"#26f",
        mud:"#6f4f3c", marble1:"#ccc", marble2:"#bbb", marble3:"#aaa", marble4:"#999",
        wall:"#774422"
      };
      return fallback[tt]||"#fff";
    }

    function preloadImages(onComplete){
      const occupantSpriteNames=["paladin","fighter","guardian","berserker","assassin","serpent","chimera","mage","ogre"];
      let totalToLoad=occupantSpriteNames.length;
      for(let k in tileAssetMapping){
        totalToLoad+=tileAssetMapping[k].files.length;
      }
      let loadedCount=0;
      function checkDone(){ loadedCount++; if(loadedCount>=totalToLoad&&onComplete)onComplete(); }

      for(let tkey in tileAssetMapping){
        tileTextures[tkey]=[];
        const { folder, files }=tileAssetMapping[tkey];
        if(!files.length)continue;
        for(let f of files){
          const img=new Image();
          img.src=folder? `resources/mapgen/mapassets/tiles/${folder}/${f}` : `resources/mapgen/mapassets/tiles/${f}`;
          img.onload=checkDone; img.onerror=checkDone;
          tileTextures[tkey].push(img);
        }
      }
      occupantSpriteNames.forEach(sp=>{
        const img=new Image();
        img.src=`resources/mapgen/mapassets/sprites/${sp}.png`;
        img.onload=checkDone; img.onerror=checkDone;
        occupantSpritesMap[sp]=img;
      });
    }

    /*******************************************************
     * MAP SETTINGS & GENERATION
     *******************************************************/
    function getMapSettings(theme){
      switch(theme){
        case "cavern": return { isCavern:true, baseDist:{}, waterBodies:0, waterMaxSize:0, roads:0, roadMaxLength:0, buildings:0 };
        default:
          return {
            isCavern:false,
            baseDist:{ grass:0.9, mud:0.1 },
            waterBodies:1, waterMaxSize:50,
            roads:2, roadMaxLength:40,
            buildings:3
          };
      }
    }

    function generateMap(){
      occupantInHand=null; offsetX=0; offsetY=0; scale=1.0; updateCanvasTransform();
      const theme=document.getElementById("mapType").value;
      const doBuildings=document.getElementById("buildingsCheck").checked;
      const doFields=document.getElementById("generateFields").checked;
      const doCityWalls=document.getElementById("cityWalls").checked;
      const doRoads=document.getElementById("roadsCheck").checked;
      const doRivers=document.getElementById("riversCheck").checked;
      const settings=getMapSettings(theme);

      if(settings.isCavern){
        generateCavern();
      } else {
        // normal fill
        initMap(settings.baseDist);
        // water bodies
        for(let i=0;i<settings.waterBodies;i++){
          createWaterBody(settings.waterMaxSize);
        }
        // rivers
        if(doRivers){
          // if volcanic => use lava, else water
          if(theme==="volcanic") createMeanderingRiver(settings.roadMaxLength,"lava");
          else createMeanderingRiver(settings.roadMaxLength,"water");
        }
        // roads
        if(doRoads){
          for(let r=0;r<settings.roads;r++){
            createRoad(settings.roadMaxLength,2,3);
          }
        }
      }

      if(doBuildings && !settings.isCavern && settings.buildings>0){
        createBuildings(settings.buildings);
      }
      if(doFields){
        createFields(3);
      }
      if(doCityWalls){
        createConvexCityWalls3Wide();
      }

      drawMap();
    }

    function initMap(dist){
      mapData=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          const rand=Math.random(); 
          let cumul=0, chosen="grass";
          for(let t in dist){
            cumul+=dist[t];
            if(rand<cumul){ chosen=t; break; }
          }
          row.push({type:chosen, occupant:null});
        }
        mapData.push(row);
      }
    }

    /*******************************************************
     * WATER BODIES
     *******************************************************/
    function createWaterBody(maxSize){
      let sx=Math.floor(Math.random()*GRID_WIDTH);
      let sy=Math.floor(Math.random()*GRID_HEIGHT);
      floodFillWater(sx,sy,maxSize);
    }
    function floodFillWater(sx,sy,maxSize){
      let stack=[[sx,sy]], size=0;
      while(stack.length && size<maxSize){
        let[cx,cy]=stack.pop();
        if(cx<0||cy<0||cx>=GRID_WIDTH||cy>=GRID_HEIGHT)continue;
        if(mapData[cy][cx].type==="water")continue;
        if(Math.random()<0.2)continue;
        mapData[cy][cx].type="water"; size++;
        stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
      }
    }

    /*******************************************************
     * RIVERS (drunkard's walk)
     *******************************************************/
    function createMeanderingRiver(maxLength, tileType="water"){
      let edges=["top","bottom","left","right"];
      let e=edges[Math.floor(Math.random()*edges.length)];
      let x=0,y=0;
      if(e==="top"){ x=Math.floor(Math.random()*GRID_WIDTH); y=0; }
      else if(e==="bottom"){ x=Math.floor(Math.random()*GRID_WIDTH); y=GRID_HEIGHT-1; }
      else if(e==="left"){ x=0; y=Math.floor(Math.random()*GRID_HEIGHT); }
      else{ x=GRID_WIDTH-1; y=Math.floor(Math.random()*GRID_HEIGHT); }
      let dir=pickRiverDir(e);
      let steps=Math.floor(Math.random()*(maxLength/2)+maxLength/2);
      for(let i=0;i<steps;i++){
        if(x<0||y<0||x>=GRID_WIDTH||y>=GRID_HEIGHT)break;
        mapData[y][x].type=tileType;
        if(Math.random()<0.2)dir=turnSlightly(dir);
        x+=dir.dx; y+=dir.dy;
      }
    }
    function pickRiverDir(edge){
      switch(edge){
        case "top": return {dx:Math.random()<0.5?1:-1,dy:1};
        case "bottom":return {dx:Math.random()<0.5?1:-1,dy:-1};
        case "left":return {dx:1,dy:Math.random()<0.5?1:-1};
        case "right":return {dx:-1,dy:Math.random()<0.5?1:-1};
        default:return {dx:0,dy:1};
      }
    }
    function turnSlightly(dir){
      const leftTurn={"1,0":{dx:0,dy:-1},"-1,0":{dx:0,dy:1},"0,1":{dx:-1,dy:0},"0,-1":{dx:1,dy:0}};
      const rightTurn={"1,0":{dx:0,dy:1},"-1,0":{dx:0,dy:-1},"0,1":{dx:1,dy:0},"0,-1":{dx:-1,dy:0}};
      let key=`${dir.dx},${dir.dy}`;
      if(Math.random()<0.5&&leftTurn[key])return leftTurn[key];
      if(rightTurn[key])return rightTurn[key];
      return dir;
    }

    /*******************************************************
     * ROADS
     *******************************************************/
    function createRoad(maxLength,minW,maxW){
      let x,y;
      if(Math.random()<0.5){
        x=Math.floor(Math.random()*GRID_WIDTH);
        y=(Math.random()<0.5)?0:GRID_HEIGHT-1;
      } else {
        x=(Math.random()<0.5)?0:GRID_WIDTH-1;
        y=Math.floor(Math.random()*GRID_HEIGHT);
      }
      let dir=getRandDir();
      const length=Math.floor(Math.random()*(maxLength/2)+maxLength/2);
      const w=Math.floor(Math.random()*(maxW-minW+1))+minW;
      for(let i=0;i<length;i++){
        carveRoad(x,y,w);
        x+=dir.dx; y+=dir.dy;
        if(Math.random()<0.2)dir=getRandDir(dir);
        if(x<0||x>=GRID_WIDTH||y<0||y>=GRID_HEIGHT)break;
      }
    }
    function carveRoad(cx,cy,width){
      const r=Math.floor(width/2);
      for(let dy=-r;dy<=r;dy++){
        for(let dx=-r;dx<=r;dx++){
          let nx=cx+dx, ny=cy+dy;
          if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT){
            mapData[ny][nx].type=Math.random()<0.6? "roadstone":"roaddirt";
          }
        }
      }
    }
    function getRandDir(prev){
      let ds=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
      if(prev&&Math.random()<0.6)return prev;
      return ds[Math.floor(Math.random()*ds.length)];
    }

    /*******************************************************
     * CAVERNS => wide corridors
     *******************************************************/
    function generateCavern(){
      let fillChance=0.52;
      let bm=makeBoolMap(fillChance);
      let steps=3;
      for(let i=0;i<steps;i++){
        bm=doCAStep(bm);
      }
      const{largestMap}=keepLargestRegion(bm);
      carveWideExits(largestMap,3);
      convertToCavern(largestMap);
    }
    function makeBoolMap(ch){
      let out=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          row.push(Math.random()<ch);
        }
        out.push(row);
      }
      return out;
    }
    function doCAStep(bm){
      let out=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          let n=countNeigh(bm,x,y);
          let c=bm[y][x];
          row.push(c?(n>=4):(n>=5));
        }
        out.push(row);
      }
      return out;
    }
    function countNeigh(bm,x,y){
      let c=0;
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          if(dx===0&&dy===0)continue;
          let nx=x+dx, ny=y+dy;
          if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT&&bm[ny][nx])c++;
        }
      }
      return c;
    }
    function keepLargestRegion(bm){
      let visited=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        visited[y]=new Array(GRID_WIDTH).fill(false);
      }
      let bestSize=0,bestReg=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          if(bm[y][x]&&!visited[y][x]){
            let q=[[x,y]];
            visited[y][x]=true;
            let reg=[[x,y]], size=1;
            while(q.length){
              let[cx,cy]=q.pop();
              for(let[nx,ny]of[[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]){
                if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT){
                  if(bm[ny][nx]&&!visited[ny][nx]){
                    visited[ny][nx]=true; q.push([nx,ny]);
                    reg.push([nx,ny]); size++;
                  }
                }
              }
            }
            if(size>bestSize){bestSize=size;bestReg=reg;}
          }
        }
      }
      let largestMap=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        largestMap[y]=bm[y].slice();
      }
      let setReg=new Set(bestReg.map(([xx,yy])=>`${xx},${yy}`));
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          if(largestMap[y][x]&&!setReg.has(`${x},${y}`)){
            largestMap[y][x]=false;
          }
        }
      }
      return{largestMap,largestRegion:bestReg};
    }
    function carveWideExits(bm,r){
      let needed=2;
      while(needed>0){
        carveRandomWideTunnel(bm,r);
        needed--;
      }
    }
    function carveRandomWideTunnel(bm,r){
      let tries=0,cx,cy;
      while(tries<500){
        cx=Math.floor(Math.random()*GRID_WIDTH);
        cy=Math.floor(Math.random()*GRID_HEIGHT);
        if(bm[cy][cx])break;
        tries++;
      }
      let ex=Math.random()<0.5?0:GRID_WIDTH-1;
      let ey=Math.floor(Math.random()*GRID_HEIGHT);
      carveCorridor(bm,cx,cy,ex,ey,r);
    }
    function carveCorridor(bm,x1,y1,x2,y2,r){
      let steps=0;
      while((x1!==x2||y1!==y2)&&steps<9999){
        carveCircle(bm,x1,y1,r);
        if(x1<x2)x1++; else if(x1>x2)x1--;
        if(y1<y2)y1++; else if(y1>y2)y1--;
        steps++;
      }
      carveCircle(bm,x1,y1,r);
    }
    function carveCircle(bm,cx,cy,rr){
      for(let dy=-rr;dy<=rr;dy++){
        for(let dx=-rr;dx<=rr;dx++){
          if(dx*dx+dy*dy<=rr*rr){
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT){
              bm[ny][nx]=true;
            }
          }
        }
      }
    }
    function convertToCavern(bm){
      mapData=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          if(bm[y][x])row.push({type:"cave_floor", occupant:null});
          else row.push({type:"negative", occupant:null});
        }
        mapData.push(row);
      }
    }

    /*******************************************************
     * BUILDINGS
     *******************************************************/
    const buildingShapes=[
      {width:4,height:4, layout:[
        [1,1,1,1],
        [1,0,0,1],
        [1,0,0,1],
        [1,1,1,1]
      ]}
      // etc for other shapes
    ];
    const possibleFloors=["marble1","marble2","marble3","marble4"];
    let chosenFloorTile=null;
    function createBuildings(num){
      chosenFloorTile=pickRandom(possibleFloors);
      let attempts=0, placed=0;
      while(placed<num && attempts<num*50){
        attempts++;
        let shape=pickRandom(buildingShapes);
        let sx=Math.floor(Math.random()*(GRID_WIDTH-shape.width));
        let sy=Math.floor(Math.random()*(GRID_HEIGHT-shape.height));
        if(canPlaceBld(sx,sy,shape)){
          placeBld(sx,sy,shape);
          placed++;
        }
      }
    }
    function pickRandom(arr){return arr[Math.floor(Math.random()*arr.length)];}
    function canPlaceBld(sx,sy,shape){
      for(let y=0;y<shape.height;y++){
        for(let x=0;x<shape.width;x++){
          let v=shape.layout[y][x];
          if(v===1||v===0){
            let t=mapData[sy+y][sx+x].type;
            if(["water","lava","roaddirt","roadstone"].includes(t)){
              return false;
            }
          }
        }
      }
      return true;
    }
    function placeBld(sx,sy,shape){
      let localLay=shape.layout.map(r=>r.slice());
      stampBld(localLay,sx,sy);
    }
    function stampBld(lay,sx,sy){
      for(let y=0;y<lay.length;y++){
        for(let x=0;x<lay[0].length;x++){
          let v=lay[y][x];
          if(v===1) mapData[sy+y][sx+x].type="wall"; // or "cobblestone"
          else if(v===0) mapData[sy+y][sx+x].type=chosenFloorTile;
        }
      }
    }

    /*******************************************************
     * FIELDS
     *******************************************************/
    function createFields(cnt){
      for(let i=0;i<cnt;i++){
        let w=3+Math.floor(Math.random()*5), h=3+Math.floor(Math.random()*5);
        let sx=Math.floor(Math.random()*(GRID_WIDTH-w)), sy=Math.floor(Math.random()*(GRID_HEIGHT-h));
        let farmlandCount=tileAssetMapping["farmland"].files.length;
        let cropIndex=Math.floor(Math.random()*farmlandCount);
        for(let yy=sy;yy<sy+h;yy++){
          for(let xx=sx;xx<sx+w;xx++){
            mapData[yy][xx].type="farmland";
            mapData[yy][xx].crop=cropIndex;
          }
        }
      }
    }

    /*******************************************************
     * CITY WALLS => 3-tile wide convex hull
     *******************************************************/
    let chosenWallImg=null;
    function createConvexCityWalls3Wide(){
      // 1) pick a single tile from tileTextures["wall"] to use
      let arr=tileTextures["wall"]||[];
      if(!arr.length)return;
      chosenWallImg=arr[Math.floor(Math.random()*arr.length)];

      // 2) gather random interior points
      const hullPoints=[];
      const howMany=Math.floor(Math.random()*4)+4; // 4..7 interior points
      for(let i=0;i<howMany;i++){
        let rx=5+Math.floor(Math.random()*(GRID_WIDTH-10));
        let ry=5+Math.floor(Math.random()*(GRID_HEIGHT-10));
        hullPoints.push({x:rx,y:ry});
      }
      // 3) compute convex hull (Graham scan or Andrew's monotone chain)
      let hull=convexHull(hullPoints);

      // 4) connect consecutive hull points with a thick line
      for(let i=0;i<hull.length;i++){
        let j=(i+1)%hull.length;
        carveHullLine(hull[i], hull[j], 1); // radius=1 => 3 wide
      }
    }
    // We'll do Andrew's monotone chain for hull
    function convexHull(pts){
      pts=[...pts].sort((a,b)=> a.x===b.x?(a.y-b.y):(a.x-b.x));
      function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x); }
      const lower=[];
      for(let p of pts){
        while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0){
          lower.pop();
        }
        lower.push(p);
      }
      const upper=[];
      for(let i=pts.length-1;i>=0;i--){
        let p=pts[i];
        while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0){
          upper.pop();
        }
        upper.push(p);
      }
      upper.pop(); lower.pop();
      return lower.concat(upper);
    }
    function carveHullLine(p1,p2,radius){
      let x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y;
      let dx=Math.abs(x2-x1), sx=(x1<x2?1:-1);
      let dy=-Math.abs(y2-y1), sy=(y1<y2?1:-1);
      let err=dx+dy;
      while(true){
        carveWallCircle(x1,y1,radius);
        if(x1===x2&&y1===y2)break;
        let e2=2*err;
        if(e2>=dy){err+=dy;x1+=sx;}
        if(e2<=dx){err+=dx;y1+=sy;}
      }
    }
    function carveWallCircle(cx,cy,r){
      for(let dy=-r;dy<=r;dy++){
        for(let dx=-r;dx<=r;dx++){
          if(dx*dx+dy*dy<=r*r){
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT){
              let t=mapData[ny][nx].type;
              // skip if it's farmland, roads, building floors, doors, etc.
              if(["roaddirt","roadstone","marble1","marble2","marble3","marble4",
                  "farmland","door"].includes(t)){
                continue;
              }
              // else set to "wall_single"
              mapData[ny][nx].type="wall_single";
            }
          }
        }
      }
    }

    /*******************************************************
     * DRAWING
     *******************************************************/
    function drawMap(){
      const canvas=document.getElementById("mapCanvas");
      const ctx=canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          drawCell(ctx,x,y);
        }
      }
    }
    function drawCell(ctx,gx,gy){
      const cell=mapData[gy][gx];
      const px=gx*TILE_SIZE, py=gy*TILE_SIZE;
      if(cell.occupant){
        drawOccupant(ctx, cell.occupant, px, py);
      } 
      else {
        // farmland
        if(cell.type==="farmland"&&cell.crop!==undefined){
          let farmlandArr=tileTextures["farmland"];
          let chosen=farmlandArr[cell.crop];
          if(chosen&&chosen.complete){
            ctx.drawImage(chosen,px,py,TILE_SIZE,TILE_SIZE);
          } else {
            ctx.fillStyle=getColorForTileType("farmland");
            ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
          }
        }
        // city wall single
        else if(cell.type==="wall_single"){
          if(chosenWallImg&&chosenWallImg.complete){
            ctx.drawImage(chosenWallImg, px, py, TILE_SIZE, TILE_SIZE);
          } else {
            ctx.fillStyle=getColorForTileType("wall");
            ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
          }
        }
        else {
          // normal tile
          let arr=tileTextures[cell.type]||[];
          let chosen=arr.length?arr[Math.floor(Math.random()*arr.length)]:null;
          if(chosen&&chosen.complete){
            ctx.drawImage(chosen, px, py, TILE_SIZE, TILE_SIZE);
          } else {
            ctx.fillStyle=getColorForTileType(cell.type);
            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
          }
        }
      }
      // optional grid line
      ctx.strokeStyle="rgba(0,0,0,0.3)";
      ctx.strokeRect(px,py,TILE_SIZE,TILE_SIZE);
    }
    function drawOccupant(ctx, occupant, px, py){
      if(occupant.sprite&&occupant.sprite!=="none"){
        let sp=occupantSpritesMap[occupant.sprite];
        if(sp&&sp.complete){
          ctx.drawImage(sp, px, py, TILE_SIZE, TILE_SIZE);
        } else {
          ctx.fillStyle="#999";
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
        }
      }
      let col=occupantColours[occupant.type]||"#f0f";
      ctx.strokeStyle=col;
      ctx.lineWidth=1;
      ctx.strokeRect(px+0.5,py+0.5,TILE_SIZE-1,TILE_SIZE-1);
    }

    /*******************************************************
     * MODE
     *******************************************************/
    function setMode(mode){
      currentMode=mode;
      if(mode!=="move"){
        occupantInHand=null;
      }
    }

    /*******************************************************
     * CANVAS EVENTS
     *******************************************************/
    const canvas=document.getElementById("mapCanvas");
    const mapWrapper=document.querySelector(".mapWrapper");
    function updateCanvasTransform(){
      canvas.style.transform=`translate(${offsetX}px,${offsetY}px) scale(${scale})`;
    }
    canvas.addEventListener("click",(e)=>{
      if(isDragging||activePointers.size>1)return;
      const rect=mapWrapper.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      const wx=(mx-offsetX)/scale, wy=(my-offsetY)/scale;
      const tx=Math.floor(wx/TILE_SIZE), ty=Math.floor(wy/TILE_SIZE);
      if(tx<0||ty<0||tx>=GRID_WIDTH||ty>=GRID_HEIGHT)return;

      let occupantType=document.getElementById("occupantType").value;
      let occupantSprite=document.getElementById("occupantSprite").value;
      let tile=mapData[ty][tx];
      switch(currentMode){
        case "delete":
          if(tile.occupant){
            tile.occupant=null; occupantInHand=null;
            drawCell(canvas.getContext("2d"),tx,ty);
          }
          break;
        case "move":
          if(!occupantInHand){
            if(tile.occupant){
              occupantInHand=tile.occupant;
              tile.occupant=null;
              drawCell(canvas.getContext("2d"),tx,ty);
            }
          } else {
            tile.occupant=occupantInHand;
            occupantInHand=null;
            drawCell(canvas.getContext("2d"),tx,ty);
          }
          break;
        case "place":
        default:
          occupantInHand=null;
          if(occupantType==="none")return;
          tile.occupant={type:occupantType, sprite:occupantSprite};
          drawCell(canvas.getContext("2d"),tx,ty);
          break;
      }
    });

    canvas.addEventListener("wheel",(e)=>{
      e.preventDefault();
      const rect=mapWrapper.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      const wx=(mx-offsetX)/scale, wy=(my-offsetY)/scale;
      const zSpeed=0.1;
      let newScale=scale+(e.deltaY<0?zSpeed:-zSpeed);
      newScale=Math.min(Math.max(newScale,minScale),maxScale);
      offsetX=mx - wx*newScale;
      offsetY=my - wy*newScale;
      scale=newScale;
      updateCanvasTransform();
    }, {passive:false});

    canvas.addEventListener("pointerdown",(e)=>{
      activePointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(activePointers.size===1){
        isDragging=true; dragStartX=e.clientX; dragStartY=e.clientY;
      } else if(activePointers.size===2){
        isDragging=false;
        initialPinchDistance=getPinchDistance();
        initialPinchScale=scale;
      }
    });
    window.addEventListener("pointermove",(e)=>{
      if(!activePointers.has(e.pointerId))return;
      activePointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      if(activePointers.size===1&&isDragging){
        let dx=e.clientX-dragStartX, dy=e.clientY-dragStartY;
        dragStartX=e.clientX; dragStartY=e.clientY;
        offsetX+=dx; offsetY+=dy;
        updateCanvasTransform();
      } 
      else if(activePointers.size===2){
        let newDist=getPinchDistance();
        let ratio=newDist/initialPinchDistance;
        let newScale=initialPinchScale*ratio;
        newScale=Math.min(Math.max(newScale,minScale),maxScale);
        const rect=mapWrapper.getBoundingClientRect();
        let arr=[...activePointers.values()];
        let midX=(arr[0].x+arr[1].x)/2 - rect.left;
        let midY=(arr[0].y+arr[1].y)/2 - rect.top;
        let wx=(midX-offsetX)/scale, wy=(midY-offsetY)/scale;
        scale=newScale;
        offsetX=midX - wx*newScale;
        offsetY=midY - wy*newScale;
        updateCanvasTransform();
        e.preventDefault();
      }
    });
    window.addEventListener("pointerup",(e)=>{
      activePointers.delete(e.pointerId);
      if(activePointers.size<2) initialPinchDistance=0;
      if(activePointers.size===0) isDragging=false;
    });
    window.addEventListener("pointercancel",(e)=>{
      activePointers.delete(e.pointerId);
      if(activePointers.size<2) initialPinchDistance=0;
      if(activePointers.size===0) isDragging=false;
    });
    function getPinchDistance(){
      if(activePointers.size!==2)return 0;
      let arr=[...activePointers.values()];
      let dx=arr[0].x-arr[1].x, dy=arr[0].y-arr[1].y;
      return Math.sqrt(dx*dx+dy*dy);
    }

    /*******************************************************
     * CLEAR
     *******************************************************/
    function clearOccupantSelection(){
      document.getElementById("occupantType").value="none";
      document.getElementById("occupantSprite").value="none";
    }

    /*******************************************************
     * ONLOAD
     *******************************************************/
    window.onload=()=>{
      preloadImages(()=>{
        generateMap();
      });
    };
  </script>
</body>
</html>
