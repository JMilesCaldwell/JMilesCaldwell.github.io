<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Procedural Battle Map Generator</title>

  <!-- Example fonts; adapt if needed -->
  <link 
    href="https://fonts.googleapis.com/css2?family=Almendra&family=Cinzel:wght@400;700&display=swap"
    rel="stylesheet"
  >

  <style>
    /* Page Styling */
    body {
      margin: 0;
      background: url('resources/mapgen.png') no-repeat center center fixed;
      background-size: cover;
      color: #FAF4E0;
      font-family: 'Almendra', serif;
      text-align: center;
      /* Prevent iOS Safari overscroll background bounce in some cases */
      overscroll-behavior: none;
    }

    .container {
      margin: 2rem auto;
      background: rgba(0, 0, 0, 0.7);
      padding: 2rem;
      border-radius: 10px;
      max-width: 95vw;
    }

    h1, h2 {
      font-family: 'Cinzel', serif;
      margin: 0.5rem 0;
    }

    .description {
      font-size: 1.2rem;
      margin-top: 1rem;
    }

    /* Responsive map wrapper */
    .mapWrapper {
      width: 90vw;
      max-width: 1000px;
      height: 60vh;
      max-height: 700px;
      margin: 1rem auto;
      overflow: hidden;
      position: relative;
      display: block;
      border: 2px solid #660000;
      background: #202020;
    }

    #mapCanvas {
      width: 1000px;
      height: 1000px;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: top left;
      image-rendering: pixelated;
      touch-action: none; 
    }

    .mapButton {
      display: inline-block;
      margin: 0.5rem;
      padding: 0.6rem 1rem;
      font-family: 'Cinzel', serif;
      background: #8B0000;
      color: #FAF4E0;
      border: 1px solid #660000;
      border-radius: 4px;
      cursor: pointer;
      text-decoration: none;
    }
    .mapButton:hover {
      background: #660000;
    }

    .controls {
      margin: 1rem auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .controls label {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      user-select: none;
    }

    .checkboxGroup {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 1rem;
      justify-content: center;
      margin-top: 1rem;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Procedural Battle Map Generator</h1>
    <p class="description">
      "Generate caverns, roads, buildings, farmland, city walls, beaches, swamps, and more."
    </p>

    <div class="controls">
      <label>
        Map Biome:
        <select id="mapType">
          <option value="desert">Desert</option>
          <option value="city">City</option>
          <option value="village">Village</option>
          <option value="grassland" selected>Grassland</option>
          <option value="mountain">Mountain</option>
          <option value="forest">Forest</option>
          <option value="cavern">Cavern</option>
          <option value="volcanic">Volcanic</option>
          <option value="mudlands">Mudlands</option>
          <option value="coastal">Coastal</option>
          <option value="riverlands">Riverlands</option>
          <option value="swamp">Swamp</option>
          <option value="bog">Bog</option>
          <option value="snow">Snow</option>
          <option value="jungle">Jungle</option>
        </select>
      </label>

      <button class="mapButton" onclick="generateMap()">Generate Map</button>

      <label>
        Occupant Type:
        <select id="occupantType">
          <option value="none" selected>None</option>
          <option value="player">Player</option>
          <option value="enemy">Enemy</option>
          <option value="npc">NPC</option>
        </select>
      </label>

      <label>
        Sprite:
        <select id="occupantSprite">
          <option value="none" selected>None</option>
          <!-- Example occupant sprite list; 
               You can expand or edit as needed to match the final sprite folder. -->
          <option value="paladin">paladin</option>
          <option value="assassin">assassin</option>
          <option value="berserker">berserker</option>
          <option value="brigand">brigand</option>
          <option value="chimera">chimera</option>
          <option value="cleric">cleric</option>
          <option value="cultist">cultist</option>
          <option value="darkguard">darkguard</option>
          <option value="darkpriestess">darkpriestess</option>
          <option value="demon">demon</option>
          <option value="druid">druid</option>
          <option value="edgelord">edgelord</option>
          <option value="fallenangel">fallenangel</option>
          <option value="fighter">fighter</option>
          <option value="ghost">ghost</option>
          <option value="goblin">goblin</option>
          <option value="guardian">guardian</option>
          <option value="halfblood">halfblood</option>
          <option value="imp">imp</option>
          <option value="mage">mage</option>
          <option value="ogre">ogre</option>
          <option value="orc">orc</option>
          <option value="orcbandit">orcbandit</option>
          <option value="orcchief">orcchief</option>
          <option value="orkfighter">orkfighter</option>
          <option value="orkshaman">orkshaman</option>
          <option value="priestess">priestess</option>
          <option value="ranger">ranger</option>
          <option value="rat">rat</option>
          <option value="rogue">rogue</option>
          <option value="serpent">serpent</option>
          <option value="sorcerer">sorcerer</option>
          <option value="spider">spider</option>
          <option value="spider2">spider2</option>
          <option value="warlock">warlock</option>
          <option value="wight">wight</option>
          <option value="zombie">zombie</option>
        </select>
      </label>

      <button class="mapButton" onclick="clearOccupantSelection()">Clear</button>
    </div>

    <div class="controls">
      <button class="mapButton" onclick="setMode('place')">Place</button>
      <button class="mapButton" onclick="setMode('delete')">Delete</button>
      <button class="mapButton" onclick="setMode('move')">Move</button>
    </div>

    <div class="checkboxGroup">
      <label>
        <input type="checkbox" id="villageCheck" />
        Village
      </label>
      <label>
        <input type="checkbox" id="fieldsCheck" />
        Fields
      </label>
      <label>
        <input type="checkbox" id="cityWallsCheck" />
        City Walls
      </label>
    </div>

    <div class="mapWrapper">
      <canvas id="mapCanvas" width="1000" height="1000"></canvas>
    </div>

    <div style="margin-top: 1rem;">
      <a href="index.html" class="mapButton">Home</a>
    </div>
  </div>

  <script>
    /*******************************************************
     * BASIC CONFIG & GLOBALS
     *******************************************************/
    const TILE_SIZE = 20;
    const GRID_WIDTH = 50;
    const GRID_HEIGHT = 50;

    let mapData = []; // entire map structure

    // occupantInHand => if carrying an occupant for Move mode
    let occupantInHand = null; 

    // occupant border colours
    const occupantColours = {
      player: "#00FF00",
      enemy:  "#FF0000",
      npc:    "#0000FF"
    };

    // occupant management mode: 'place' | 'delete' | 'move'
    let currentMode = 'place';

    /*******************************************************
     * PAN & ZOOM
     *******************************************************/
    let scale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    const minScale = 0.3;
    const maxScale = 3.0;

    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    /* 
      For pinch-zoom on mobile:
      We'll keep track of all active pointers, 
      and if exactly two are down, we'll do pinch.
    */
    let activePointers = new Map();
    let initialPinchDistance = 0;
    let initialPinchScale = 1.0;

    /*******************************************************
     * MAP TILE STRUCTURE
     * We'll store arrays of possible tiles for each biome.
     * For building walls/floors/doors, we'll keep a few sets. 
     *******************************************************/

    // Biome tile sets:
    // Each item in these arrays is a *relative path* from your "resources/mapgen/mapassets/tiles/" folder.
    // For variety, each array can contain multiple tiles from the same subfolder.
    const biomeTileSets = {
      grassland: [
        "grass/grasstile1.png", 
        "grass/grasstile2.png",
        "grass/grasstile3.png",
        "grass/grasstile4.png",
        "grass/grasstile5.png"
      ],
      desert: [
        "desert/sand1.png",
        "desert/sand2.png",
        "desert/sand3.png",
        "desert/dune1.png"
      ],
      mountain: [
        // We'll treat it mostly as stony/dirt from the "dirt" subfolder
        "dirt/dirt1.png",
        "dirt/dirt2.png",
        "dirt/dirt3.png",
        // Maybe some "rocky" or "cracked" tile for variety
        "dirt/dirtCracked.png"
      ],
      forest: [
        // base forest floor as "grass" plus some chance for shrub or forest folder
        "grass/grasstile1.png",
        "grass/grasstile2.png",
        "grass/grasstile3.png",
        "forest/forestFloor.png" // You can add new forest floor assets if they exist
      ],
      mudlands: [
        "dirt/dirtMud1.png",
        "dirt/dirtMud2.png",
        "dirt/dirtMud3.png"
      ],
      volcanic: [
        "vulcanic/barrens1.png",
        "vulcanic/barrens2.png",
        "vulcanic/lavastone1.png",
        "vulcanic/lavastone2.png"
      ],
      city: [
        // A rough default for "urban"—some cobbled or stony ground
        "buildings/floors/floorCastle.png",
        "buildings/floors/marble1.png",
        "dirt/dirtTile.png" // Possibly a rough tile
      ],
      village: [
        // Slightly more earthy floors in general
        "dirt/dirt1.png",
        "dirt/dirt2.png",
        "grass/grasstile2.png"
      ],
      cavern: [
        // We'll handle the labyrinth logic separately, but here's fallback
        "cavern/cave1.png",
        "cavern/cave2.png"
      ],
      coastal: [
        // Combination of grass and sand for beaches
        "grass/grasstile1.png",
        "grass/grasstile2.png",
        "water/whitesand.png"
      ],
      riverlands: [
        // Lush grass + water edges
        "grass/grasstile3.png",
        "grass/grasstile4.png"
      ],
      swamp: [
        "water/swamp.png",
        "water/swamp2.png",
        "dirt/dirtMud1.png"
      ],
      bog: [
        // Even more watery or muddy
        "dirt/dirtMud2.png",
        "dirt/dirtMud3.png",
        "water/swamp2.png"
      ],
      snow: [
        "snow/snow.png",
        "snow/powdersnow1.png",
        "snow/powdersnow2.png"
      ],
      jungle: [
        "jungle/jungleGrass.png",
        "jungle/junglemud1.png",
        "jungle/junglemud2.png"
      ]
    };

    // Water tile references (for rivers/lakes)
    // We'll let the code pick from these if we need water.
    const waterTiles = [
      "water/water.png"
    ];

    // Additional scatter objects for each biome
    const scatterForBiome = {
      grassland: [
        "grass/grasstree1.png",
        "grass/grasstree2.png"
      ],
      desert: [
        "desert/cactus1.png",
        "desert/cactus2.png",
        "desert/desertpalmtree1.png"
      ],
      mountain: [
        "dirt/dirtRocks1.png",
        "dirt/dirtRocks2.png"
      ],
      forest: [
        "dirt/shrub1.png",
        "dirt/shrub2.png",
        "dirt/shrub3.png"
      ],
      mudlands: [
        "dirt/dirtRocks1.png",
        "dirt/dirtRocks2.png"
      ],
      volcanic: [
        "vulcanic/magma.png",
        "vulcanic/brimstone.png",
        "vulcanic/brimstone2.png"
      ],
      city: [
        // maybe minimal scatter
      ],
      village: [
        "grass/grasstree1.png"
      ],
      cavern: [
        "cavern/caveRock.png",
        "cavern/caveRockLarge.png",
        "cavern/caveBones.png"
      ],
      coastal: [
        "water/whitesand.png",
        "water/waterrocks.png"
      ],
      riverlands: [
        "water/waterrocks2.png",
        "grass/grasstree1.png"
      ],
      swamp: [
        "dirt/shrub2.png",
        "water/waterrocks.png"
      ],
      bog: [
        "cavern/caveBog.png"
      ],
      snow: [
        "snow/snowTree.png"
      ],
      jungle: [
        "jungle/junglefern.png",
        "jungle/junglelog.png",
        "jungle/junglebush.png"
      ]
    };

    // Building walls, floors, doors
    const buildingWallSets = {
      cobble: [
        "buildings/walls/cobble1.png",
        "buildings/walls/cobble2.png",
        "buildings/walls/cobble3.png",
        "buildings/walls/cobble4.png"
      ],
      brick: [
        "buildings/walls/brick1.png",
        "buildings/walls/brick2.png",
        "buildings/walls/brick3.png",
        "buildings/walls/brick4.png",
        "buildings/walls/brick5.png"
      ],
      limestone: [
        "buildings/walls/limestone1.png",
        "buildings/walls/limestone2.png",
        "buildings/walls/limestone3.png"
      ],
      darkstone: [
        "buildings/walls/darkStoneBlock.png",
        "buildings/walls/darktile1.png",
        "buildings/walls/darktile2.png",
        "buildings/walls/darktile3.png",
        "buildings/walls/darktile4.png"
      ]
      // add more sets if you wish...
    };

    const buildingFloorSets = {
      marble: [
        "buildings/floors/marble1.png",
        "buildings/floors/marble2.png",
        "buildings/floors/marble3.png",
        "buildings/floors/marble4.png"
      ],
      castle: [
        "buildings/floors/floorCastle.png"
      ],
      sandstone: [
        "buildings/floors/sandstonetile.png"
      ],
      wood: [
        "buildings/floors/woodfloor.png"
      ],
      rubble: [
        "buildings/floors/PlainTileRubble1.png",
        "buildings/floors/PlainTileRubble2.png",
        "buildings/floors/PlainTileRubble3.png"
      ]
    };

    const buildingDoorOptions = [
      "buildings/doors/doorWood1.png",
      "buildings/doors/doorWood2.png",
      "buildings/doors/gateStone.png",
      "buildings/doors/gateStone2.png"
    ];

    // The image objects themselves after loading
    const tileTextures = {};
    const occupantSpritesMap = {};

    /*******************************************************
     * HELPER FUNCTIONS
     *******************************************************/
    function pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    // We'll keep a dictionary for "loaded" images keyed by their path (the sub-path).
    // Then, tileTextures[tileKey] = the Image object.
    function getImage(path) {
      // path example: "grass/grasstile1.png"
      // We want to prefix with "resources/mapgen/mapassets/tiles/"
      const fullPath = `resources/mapgen/mapassets/tiles/${path}`;
      return tileTextures[fullPath];
    }

    function getDoorImage() {
      const path = pickRandom(buildingDoorOptions);
      return tileTextures[`resources/mapgen/mapassets/tiles/${path}`];
    }

    // Quick map cell object:
    function makeCell(tilePath) {
      return {
        tilePath,      // which tile texture (relative path)
        occupant: null
      };
    }

    /*******************************************************
     * PRELOAD IMAGES
     *******************************************************/
    // 1) Gather every tile path from the above arrays
    // 2) occupant sprites
    function preloadImages(onComplete) {
      const occupantSpriteNames = [
        "asassin","assassin","bat","berserker","brigand","chimera","cleric","cultist","darkguard",
        "darkpriestess","demon","druid","edgelord","fallenangel","fighter","ghost","goblin",
        "guardian","halfblood","imp","mage","ogre","orc","orcbandit","orcchief","orkfighter",
        "orkshaman","paladin","priestess","ranger","rat","rogue","serpent","sorcerer","spider",
        "spider2","warlock","wight","zombie"
      ];
      // Clean out duplicates like 'asassin' vs 'assassin' if needed; we can just load them all.

      const allBiomePaths = Object.values(biomeTileSets).flat();
      const allScatterPaths = Object.values(scatterForBiome).flat();
      const allWallPaths = Object.values(buildingWallSets).flat();
      const allFloorPaths = Object.values(buildingFloorSets).flat();
      // Doors:
      const allDoorPaths = buildingDoorOptions;

      // Water paths:
      const otherPaths = waterTiles;

      // Combine them:
      const tilePaths = [
        ...allBiomePaths,
        ...allScatterPaths,
        ...allWallPaths,
        ...allFloorPaths,
        ...allDoorPaths,
        ...otherPaths
      ];

      // Convert each tile path to a full path "resources/mapgen/mapassets/tiles/..."
      const uniqueTileFullPaths = Array.from(
        new Set(tilePaths.map(p => `resources/mapgen/mapassets/tiles/${p}`))
      );

      const totalToLoad = uniqueTileFullPaths.length + occupantSpriteNames.length;
      let loadedCount = 0;

      function checkDone() {
        loadedCount++;
        if (loadedCount >= totalToLoad && onComplete) {
          onComplete();
        }
      }

      // Load tile textures
      for (let fullPath of uniqueTileFullPaths) {
        const img = new Image();
        img.src = fullPath;
        img.onload = checkDone;
        img.onerror = checkDone;
        tileTextures[fullPath] = img; 
      }

      // Load occupant sprites
      occupantSpriteNames.forEach(spriteName => {
        const img = new Image();
        img.src = `resources/mapgen/mapassets/sprites/${spriteName}.png`;
        img.onload = checkDone;
        img.onerror = checkDone;
        occupantSpritesMap[spriteName] = img;
      });
    }

    /*******************************************************
     * MAIN MAP GENERATION
     *******************************************************/
    function generateMap() {
      occupantInHand = null; // reset occupant carrying
      offsetX = 0;
      offsetY = 0;
      scale = 1.0;
      updateCanvasTransform();

      const theme = document.getElementById("mapType").value;
      const doVillage = document.getElementById("villageCheck").checked;
      const doCityWalls = document.getElementById("cityWallsCheck").checked;
      const doFields = document.getElementById("fieldsCheck").checked;

      if (theme === "cavern") {
        generateCavern();
      } else {
        // Basic fill
        initMap(theme);

        // Possibly add large water feature or river
        maybeAddRiversOrPonds(theme);

        // Add roads in some biomes
        maybeAddRoads(theme);

        // If farmland requested
        if (doFields) {
          createFarmlandPatches(theme);
        }

        // If there's a chance for additional scatter (trees, cacti, etc.)
        addScatter(theme);
      }

      // If user wants a "village" => generate buildings
      if (doVillage && theme !== "cavern") {
        createBuildings(theme);
      }

      // If user wants city walls => ring the perimeter with walls
      if (doCityWalls) {
        createCityWalls();
      }

      drawMap();
    }

    /** Fills mapData with random picks from the biome tile set. */
    function initMap(theme) {
      const baseArray = biomeTileSets[theme] || biomeTileSets["grassland"]; 
      mapData = [];
      for (let y = 0; y < GRID_HEIGHT; y++) {
        let row = [];
        for (let x = 0; x < GRID_WIDTH; x++) {
          const chosenTile = pickRandom(baseArray);
          row.push(makeCell(chosenTile));
        }
        mapData.push(row);
      }
    }

    /**
     * Add random rivers or ponds. 
     * For coastal: maybe we add a “coast” along one edge with water. 
     * For riverlands, maybe a bigger winding river. 
     */
    function maybeAddRiversOrPonds(theme) {
      // Examples
      if (theme === "coastal") {
        // Make left side or bottom side watery
        let edge = Math.random() < 0.5 ? "left" : "bottom";
        if (edge === "left") {
          for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < 5; x++) {
              mapData[y][x].tilePath = pickRandom(waterTiles);
            }
          }
        } else {
          for (let x = 0; x < GRID_WIDTH; x++) {
            for (let y = GRID_HEIGHT - 5; y < GRID_HEIGHT; y++) {
              mapData[y][x].tilePath = pickRandom(waterTiles);
            }
          }
        }
      } 
      else if (theme === "riverlands" || theme === "swamp" || theme === "bog") {
        // Just do a random vertical or horizontal river
        const horizontal = Math.random() < 0.5;
        if (horizontal) {
          let riverY = Math.floor(GRID_HEIGHT * 0.3 + Math.random() * 0.4 * GRID_HEIGHT);
          let width = Math.floor(Math.random() * 3) + 2; 
          for (let y = riverY; y < riverY + width; y++) {
            if (y < 0 || y >= GRID_HEIGHT) continue;
            for (let x = 0; x < GRID_WIDTH; x++) {
              mapData[y][x].tilePath = pickRandom(waterTiles);
            }
          }
        } else {
          let riverX = Math.floor(GRID_WIDTH * 0.3 + Math.random() * 0.4 * GRID_WIDTH);
          let width = Math.floor(Math.random() * 3) + 2;
          for (let x = riverX; x < riverX + width; x++) {
            if (x < 0 || x >= GRID_WIDTH) continue;
            for (let y = 0; y < GRID_HEIGHT; y++) {
              mapData[y][x].tilePath = pickRandom(waterTiles);
            }
          }
        }
      } 
      else if (theme === "volcanic") {
        // "Rivers" of lava
        let doLavaRiver = Math.random() < 0.7;
        if (doLavaRiver) {
          carveLavaRiver();
        }
      } 
      else {
        // Random chance of a small pond
        if (Math.random() < 0.4) {
          createPond();
        }
      }
    }

    function createPond() {
      let sx = Math.floor(Math.random() * GRID_WIDTH);
      let sy = Math.floor(Math.random() * GRID_HEIGHT);
      let size = 20 + Math.floor(Math.random() * 40);
      floodFillWater(sx, sy, size, pickRandom(waterTiles));
    }

    function floodFillWater(sx, sy, maxSize, waterTile) {
      let stack = [[sx, sy]];
      let size = 0;
      while (stack.length && size < maxSize) {
        const [cx, cy] = stack.pop();
        if (cx < 0 || cy < 0 || cx >= GRID_WIDTH || cy >= GRID_HEIGHT) continue;
        if (mapData[cy][cx].tilePath === waterTile) continue;
        if (Math.random() < 0.25) continue; // skip some expansions
        mapData[cy][cx].tilePath = waterTile;
        size++;
        stack.push([cx + 1, cy],[cx - 1, cy],[cx, cy + 1],[cx, cy - 1]);
      }
    }

    function carveLavaRiver() {
      // Simple horizontal or vertical. 
      let horizontal = Math.random() < 0.5;
      let tile = pickRandom([
        "vulcanic/lava1.png", 
        "vulcanic/lava2.png", 
        "vulcanic/lava3.png"
      ]);
      if (horizontal) {
        const ry = Math.floor(Math.random() * GRID_HEIGHT);
        const thickness = 2 + Math.floor(Math.random() * 3);
        for (let t = 0; t < thickness; t++) {
          let rowY = ry + t;
          if (rowY < 0 || rowY >= GRID_HEIGHT) continue;
          for (let x = 0; x < GRID_WIDTH; x++) {
            mapData[rowY][x].tilePath = tile;
          }
        }
      } else {
        const rx = Math.floor(Math.random() * GRID_WIDTH);
        const thickness = 2 + Math.floor(Math.random() * 3);
        for (let t = 0; t < thickness; t++) {
          let colX = rx + t;
          if (colX < 0 || colX >= GRID_WIDTH) continue;
          for (let y = 0; y < GRID_HEIGHT; y++) {
            mapData[y][colX].tilePath = tile;
          }
        }
      }
    }

    function maybeAddRoads(theme) {
      // We won't do roads in cavern, obviously. 
      // Let's add fewer or more roads depending on the theme.
      let roadsCount = 0;
      switch (theme) {
        case "city": roadsCount = 4; break;
        case "village": roadsCount = 2; break;
        case "grassland": roadsCount = 2; break;
        case "forest": roadsCount = 1; break;
        case "mountain": roadsCount = 1; break;
        default: 
          roadsCount = 1; 
          break;
      }
      for (let i = 0; i < roadsCount; i++) {
        createRoad(50, 2, 3); 
      }
    }

    // We'll keep a road texture from "dirt/roadDirt.png" or "buildings/floors/sandstonetile.png"
    function createRoad(maxLength, minW, maxW) {
      let x, y;
      if (Math.random() < 0.5) {
        x = Math.floor(Math.random() * GRID_WIDTH);
        y = (Math.random() < 0.5) ? 0 : GRID_HEIGHT - 1;
      } else {
        x = (Math.random() < 0.5) ? 0 : GRID_WIDTH - 1;
        y = Math.floor(Math.random() * GRID_HEIGHT);
      }
      let direction = getRandomDirection();
      const length = Math.floor(Math.random() * (maxLength / 2) + maxLength / 2);
      const w = Math.floor(Math.random() * (maxW - minW + 1)) + minW;

      // Choose a random road tile
      let roadTile = Math.random() < 0.5 
                     ? "dirt/roadDirt.png" 
                     : "buildings/floors/sandstonetile.png";

      for (let i = 0; i < length; i++) {
        carveRoad(x, y, w, roadTile);
        x += direction.dx;
        y += direction.dy;
        if (Math.random() < 0.2) direction = getRandomDirection(direction);
        if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) break;
      }
    }

    function carveRoad(cx, cy, width, roadTile) {
      const r = Math.floor(width / 2);
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          let nx = cx + dx, ny = cy + dy;
          if(nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
            mapData[ny][nx].tilePath = roadTile;
          }
        }
      }
    }

    function getRandomDirection(prevDir) {
      const dirs = [
        {dx:1, dy:0}, {dx:-1, dy:0}, 
        {dx:0, dy:1}, {dx:0, dy:-1}
      ];
      if (prevDir && Math.random() < 0.6) return prevDir;
      return dirs[Math.floor(Math.random() * dirs.length)];
    }

    // Scatter random objects that fit the theme
    function addScatter(theme) {
      const scatterItems = scatterForBiome[theme] || [];
      if (!scatterItems.length) return;

      // We'll attempt to place some scatter. 
      const totalScatter = Math.floor(Math.random() * 120); 
      for (let i = 0; i < totalScatter; i++) {
        let rx = Math.floor(Math.random() * GRID_WIDTH);
        let ry = Math.floor(Math.random() * GRID_HEIGHT);
        // Skip if tile is water or lava, etc.
        let currentPath = mapData[ry][rx].tilePath;
        if (/water|lava/.test(currentPath)) continue;
        // 20% chance to place scatter
        if (Math.random() < 0.2) {
          mapData[ry][rx].tilePath = pickRandom(scatterItems);
        }
      }
    }

    /*******************************************************
     * FARMLAND
     *******************************************************/
    function createFarmlandPatches(theme) {
      // We'll place 1-3 farmland rectangles in random places,
      // using farmland crops from "farmland" folder
      const farmlandTiles = [
        "farmland/corn.png",
        "farmland/pumpkins.png",
        "farmland/rye.png",
        "farmland/sunflowers.png",
        "farmland/vinyard.png",
        "farmland/wheat.png"
      ];
      let count = 1 + Math.floor(Math.random() * 3);
      for (let i=0; i<count; i++) {
        let w = 5 + Math.floor(Math.random() * 8);
        let h = 4 + Math.floor(Math.random() * 8);
        let sx = Math.floor(Math.random() * (GRID_WIDTH - w));
        let sy = Math.floor(Math.random() * (GRID_HEIGHT - h));
        let chosenCrop = pickRandom(farmlandTiles);
        // Stamp out a farmland patch
        for (let y = sy; y < sy + h; y++) {
          for (let x = sx; x < sx + w; x++) {
            // Slight chance to skip
            if (Math.random() < 0.15) continue;
            mapData[y][x].tilePath = chosenCrop;
          }
        }
      }
    }

    /*******************************************************
     * CITY WALLS
     *******************************************************/
    function createCityWalls() {
      // Let’s pick a random wall set
      let possibleSets = Object.keys(buildingWallSets);
      let chosenSet = pickRandom(possibleSets);
      let wallSet = buildingWallSets[chosenSet];

      // We'll ring the perimeter with one random tile from that set
      let wallTile = pickRandom(wallSet);

      // top edge
      for (let x=0; x<GRID_WIDTH; x++) {
        mapData[0][x].tilePath = wallTile;
      }
      // bottom edge
      for (let x=0; x<GRID_WIDTH; x++) {
        mapData[GRID_HEIGHT-1][x].tilePath = wallTile;
      }
      // left edge
      for (let y=0; y<GRID_HEIGHT; y++) {
        mapData[y][0].tilePath = wallTile;
      }
      // right edge
      for (let y=0; y<GRID_HEIGHT; y++) {
        mapData[y][GRID_WIDTH-1].tilePath = wallTile;
      }
    }

    /*******************************************************
     * BUILDINGS (Village or city-ish)
     *******************************************************/
    function createBuildings(theme) {
      // We'll place some number of buildings
      const numBuildings = 4 + Math.floor(Math.random()*4);
      for (let i=0; i<numBuildings; i++) {
        placeRandomBuilding();
      }
    }

    function placeRandomBuilding() {
      // Pick random building shape from a set
      const buildingShapes = [
        { width:4, height:4 },
        { width:5, height:5 },
        { width:6, height:5 },
        { width:7, height:5 }
      ];
      const shape = pickRandom(buildingShapes);
      // Random location
      const sx = Math.floor(Math.random()*(GRID_WIDTH - shape.width));
      const sy = Math.floor(Math.random()*(GRID_HEIGHT - shape.height));

      // Check if we can place
      if (!canPlaceBuilding(sx, sy, shape)) return;

      // pick a random wall set & floor set
      let possibleWalls = Object.keys(buildingWallSets);
      let chosenWallSetName = pickRandom(possibleWalls);
      let wallSet = buildingWallSets[chosenWallSetName];

      let possibleFloors = Object.keys(buildingFloorSets);
      let chosenFloorSetName = pickRandom(possibleFloors);
      let floorSet = buildingFloorSets[chosenFloorSetName];

      // create layout
      let layout = createBasicBuildingLayout(shape, pickRandom(wallSet), pickRandom(floorSet));
      // place a door or two
      addDoorsToBuildingLayout(layout, shape);

      // stamp onto the map
      stampBuilding(sx, sy, layout);
    }

    // Just do a simple check to avoid water/lava/solid obstacles
    function canPlaceBuilding(sx, sy, shape) {
      for (let y=0; y<shape.height; y++) {
        for (let x=0; x<shape.width; x++) {
          let tile = mapData[sy+y][sx+x].tilePath;
          // if tile has water or lava, skip
          if (/water|lava/.test(tile)) return false;
        }
      }
      return true;
    }

    // Create a minimal rectangular building layout
    // We'll store each cell as either wallTile or floorTile.
    // Doors will be handled separately.
    function createBasicBuildingLayout(shape, wallTile, floorTile) {
      let layout = [];
      for (let y=0; y<shape.height; y++) {
        let row = [];
        for (let x=0; x<shape.width; x++) {
          if (y===0 || y===shape.height-1 || x===0 || x===shape.width-1) {
            row.push(wallTile);
          } else {
            row.push(floorTile);
          }
        }
        layout.push(row);
      }
      return layout;
    }

    function addDoorsToBuildingLayout(layout, shape) {
      // Randomly pick 1-2 edges for the door
      let doorCount = 1 + Math.floor(Math.random()*2);
      for (let i=0; i<doorCount; i++) {
        let edge = Math.floor(Math.random()*4);
        switch(edge) {
          case 0: { 
            // top edge
            let x = 1 + Math.floor(Math.random()*(shape.width-2));
            layout[0][x] = pickRandom(buildingDoorOptions);
            break;
          }
          case 1: {
            // bottom
            let x = 1 + Math.floor(Math.random()*(shape.width-2));
            layout[shape.height-1][x] = pickRandom(buildingDoorOptions);
            break;
          }
          case 2: {
            // left
            let y = 1 + Math.floor(Math.random()*(shape.height-2));
            layout[y][0] = pickRandom(buildingDoorOptions);
            break;
          }
          case 3: {
            // right
            let y = 1 + Math.floor(Math.random()*(shape.height-2));
            layout[y][shape.width-1] = pickRandom(buildingDoorOptions);
            break;
          }
        }
      }
    }

    function stampBuilding(sx, sy, layout) {
      for (let y=0; y<layout.length; y++) {
        for (let x=0; x<layout[0].length; x++) {
          mapData[sy+y][sx+x].tilePath = layout[y][x];
        }
      }
    }

    /*******************************************************
     * CAVERN GENERATION
     *******************************************************/
    function generateCavern() {
      // We do a random bool map => run cellular automata => keep largest region => carve "rooms"
      // Then fill that region with cave floors, outside region => black or solid block
      let fillChance = 0.48;
      let boolMap = randomBoolMap(fillChance);
      let steps = 5 + Math.floor(Math.random()*3);
      for (let i=0; i<steps; i++){
        boolMap = doCAStep(boolMap);
      }
      const { largestMap } = keepLargestRegion(boolMap);
      carveRandomOpenings(largestMap);
      convertCavernBoolMapToTiles(largestMap);
      addCavernScatter(); 
    }

    function randomBoolMap(fillChance) {
      let bm = [];
      for (let y=0; y<GRID_HEIGHT; y++) {
        let row = [];
        for (let x=0; x<GRID_WIDTH; x++){
          row.push(Math.random() < fillChance);
        }
        bm.push(row);
      }
      return bm;
    }

    function doCAStep(boolMap) {
      let newMap = [];
      for (let y=0; y<GRID_HEIGHT; y++) {
        let row=[];
        for(let x=0; x<GRID_WIDTH; x++){
          const n = countFloorNeighbours(boolMap, x, y);
          const curr = boolMap[y][x];
          if (curr) {
            row.push(n>=4);
          } else {
            row.push(n>=5);
          }
        }
        newMap.push(row);
      }
      return newMap;
    }

    function countFloorNeighbours(bm, cx, cy) {
      let c=0;
      for (let dy=-1; dy<=1; dy++){
        for (let dx=-1; dx<=1; dx++){
          if(dx===0 && dy===0) continue;
          let nx=cx+dx, ny=cy+dy;
          if(nx>=0 && ny>=0 && nx<GRID_WIDTH && ny<GRID_HEIGHT){
            if(bm[ny][nx]) c++;
          }
        }
      }
      return c;
    }

    function keepLargestRegion(boolMap) {
      let visited = [];
      for (let y=0;y<GRID_HEIGHT;y++){
        visited[y] = new Array(GRID_WIDTH).fill(false);
      }
      let bestSize=0, bestRegion=[];
      for(let y=0; y<GRID_HEIGHT; y++){
        for(let x=0; x<GRID_WIDTH; x++){
          if(boolMap[y][x] && !visited[y][x]){
            let queue=[[x,y]];
            visited[y][x]=true;
            let regionCells=[[x,y]];
            let size=1;
            while(queue.length){
              const [cx, cy] = queue.pop();
              for(let [nx, ny] of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]){
                if(nx>=0 && ny>=0 && nx<GRID_WIDTH && ny<GRID_HEIGHT){
                  if(boolMap[ny][nx] && !visited[ny][nx]){
                    visited[ny][nx] = true;
                    queue.push([nx,ny]);
                    regionCells.push([nx,ny]);
                    size++;
                  }
                }
              }
            }
            if(size>bestSize){
              bestSize=size;
              bestRegion=regionCells;
            }
          }
        }
      }
      let largestMap=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        largestMap[y] = boolMap[y].slice();
      }
      let regionSet = new Set(bestRegion.map(([xx,yy])=>`${xx},${yy}`));
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          if(largestMap[y][x] && !regionSet.has(`${x},${y}`)){
            largestMap[y][x] = false;
          }
        }
      }
      return { largestMap, largestRegion: bestRegion };
    }

    function carveRandomOpenings(boolMap) {
      // We'll add 1-3 random openings on the edges
      let openings=0;
      for(let x=0; x<GRID_WIDTH; x++){
        if(boolMap[0][x]||boolMap[GRID_HEIGHT-1][x]) openings++;
      }
      for(let y=0; y<GRID_HEIGHT; y++){
        if(boolMap[y][0]||boolMap[y][GRID_WIDTH-1]) openings++;
      }
      if(openings<1) carveRandomLine(boolMap);
      if(openings<2) carveRandomLine(boolMap);
      if(openings<3 && Math.random()<0.5) carveRandomLine(boolMap);
    }

    function carveRandomLine(boolMap) {
      let tries=0; 
      let cx, cy;
      while(tries<500){
        cx=Math.floor(Math.random()*GRID_WIDTH);
        cy=Math.floor(Math.random()*GRID_HEIGHT);
        if(boolMap[cy][cx]) break;
        tries++;
      }
      let ex=(Math.random()<0.5)?0:GRID_WIDTH-1;
      let ey=Math.floor(Math.random()*GRID_HEIGHT);
      carveLine(boolMap,cx,cy,ex,ey);
    }

    function carveLine(boolMap,x1,y1,x2,y2) {
      let steps=0;
      while((x1!==x2||y1!==y2)&&steps<2000){
        boolMap[y1][x1]=true;
        if(x1<x2) x1++; else if(x1>x2) x1--;
        if(y1<y2) y1++; else if(y1>y2) y1--;
        steps++;
      }
      if(x1>=0 && x1<GRID_WIDTH && y1>=0 && y1<GRID_HEIGHT){
        boolMap[y1][x1]=true;
      }
    }

    function convertCavernBoolMapToTiles(boolMap) {
      mapData=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          if(boolMap[y][x]){
            // floor tile
            // pick from "cavern/cave1.png" or "cavern/cave2.png"
            let base = pickRandom(["cavern/cave1.png","cavern/cave2.png","cavern/caveMoss1.png","cavern/caveMoss2.png"]);
            row.push({ tilePath: base, occupant: null});
          } else {
            // wall => black or "buildings/walls/caveWall.png"
            let type = Math.random()<0.8 ? "black" : "buildings/walls/caveWall.png";
            row.push({ tilePath: type, occupant: null});
          }
        }
        mapData.push(row);
      }
    }

    // Place some scatter in the largest open floor
    function addCavernScatter() {
      // same approach: random lumps of caveRock, bones, puddles
      const caveScatters = ["cavern/caveBones.png","cavern/caveRock.png","cavern/caveRockLarge.png","cavern/cavePuddle.png"];
      let tries = 200;
      while(tries>0) {
        tries--;
        let x=Math.floor(Math.random()*GRID_WIDTH);
        let y=Math.floor(Math.random()*GRID_HEIGHT);
        let tile=mapData[y][x].tilePath;
        if(tile.includes("cave") || tile.includes("moss")){
          if(Math.random()<0.1) {
            mapData[y][x].tilePath = pickRandom(caveScatters);
          }
        }
      }
    }

    /*******************************************************
     * RENDERING
     *******************************************************/
    function drawMap(){
      const canvas = document.getElementById("mapCanvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);

      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          drawCell(ctx,x,y);
        }
      }
    }

    function drawCell(ctx, gx, gy) {
      const cell = mapData[gy][gx];
      const px = gx * TILE_SIZE;
      const py = gy * TILE_SIZE;

      // If tilePath is "black", fill black
      if (cell.tilePath === "black") {
        ctx.fillStyle = "#000000";
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
      }
      else {
        // normal tile
        const imgObj = getImage(cell.tilePath);
        if (imgObj && imgObj.complete) {
          ctx.drawImage(imgObj, px, py, TILE_SIZE, TILE_SIZE);
        } else {
          // fallback fill
          ctx.fillStyle = "#888";
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      }

      // occupant
      if (cell.occupant) {
        drawOccupantSprite(ctx, cell.occupant, px, py);
      }

      // optional grid line
      ctx.strokeStyle="rgba(0,0,0,0.3)";
      ctx.strokeRect(px,py,TILE_SIZE,TILE_SIZE);
    }

    function drawOccupantSprite(ctx, occupant, px, py) {
      if(occupant.sprite && occupant.sprite !== "none"){
        const spriteImg = occupantSpritesMap[occupant.sprite];
        if(spriteImg && spriteImg.complete){
          ctx.drawImage(spriteImg, px, py, TILE_SIZE, TILE_SIZE);
        } else {
          // fallback occupant colour
          ctx.fillStyle="#999";
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      }
      const borderColor = occupantColours[occupant.type] || "#FF00FF";
      ctx.strokeStyle=borderColor;
      ctx.lineWidth=1;
      ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
    }

    /*******************************************************
     * MODE SELECTOR (Place, Delete, Move)
     *******************************************************/
    function setMode(mode){
      currentMode = mode;
      if(currentMode !== 'move'){
        occupantInHand = null;
      }
    }

    /*******************************************************
     * CANVAS EVENTS => Occupant & Panning & Pinch
     *******************************************************/
    const canvas = document.getElementById("mapCanvas");
    const mapWrapper = document.querySelector(".mapWrapper");

    function updateCanvasTransform(){
      canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
    }

    canvas.addEventListener("click",(e)=>{
      if(isDragging || activePointers.size > 1) return;

      const wrapperRect = mapWrapper.getBoundingClientRect();
      const mouseXInWrapper = e.clientX - wrapperRect.left;
      const mouseYInWrapper = e.clientY - wrapperRect.top;

      const worldX = (mouseXInWrapper - offsetX) / scale;
      const worldY = (mouseYInWrapper - offsetY) / scale;

      const tileX = Math.floor(worldX / TILE_SIZE);
      const tileY = Math.floor(worldY / TILE_SIZE);
      if(tileX<0||tileY<0||tileX>=GRID_WIDTH||tileY>=GRID_HEIGHT) return;

      const occupantType = document.getElementById("occupantType").value;
      const occupantSprite = document.getElementById("occupantSprite").value;
      const tile = mapData[tileY][tileX];

      switch(currentMode){
        case 'delete':
          if(tile.occupant){
            tile.occupant = null;
            occupantInHand = null;
            drawCell(canvas.getContext("2d"), tileX, tileY);
          }
          break;
        case 'move':
          if(!occupantInHand){
            if(tile.occupant){
              occupantInHand = tile.occupant;
              tile.occupant = null;
              drawCell(canvas.getContext("2d"), tileX, tileY);
            }
          } else {
            tile.occupant = occupantInHand;
            occupantInHand = null;
            drawCell(canvas.getContext("2d"), tileX, tileY);
          }
          break;
        case 'place':
        default:
          occupantInHand = null;
          if(occupantType === "none") return;
          tile.occupant = {
            type: occupantType,
            sprite: occupantSprite
          };
          drawCell(canvas.getContext("2d"), tileX, tileY);
          break;
      }
    });

    // DESKTOP WHEEL => Zoom
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const wrapperRect = mapWrapper.getBoundingClientRect();
      const mouseX = e.clientX - wrapperRect.left;
      const mouseY = e.clientY - wrapperRect.top;

      const worldX = (mouseX - offsetX) / scale;
      const worldY = (mouseY - offsetY) / scale;

      const zoomSpeed = 0.1;
      let newScale = scale;
      if(e.deltaY < 0) {
        newScale += zoomSpeed;
      } else {
        newScale -= zoomSpeed;
      }
      newScale = Math.min(Math.max(newScale, minScale), maxScale);

      offsetX = mouseX - worldX * newScale;
      offsetY = mouseY - worldY * newScale;
      scale = newScale;

      updateCanvasTransform();
    }, { passive: false });

    canvas.addEventListener("pointerdown", (e) => {
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      // If only one pointer is down => we might drag
      if (activePointers.size === 1) {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
      }
      // If two pointers => pinch
      else if (activePointers.size === 2) {
        isDragging = false; 
        initialPinchDistance = getPinchDistance();
        initialPinchScale = scale;
      }
    });

    window.addEventListener("pointermove", (e) => {
      if (!activePointers.has(e.pointerId)) return;

      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePointers.size === 1 && isDragging) {
        // single-finger panning
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        offsetX += dx;
        offsetY += dy;
        updateCanvasTransform();
      } 
      else if (activePointers.size === 2) {
        // pinch zoom
        const newDist = getPinchDistance();
        const scaleRatio = newDist / initialPinchDistance;
        let newScale = initialPinchScale * scaleRatio;
        newScale = Math.min(Math.max(newScale, minScale), maxScale);

        const midpoint = getPinchMidpoint();
        const wrapperRect = mapWrapper.getBoundingClientRect();
        const midXInWrapper = midpoint.x - wrapperRect.left;
        const midYInWrapper = midpoint.y - wrapperRect.top;

        const worldX = (midXInWrapper - offsetX) / scale;
        const worldY = (midYInWrapper - offsetY) / scale;

        scale = newScale;
        offsetX = midXInWrapper - worldX * newScale;
        offsetY = midYInWrapper - worldY * newScale;
        updateCanvasTransform();

        e.preventDefault();
      }
    });

    window.addEventListener("pointerup", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) {
        initialPinchDistance = 0;
      }
      if (activePointers.size === 0) {
        isDragging = false;
      }
    });

    window.addEventListener("pointercancel", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) {
        initialPinchDistance = 0;
      }
      if (activePointers.size === 0) {
        isDragging = false;
      }
    });

    function getPinchDistance() {
      if (activePointers.size !== 2) return 0;
      const points = [...activePointers.values()];
      const dx = points[0].x - points[1].x;
      const dy = points[0].y - points[1].y;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function getPinchMidpoint() {
      const points = [...activePointers.values()];
      const x = (points[0].x + points[1].x) / 2;
      const y = (points[0].y + points[1].y) / 2;
      return { x, y };
    }

    /*******************************************************
     * CLEAR button => occupantType = none, occupantSprite = none
     *******************************************************/
    function clearOccupantSelection() {
      document.getElementById("occupantType").value = "none";
      document.getElementById("occupantSprite").value = "none";
    }

    /*******************************************************
     * ON LOAD
     *******************************************************/
    window.onload=()=>{
      preloadImages(()=>{
        generateMap();
      });
    };
  </script>
</body>
</html>
