<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
        }
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
        }
        .info {
            margin-top: 20px;
            text-align: center;
            color: #888;
            font-size: 14px;
        }
        .info kbd {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        .coords {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <canvas id="fractal"></canvas>
    <div class="info">
        <kbd>↑</kbd> Zoom In &nbsp;&nbsp; <kbd>↓</kbd> Zoom Out &nbsp;&nbsp; Click to recenter
    </div>
    <div class="coords" id="coords"></div>

    <script>
        const canvas = document.getElementById('fractal');
        const ctx = canvas.getContext('2d');
        const coordsEl = document.getElementById('coords');

        // Set canvas size
        const size = Math.min(window.innerWidth - 40, window.innerHeight - 120, 800);
        canvas.width = size;
        canvas.height = size;

        // Mandelbrot parameters
        let centerX = -0.5;
        let centerY = 0;
        let zoom = 1;
        const maxIterations = 256;

        // Animation state
        let targetZoom = zoom;
        let targetCenterX = centerX;
        let targetCenterY = centerY;
        let isAnimating = false;
        const zoomSpeed = 0.08;
        const panSpeed = 0.12;

        // Track held keys for continuous zoom
        const keysHeld = { up: false, down: false };

        // Color palette
        function getColor(iterations) {
            if (iterations === maxIterations) return [0, 0, 0];
            
            const hue = (iterations / maxIterations) * 360;
            const saturation = 100;
            const lightness = iterations < maxIterations ? 50 : 0;
            
            const h = hue / 360;
            const s = saturation / 100;
            const l = lightness / 100;
            
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function mandelbrot(cx, cy) {
            let x = 0, y = 0;
            let iteration = 0;
            
            while (x * x + y * y <= 4 && iteration < maxIterations) {
                const xTemp = x * x - y * y + cx;
                y = 2 * x * y + cy;
                x = xTemp;
                iteration++;
            }
            
            // Smooth coloring
            if (iteration < maxIterations) {
                const logZn = Math.log(x * x + y * y) / 2;
                const nu = Math.log(logZn / Math.log(2)) / Math.log(2);
                iteration = iteration + 1 - nu;
            }
            
            return iteration;
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            const scale = 3 / (zoom * canvas.width);
            
            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const x = centerX + (px - canvas.width / 2) * scale;
                    const y = centerY + (py - canvas.height / 2) * scale;
                    
                    const iterations = mandelbrot(x, y);
                    const [r, g, b] = getColor(iterations);
                    
                    const idx = (py * canvas.width + px) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            updateCoords();
        }

        function updateCoords() {
            coordsEl.textContent = `Center: (${centerX.toFixed(10)}, ${centerY.toFixed(10)}) | Zoom: ${zoom.toFixed(2)}x`;
        }

        // Smooth animation loop
        function animate() {
            // Continuous zoom while keys are held
            if (keysHeld.up) {
                targetZoom *= 1.03;
            }
            if (keysHeld.down) {
                targetZoom /= 1.03;
                if (targetZoom < 0.1) targetZoom = 0.1;
            }

            // Smoothly interpolate current values toward targets
            const zoomDiff = targetZoom - zoom;
            const centerXDiff = targetCenterX - centerX;
            const centerYDiff = targetCenterY - centerY;

            // Check if we need to animate
            const needsUpdate = 
                Math.abs(zoomDiff) > 0.001 || 
                Math.abs(centerXDiff) > 1e-15 || 
                Math.abs(centerYDiff) > 1e-15 ||
                keysHeld.up || keysHeld.down;

            if (needsUpdate) {
                // Exponential smoothing for zoom
                zoom += zoomDiff * zoomSpeed;
                
                // Linear smoothing for position
                centerX += centerXDiff * panSpeed;
                centerY += centerYDiff * panSpeed;

                render();
                isAnimating = true;
                requestAnimationFrame(animate);
            } else {
                isAnimating = false;
            }
        }

        function startAnimationIfNeeded() {
            if (!isAnimating) {
                isAnimating = true;
                requestAnimationFrame(animate);
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                keysHeld.up = true;
                startAnimationIfNeeded();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                keysHeld.down = true;
                startAnimationIfNeeded();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp') {
                keysHeld.up = false;
            } else if (e.key === 'ArrowDown') {
                keysHeld.down = false;
            }
        });

        // Click to recenter with smooth pan
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;
            
            const scale = 3 / (zoom * canvas.width);
            targetCenterX = centerX + (px - canvas.width / 2) * scale;
            targetCenterY = centerY + (py - canvas.height / 2) * scale;
            
            startAnimationIfNeeded();
        });

        // Initial render
        render();
    </script>
</body>
</html>
