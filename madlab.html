<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>D&D Map Generator (Enhanced)</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Almendra&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* --- Global Styles --- */
    body {
      margin: 0;
      background: url('resources/alcazar.png') no-repeat center center fixed;
      background-size: cover;
      color: #FAF4E0;
      font-family: 'Almendra', serif;
      text-align: center;
    }
    .container {
      width: fit-content;
      margin: 2rem auto;
      background: rgba(0, 0, 0, 0.7);
      padding: 2rem;
      border-radius: 10px;
    }
    h1, h2 {
      font-family: 'Cinzel', serif;
      margin: 0.5rem 0;
    }
    .description {
      font-size: 1.2rem;
      margin-top: 1rem;
    }
    .mapWrapper {
      text-align: center;
    }
    #mapCanvas {
      border: 2px solid #660000;
      background: #202020;
      display: block;
      margin: 1rem auto; 
      image-rendering: pixelated;
    }
    .mapButton {
      display: inline-block;
      margin: 0.5rem;
      padding: 0.6rem 1rem;
      font-family: 'Cinzel', serif;
      background: #8B0000;
      color: #FAF4E0;
      border: 1px solid #660000;
      border-radius: 4px;
      cursor: pointer;
      text-decoration: none;
    }
    .mapButton:hover {
      background: #660000;
    }
    .controls {
      margin: 1rem auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .controls label {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>D&D Map Generator (Enhanced)</h1>
    <p class="description">
      "Explore deserts, forests, caverns, or other lands. Choose whether it's a bustling village or a wild frontier!"
    </p>
    
    <div class="controls">
      <!-- Biome / Map Type Selection -->
      <label>
        Map Biome:
        <select id="mapType">
          <option value="desert">Desert</option>
          <option value="city">City</option>
          <option value="village">Village</option>
          <option value="grassland" selected>Grassland</option>
          <option value="mountain">Mountain</option>
          <option value="forest">Forest</option>
          <option value="cavern">Cavern</option>
        </select>
      </label>
      
      <!-- Style Selection -->
      <label>
        Map Style:
        <select id="mapStyle">
          <option value="village" selected>Village</option>
          <option value="wilds">Wilds (No Buildings)</option>
        </select>
      </label>
      
      <button class="mapButton">Generate Map</button>
      
      <!-- Occupant Selection -->
      <label>
        Occupant:
        <select id="occupantType">
          <option value="player">Player</option>
          <option value="enemy">Enemy</option>
          <option value="npc">NPC</option>
        </select>
      </label>
    </div>
    
    <div class="mapWrapper">
      <canvas id="mapCanvas" width="1000" height="1000"></canvas>
    </div>
  </div>

  <script type="module">
    /*******************************************************
     * CONFIGURATION & GLOBALS
     *******************************************************/
    const CONFIG = {
      tileSize: 20,
      gridWidth: 50,
      gridHeight: 50,
      assetPathTiles: 'resources/mapassets/',
      assetPathOccupants: 'resources/occupants/'
    };

    // Map data & occupant tracking
    let mapData = [];
    let occupantInHand = null;

    // Basic tile types (the value equals the "default" filename)
    const TILE_TYPES = {
      GRASS:       "grass",
      TREE:        "tree",
      DIRT:        "dirt",
      SAND:        "sand",
      WATER:       "water",
      ROAD_STONE:  "roadStone",
      ROAD_DIRT:   "roadDirt",
      STONE:       "stone",
      WALL:        "wall",
      FLOOR:       "floor",
      DOOR:        "door",
      SOLID_STONE: "solidStone"
    };

    // Fallback colours (original dot colours)
    const baseTileColours = {
      [TILE_TYPES.GRASS]:       "#9AE582",
      [TILE_TYPES.TREE]:        "#7BC16E",
      [TILE_TYPES.DIRT]:        "#C2A15F",
      [TILE_TYPES.SAND]:        "#DDD593",
      [TILE_TYPES.WATER]:       "#2B64CF",
      [TILE_TYPES.ROAD_STONE]:  "#777777",
      [TILE_TYPES.ROAD_DIRT]:   "#A37E4C",
      [TILE_TYPES.STONE]:       "#AAAAAA",
      [TILE_TYPES.WALL]:        "#8B4513",
      [TILE_TYPES.FLOOR]:       "#555555",
      [TILE_TYPES.DOOR]:        "#552200",
      [TILE_TYPES.SOLID_STONE]: "#000000"
    };

    // Mapping tile type to an array of texture filenames (including your new assets)
    const TILE_TEXTURE_OPTIONS = {
      [TILE_TYPES.GRASS]:       ["grass.png", "ancienttile.png"],
      [TILE_TYPES.TREE]:        ["tree.png", "shrub1.png", "shrub2.png", "shrub3.png"],
      [TILE_TYPES.DIRT]:        ["dirt.png", "mud.png", "mud2.png", "mud3.png"],
      [TILE_TYPES.SAND]:        ["sand.png", "desertsand.png", "desertdune.png", "desertdune2.png", "whitesand.png"],
      [TILE_TYPES.WATER]:       ["water.png"],
      [TILE_TYPES.ROAD_STONE]:  ["roadStone.png"],
      [TILE_TYPES.ROAD_DIRT]:   ["roadDirt.png"],
      [TILE_TYPES.STONE]:       ["stone.png", "marble1.png", "marble2.png", "marble3.png", "marble4.png", "marblecrack.png"],
      [TILE_TYPES.WALL]:        ["wall.png", "brick1.png", "brick2.png", "brick3.png", "brick4.png", "brick5.png", "cavewall.png"],
      [TILE_TYPES.FLOOR]:       ["floor.png", "darktile.png", "darktile2.png", "darktile3.png", "darktile4.png"],
      [TILE_TYPES.DOOR]:        ["door.png"],
      [TILE_TYPES.SOLID_STONE]: ["solidStone.png", "lava.png", "magma.png", "brimstone.png", "brimstone2.png", "sandstonetile.png", "desertrock.png"]
    };

    // Occupant sprites (filenames). Duplicates are okay; they simply provide more variety.
    const occupantSpriteFilenames = [
      "paladin.png",
      "fighter.png",
      "guardian.png",
      "halfblood.png",
      "berserker.png",
      "assassin.png",
      "warlock.png",
      "sorcerer.png",
      "priestess.png",
      "cleric.png",
      "druid.png",
      "demon.png",
      "mage.png",
      "serpent.png",
      "chimera.png",
      "ogre.png",
      "edgelord.png",
      "fallenangel.png",
      "darkpriestess.png",
      "darkguard.png",
      "cultist.png",
      "goblin.png",
      "spider.png",
      "bat.png",
      "zombie.png",
      "orc.png",
      "orcbandit.png",
      "orcchief.png",
      "orcshaman.png",
      "orcfighter.png"
    ];

    // Global dictionaries to store preloaded images
    const loadedTileImages = {};     // key: filename → Image object
    const loadedOccupantImages = {}; // key: filename → Image object

    // Utility: Random choice from array
    const randomChoice = arr => arr[Math.floor(Math.random() * arr.length)];

    // Utility: Get fallback colour for a tile type
    const getColorForTileType = (tileType) => baseTileColours[tileType] || "#FFFFFF";

    // Utility: Get a DOM element by ID
    const $ = id => document.getElementById(id);

    /*******************************************************
     * ASSET PRELOADING FUNCTIONS
     *******************************************************/
    // Preload all tile textures (all unique filenames in TILE_TEXTURE_OPTIONS)
    async function preloadTileTextures() {
      const files = new Set();
      for (const key in TILE_TEXTURE_OPTIONS) {
        TILE_TEXTURE_OPTIONS[key].forEach(filename => files.add(filename));
      }
      const promises = [];
      for (const filename of files) {
        promises.push(new Promise((resolve) => {
          const img = new Image();
          img.src = CONFIG.assetPathTiles + filename;
          img.onload = () => { loadedTileImages[filename] = img; resolve(); };
          img.onerror = () => { console.error("Error loading tile:", filename); resolve(); };
        }));
      }
      await Promise.all(promises);
    }

    // Preload all occupant sprite images
    async function preloadOccupantTextures() {
      const promises = occupantSpriteFilenames.map(filename => new Promise((resolve) => {
        const img = new Image();
        img.src = CONFIG.assetPathOccupants + filename;
        img.onload = () => { loadedOccupantImages[filename] = img; resolve(); };
        img.onerror = () => { console.error("Error loading occupant sprite:", filename); resolve(); };
      }));
      await Promise.all(promises);
    }

    /*******************************************************
     * MAP SETTINGS & GENERATION FUNCTIONS
     *******************************************************/
    function getMapSettings(theme) {
      switch(theme) {
        case "desert":
          return {
            baseDist: { SAND: 0.6, DIRT: 0.2, STONE: 0.1, TREE: 0.0, GRASS: 0.1 },
            waterBodies: 1,
            waterMaxSize: 50,
            roads: 2,
            roadMaxLength: 40,
            buildings: 5,
            isCavern: false
          };
        case "city":
          return {
            baseDist: { DIRT: 0.05, STONE: 0.2, GRASS: 0.15, TREE: 0.1 },
            waterBodies: 2,
            waterMaxSize: 80,
            roads: 8,
            roadMaxLength: 80,
            buildings: 15,
            isCavern: false
          };
        case "village":
          return {
            baseDist: { GRASS: 0.4, DIRT: 0.3, STONE: 0.05, TREE: 0.2 },
            waterBodies: 2,
            waterMaxSize: 60,
            roads: 4,
            roadMaxLength: 60,
            buildings: 8,
            isCavern: false
          };
        case "grassland":
          return {
            baseDist: { GRASS: 0.6, TREE: 0.2, DIRT: 0.1, STONE: 0.05 },
            waterBodies: 3,
            waterMaxSize: 120,
            roads: 4,
            roadMaxLength: 60,
            buildings: 6,
            isCavern: false
          };
        case "mountain":
          return {
            baseDist: { STONE: 0.4, DIRT: 0.3, GRASS: 0.1, TREE: 0.05 },
            waterBodies: 1,
            waterMaxSize: 40,
            roads: 3,
            roadMaxLength: 50,
            buildings: 4,
            isCavern: false
          };
        case "forest":
          return {
            baseDist: { TREE: 0.6, GRASS: 0.2, DIRT: 0.1, STONE: 0.05 },
            waterBodies: 3,
            waterMaxSize: 80,
            roads: 3,
            roadMaxLength: 50,
            buildings: 4,
            isCavern: false
          };
        case "cavern":
          return {
            baseDist: {},
            waterBodies: 0,
            waterMaxSize: 0,
            roads: 0,
            roadMaxLength: 0,
            buildings: 0,
            isCavern: true
          };
        default:
          return {
            baseDist: { GRASS: 0.6, TREE: 0.2, DIRT: 0.1, STONE: 0.05 },
            waterBodies: 2,
            waterMaxSize: 60,
            roads: 4,
            roadMaxLength: 60,
            buildings: 6,
            isCavern: false
          };
      }
    }

    // For non-cavern maps: randomly assign a tile type and choose one texture from the available options
    function initMap(dist) {
      mapData = [];
      let totalP = 0;
      for (let t in dist) { totalP += dist[t]; }
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          const rand = Math.random();
          let chosen = TILE_TYPES.GRASS;
          let cumul = 0;
          for (let t in dist) {
            cumul += dist[t];
            if (rand < cumul) {
              chosen = TILE_TYPES[t];
              break;
            }
          }
          // Assign a random texture (filename) from the options for this tile type
          const textureOptions = TILE_TEXTURE_OPTIONS[chosen] || [];
          const texture = textureOptions.length ? randomChoice(textureOptions) : null;
          row.push({ type: chosen, texture, occupant: null });
        }
        mapData.push(row);
      }
    }

    // Cellular automata-based cavern generation remains as before
    function generateCavern() {
      let boolMap = randomBoolMap(0.45);
      for (let i = 0; i < 5; i++) { boolMap = doCAStep(boolMap); }
      const { largestMap, largestRegion } = keepLargestRegion(boolMap);
      carveExits(largestMap, largestRegion);
      convertBoolMapToCavern(largestMap);
    }
    function randomBoolMap(fillChance) {
      const bm = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          row.push(Math.random() < fillChance);
        }
        bm.push(row);
      }
      return bm;
    }
    function doCAStep(bm) {
      const newMap = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          const n = countFloorNeighbours(bm, x, y);
          row.push(bm[y][x] ? (n >= 4) : (n >= 5));
        }
        newMap.push(row);
      }
      return newMap;
    }
    function countFloorNeighbours(bm, cx, cy) {
      let c = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = cx + dx, ny = cy + dy;
          if (nx >= 0 && ny >= 0 && nx < CONFIG.gridWidth && ny < CONFIG.gridHeight) {
            if (bm[ny][nx]) c++;
          }
        }
      }
      return c;
    }
    function keepLargestRegion(bm) {
      const visited = Array.from({ length: CONFIG.gridHeight }, () => Array(CONFIG.gridWidth).fill(false));
      let bestSize = 0, bestRegion = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          if (bm[y][x] && !visited[y][x]) {
            const queue = [[x, y]];
            visited[y][x] = true;
            const regionCells = [[x, y]];
            let size = 1;
            while (queue.length) {
              const [cx, cy] = queue.pop();
              for (const [nx, ny] of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]) {
                if (nx >= 0 && ny >= 0 && nx < CONFIG.gridWidth && ny < CONFIG.gridHeight) {
                  if (bm[ny][nx] && !visited[ny][nx]) {
                    visited[ny][nx] = true;
                    queue.push([nx, ny]);
                    regionCells.push([nx, ny]);
                    size++;
                  }
                }
              }
            }
            if (size > bestSize) { bestSize = size; bestRegion = regionCells; }
          }
        }
      }
      const largestMap = bm.map(row => row.slice());
      const regionSet = new Set(bestRegion.map(([xx, yy]) => `${xx},${yy}`));
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          if (largestMap[y][x] && !regionSet.has(`${x},${y}`)) {
            largestMap[y][x] = false;
          }
        }
      }
      return { largestMap, largestRegion: bestRegion };
    }
    function carveExits(bm, regionCells) {
      let boundaryCount = 0;
      for (const [x, y] of regionCells) {
        if (x === 0 || x === CONFIG.gridWidth - 1 || y === 0 || y === CONFIG.gridHeight - 1) {
          boundaryCount++;
          if (boundaryCount >= 3) break;
        }
      }
      if (boundaryCount < 1) {
        const needed = 1 + Math.floor(Math.random() * 3);
        for (let i = 0; i < needed; i++) { carveOneExit(bm, regionCells); }
      } else if (boundaryCount < 3) {
        const toAdd = Math.floor(Math.random() * (3 - boundaryCount + 1));
        for (let i = 0; i < toAdd; i++) { carveOneExit(bm, regionCells); }
      }
    }
    function carveOneExit(bm, regionCells) {
      if (!regionCells.length) return;
      const [rx, ry] = regionCells[Math.floor(Math.random() * regionCells.length)];
      let edgeX, edgeY;
      const side = Math.floor(Math.random() * 4);
      if (side === 0) { edgeY = 0; edgeX = Math.floor(Math.random() * CONFIG.gridWidth); }
      else if (side === 1) { edgeY = CONFIG.gridHeight - 1; edgeX = Math.floor(Math.random() * CONFIG.gridWidth); }
      else if (side === 2) { edgeX = 0; edgeY = Math.floor(Math.random() * CONFIG.gridHeight); }
      else { edgeX = CONFIG.gridWidth - 1; edgeY = Math.floor(Math.random() * CONFIG.gridHeight); }
      carveLine(bm, rx, ry, edgeX, edgeY);
    }
    function carveLine(bm, x1, y1, x2, y2) {
      let steps = 0;
      while ((x1 !== x2 || y1 !== y2) && steps < 2000) {
        bm[y1][x1] = true;
        if (x1 < x2) x1++; else if (x1 > x2) x1--;
        if (y1 < y2) y1++; else if (y1 > y2) y1--;
        steps++;
      }
      if (x1 >= 0 && x1 < CONFIG.gridWidth && y1 >= 0 && y1 < CONFIG.gridHeight) {
        bm[y1][x1] = true;
      }
    }
    function convertBoolMapToCavern(bm) {
      mapData = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          if (bm[y][x]) {
            const r = Math.random();
            if (r < 0.03) row.push({ type: TILE_TYPES.WATER, occupant: null });
            else if (r < 0.15) row.push({ type: TILE_TYPES.DIRT, occupant: null });
            else row.push({ type: TILE_TYPES.STONE, occupant: null });
          } else {
            row.push({ type: TILE_TYPES.SOLID_STONE, occupant: null });
          }
          // Also assign a random texture from the options for the chosen type:
          const texOptions = TILE_TEXTURE_OPTIONS[row[x].type] || [];
          row[x].texture = texOptions.length ? randomChoice(texOptions) : null;
        }
        mapData.push(row);
      }
    }

    /*******************************************************
     * WATER & ROAD FUNCTIONS
     *******************************************************/
    function createWaterBody(maxSize) {
      const sx = Math.floor(Math.random() * CONFIG.gridWidth);
      const sy = Math.floor(Math.random() * CONFIG.gridHeight);
      floodFillWater(sx, sy, maxSize);
    }
    function floodFillWater(sx, sy, maxSize) {
      const stack = [[sx, sy]];
      let size = 0;
      while (stack.length && size < maxSize) {
        const [cx, cy] = stack.pop();
        if (cx < 0 || cy < 0 || cx >= CONFIG.gridWidth || cy >= CONFIG.gridHeight) continue;
        if (mapData[cy][cx].type === TILE_TYPES.WATER) continue;
        if (Math.random() < 0.2) continue;
        mapData[cy][cx].type = TILE_TYPES.WATER;
        size++;
        stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
      }
    }
    function createRoad(maxLength, minW, maxW) {
      let x, y;
      if (Math.random() < 0.5) {
        x = Math.floor(Math.random() * CONFIG.gridWidth);
        y = (Math.random() < 0.5) ? 0 : CONFIG.gridHeight - 1;
      } else {
        x = (Math.random() < 0.5) ? 0 : CONFIG.gridWidth - 1;
        y = Math.floor(Math.random() * CONFIG.gridHeight);
      }
      let direction = getRandomDirection();
      const length = Math.floor(Math.random() * (maxLength / 2) + maxLength / 2);
      const w = Math.floor(Math.random() * (maxW - minW + 1)) + minW;
      for (let i = 0; i < length; i++) {
        carveRoad(x, y, w);
        x += direction.dx;
        y += direction.dy;
        if (Math.random() < 0.2) direction = getRandomDirection(direction);
        if (x < 0 || x >= CONFIG.gridWidth || y < 0 || y >= CONFIG.gridHeight) break;
      }
    }
    function carveRoad(cx, cy, width) {
      const r = Math.floor(width / 2);
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          const nx = cx + dx, ny = cy + dy;
          if (nx >= 0 && nx < CONFIG.gridWidth && ny >= 0 && ny < CONFIG.gridHeight) {
            mapData[ny][nx].type = (Math.random() < 0.6) ? TILE_TYPES.ROAD_STONE : TILE_TYPES.ROAD_DIRT;
          }
        }
      }
    }
    function getRandomDirection(prevDir) {
      const dirs = [{dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}];
      if (prevDir && Math.random() < 0.6) return prevDir;
      return randomChoice(dirs);
    }

    /*******************************************************
     * BUILDING GENERATION (with improved door logic)
     *******************************************************/
    const buildingShapes = [
      { width: 4, height: 4, layout: [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]] },
      { width: 5, height: 5, layout: [[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1]] },
      { width: 6, height: 5, layout: [[1,1,1,1,1,1],[1,0,0,0,0,1],[1,0,0,0,0,1],[1,0,0,0,0,1],[1,1,1,1,1,1]] },
      { width: 7, height: 5, layout: [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] },
      { width: 7, height: 7, layout: [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] },
      { width: 8, height: 5, layout: [[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1]] }
    ];
    function createBuildings(numBuildings) {
      let attempts = 0, placed = 0;
      while (placed < numBuildings && attempts < numBuildings * 50) {
        attempts++;
        const shape = randomChoice(buildingShapes);
        const sx = Math.floor(Math.random() * (CONFIG.gridWidth - shape.width));
        const sy = Math.floor(Math.random() * (CONFIG.gridHeight - shape.height));
        if (canPlaceBuilding(sx, sy, shape)) {
          placeBuilding(sx, sy, shape);
          placed++;
        }
      }
    }
    function canPlaceBuilding(sx, sy, shape) {
      for (let y = 0; y < shape.height; y++) {
        for (let x = 0; x < shape.width; x++) {
          const val = shape.layout[y][x];
          if (val === 1 || val === 0) {
            const tileType = mapData[sy+y][sx+x].type;
            if ([TILE_TYPES.WATER, TILE_TYPES.ROAD_STONE, TILE_TYPES.ROAD_DIRT, TILE_TYPES.SOLID_STONE].includes(tileType)) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function placeBuilding(sx, sy, shape) {
      let localLayout = shape.layout.map(row => row.slice());
      subdivideBuilding(localLayout);
      placeExteriorDoor(localLayout);
      ensureAccessibility(localLayout);
      stampBuildingOntoMap(localLayout, sx, sy);
    }
    function subdivideBuilding(localLayout) {
      const h = localLayout.length, w = localLayout[0].length;
      if (w >= 7) {
        const wx = Math.floor(w / 2);
        for (let y = 1; y < h - 1; y++) { localLayout[y][wx] = 1; }
        const doorY = Math.floor(Math.random() * (h - 2)) + 1;
        localLayout[doorY][wx] = 2;
      }
      if (h >= 7) {
        const wy = Math.floor(h / 2);
        for (let x = 1; x < w - 1; x++) { localLayout[wy][x] = 1; }
        const doorX = Math.floor(Math.random() * (w - 2)) + 1;
        localLayout[wy][doorX] = 2;
      }
    }
    function placeExteriorDoor(localLayout) {
      const h = localLayout.length, w = localLayout[0].length;
      let candidates = [];
      for (let x = 1; x < w - 1; x++) {
        if (isWallish(localLayout[0][x]) && hasExactlyTwoOrthWalls(localLayout, x, 0)) {
          candidates.push({ px: x, py: 0 });
        }
        if (isWallish(localLayout[h-1][x]) && hasExactlyTwoOrthWalls(localLayout, x, h-1)) {
          candidates.push({ px: x, py: h-1 });
        }
      }
      for (let y = 1; y < h - 1; y++) {
        if (isWallish(localLayout[y][0]) && hasExactlyTwoOrthWalls(localLayout, 0, y)) {
          candidates.push({ px: 0, py: y });
        }
        if (isWallish(localLayout[y][w-1]) && hasExactlyTwoOrthWalls(localLayout, w-1, y)) {
          candidates.push({ px: w-1, py: y });
        }
      }
      if (candidates.length > 0) {
        const howMany = 1 + Math.floor(Math.random() * 2);
        for (let i = 0; i < howMany && candidates.length; i++) {
          const idx = Math.floor(Math.random() * candidates.length);
          const chosen = candidates[idx];
          localLayout[chosen.py][chosen.px] = 2;
          candidates.splice(idx, 1);
        }
      }
    }
    function ensureAccessibility(localLayout) {
      const floors = collectFloorCells(localLayout);
      if (!floors.length) return;
      const doorCoords = collectDoorCoords(localLayout);
      if (!doorCoords.length) return;
      const mainDoor = doorCoords.find(d => isOnPerimeter(localLayout, d.x, d.y)) || doorCoords[0];
      if (!mainDoor) return;
      const visited = new Set();
      const queue = [];
      queue.push({ x: mainDoor.x, y: mainDoor.y });
      visited.add(`${mainDoor.x},${mainDoor.y}`);
      while (queue.length) {
        const { x, y } = queue.shift();
        for (const [nx, ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]) {
          if (nx < 0 || ny < 0 || nx >= localLayout[0].length || ny >= localLayout.length) continue;
          const val = localLayout[ny][nx];
          if (val === 0 || val === 2) {
            const key = `${nx},${ny}`;
            if (!visited.has(key)) {
              visited.add(key);
              queue.push({ x: nx, y: ny });
            }
          }
        }
      }
      const allVisited = floors.every(cell => visited.has(`${cell.x},${cell.y}`));
      if (!allVisited) { forceInteriorDoor(localLayout, visited); }
    }
    function collectFloorCells(localLayout) {
      const res = [];
      for (let y = 0; y < localLayout.length; y++) {
        for (let x = 0; x < localLayout[0].length; x++) {
          if (localLayout[y][x] === 0 || localLayout[y][x] === 2) { res.push({ x, y }); }
        }
      }
      return res;
    }
    function collectDoorCoords(localLayout) {
      const res = [];
      for (let y = 0; y < localLayout.length; y++) {
        for (let x = 0; x < localLayout[0].length; x++) {
          if (localLayout[y][x] === 2) { res.push({ x, y }); }
        }
      }
      return res;
    }
    function isOnPerimeter(localLayout, x, y) {
      return (x === 0 || y === 0 || x === localLayout[0].length - 1 || y === localLayout.length - 1);
    }
    function isWallish(val) { return val === 1 || val === 2; }
    function hasExactlyTwoOrthWalls(localLayout, x, y) {
      const up = (y > 0) && isWallish(localLayout[y-1][x]);
      const down = (y < localLayout.length - 1) && isWallish(localLayout[y+1][x]);
      const left = (x > 0) && isWallish(localLayout[y][x-1]);
      const right = (x < localLayout[0].length - 1) && isWallish(localLayout[y][x+1]);
      const count = (up ? 1 : 0) + (down ? 1 : 0) + (left ? 1 : 0) + (right ? 1 : 0);
      if (count === 2) {
        if (up && down) return true;
        if (left && right) return true;
      }
      return false;
    }
    function forceInteriorDoor(localLayout, visited) {
      const h = localLayout.length, w = localLayout[0].length;
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          if (localLayout[y][x] === 1 && hasExactlyTwoOrthWalls(localLayout, x, y)) {
            const sides = [[1,0],[-1,0],[0,1],[0,-1]];
            let visitedSide = false, unvisitedSide = false;
            for (const [dx, dy] of sides) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < w && ny < h) {
                if (localLayout[ny][nx] === 0 || localLayout[ny][nx] === 2) {
                  if (visited.has(`${nx},${ny}`)) visitedSide = true;
                  else unvisitedSide = true;
                }
              }
            }
            if (visitedSide && unvisitedSide) { localLayout[y][x] = 2; return; }
          }
        }
      }
    }
    function stampBuildingOntoMap(localLayout, sx, sy) {
      const h = localLayout.length, w = localLayout[0].length;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const val = localLayout[y][x];
          if (val === 1) { mapData[sy+y][sx+x].type = TILE_TYPES.WALL; }
          else if (val === 0) { mapData[sy+y][sx+x].type = TILE_TYPES.FLOOR; }
          else if (val === 2) { mapData[sy+y][sx+x].type = TILE_TYPES.DOOR; }
          // Also reassign a texture for the updated type:
          const options = TILE_TEXTURE_OPTIONS[mapData[sy+y][sx+x].type] || [];
          mapData[sy+y][sx+x].texture = options.length ? randomChoice(options) : null;
        }
      }
    }

    /*******************************************************
     * DRAWING FUNCTIONS
     *******************************************************/
    function drawMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          drawTile(x, y);
        }
      }
    }
    function drawTile(x, y) {
      const tile = mapData[y][x];
      const px = x * CONFIG.tileSize, py = y * CONFIG.tileSize;
      // Draw the tile texture if available
      if (tile.texture && loadedTileImages[tile.texture] && loadedTileImages[tile.texture].complete) {
        ctx.drawImage(loadedTileImages[tile.texture], px, py, CONFIG.tileSize, CONFIG.tileSize);
      } else {
        ctx.fillStyle = getColorForTileType(tile.type);
        ctx.fillRect(px, py, CONFIG.tileSize, CONFIG.tileSize);
      }
      // Draw occupant sprite if present
      if (tile.occupant) {
        // Draw occupant sprite scaled to (tileSize - 2) to leave a 1px margin
        const spriteFilename = tile.occupant.sprite;
        if (spriteFilename && loadedOccupantImages[spriteFilename] && loadedOccupantImages[spriteFilename].complete) {
          ctx.drawImage(loadedOccupantImages[spriteFilename], px+1, py+1, CONFIG.tileSize-2, CONFIG.tileSize-2);
        }
        // Draw a 1px border in the occupant's color around the sprite area
        ctx.lineWidth = 1;
        ctx.strokeStyle = tile.occupant.color;
        ctx.strokeRect(px+1, py+1, CONFIG.tileSize-2, CONFIG.tileSize-2);
      }
      // Draw a subtle grid over the tile
      ctx.strokeStyle = "rgba(0,0,0,0.3)";
      ctx.strokeRect(px, py, CONFIG.tileSize, CONFIG.tileSize);
    }

    /*******************************************************
     * EVENT HANDLING FOR OCCUPANT PLACEMENT
     *******************************************************/
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const tileX = Math.floor((e.clientX - rect.left) / CONFIG.tileSize);
      const tileY = Math.floor((e.clientY - rect.top) / CONFIG.tileSize);
      if (tileX < 0 || tileY < 0 || tileX >= CONFIG.gridWidth || tileY >= CONFIG.gridHeight) return;
      const tile = mapData[tileY][tileX];
      if (!occupantInHand) {
        if (!tile.occupant) {
          const occupantType = $("occupantType").value;
          let occupantColor = "#FFFFFF";
          if (occupantType === "player") occupantColor = "#00FF00";
          else if (occupantType === "enemy") occupantColor = "#FF0000";
          else if (occupantType === "npc") occupantColor = "#0000FF";
          // Assign a random occupant sprite from the list
          const sprite = randomChoice(occupantSpriteFilenames);
          tile.occupant = { type: occupantType, color: occupantColor, sprite };
        } else {
          occupantInHand = tile.occupant;
          tile.occupant = null;
        }
      } else {
        tile.occupant = occupantInHand;
        occupantInHand = null;
      }
      drawTile(tileX, tileY);
    });

    /*******************************************************
     * INITIALISATION: Preload Assets & Generate Map
     *******************************************************/
    async function init() {
      try {
        await Promise.all([ preloadTileTextures(), preloadOccupantTextures() ]);
      } catch (err) {
        console.error("Error preloading assets:", err);
      }
      
      const theme = $("mapType").value;
      const style = $("mapStyle").value;
      const settings = getMapSettings(theme);
      
      if (settings.isCavern) { generateCavern(); }
      else {
        initMap(settings.baseDist);
        for (let i = 0; i < settings.waterBodies; i++) { createWaterBody(settings.waterMaxSize); }
        for (let r = 0; r < settings.roads; r++) { createRoad(settings.roadMaxLength, 2, 3); }
      }
      if (!settings.isCavern && style === "village" && settings.buildings > 0) {
        createBuildings(settings.buildings);
      }
      drawMap();
    }

    /*******************************************************
     * BINDING: Regenerate map on button click and on window load
     *******************************************************/
    document.querySelector(".mapButton").addEventListener("click", () => { init(); });
    window.addEventListener("load", () => {
      init();
      // Belt-and-braces: a second redraw after 1 second
      setTimeout(() => { requestAnimationFrame(drawMap); }, 1000);
    });
  </script>
</body>
</html>
