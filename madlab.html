<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Procedural Battle Map Generator</title>

  <!-- Example fonts; adapt if needed -->
  <link 
    href="https://fonts.googleapis.com/css2?family=Almendra&family=Cinzel:wght@400;700&display=swap"
    rel="stylesheet"
  >

  <style>
    /* Page Styling */
    body {
      margin: 0;
      background: url('resources/mapgen.png') no-repeat center center fixed;
      background-size: cover;
      color: #FAF4E0;
      font-family: 'Almendra', serif;
      text-align: center;
      /* Prevent iOS Safari overscroll background bounce in some cases */
      overscroll-behavior: none;
    }

    .container {
      margin: 2rem auto;
      background: rgba(0, 0, 0, 0.7);
      padding: 2rem;
      border-radius: 10px;
      max-width: 95vw;
    }

    h1, h2 {
      font-family: 'Cinzel', serif;
      margin: 0.5rem 0;
    }

    .description {
      font-size: 1.2rem;
      margin-top: 1rem;
    }

    /* Responsive map wrapper */
    .mapWrapper {
      width: 90vw;
      max-width: 1000px;
      height: 60vh;
      max-height: 700px;
      margin: 1rem auto;
      overflow: hidden;
      position: relative;
      display: block;
      border: 2px solid #660000;
      background: #202020;
    }

    #mapCanvas {
      width: 1000px;
      height: 1000px;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: top left;
      image-rendering: pixelated;
      touch-action: none;
    }

    .mapButton {
      display: inline-block;
      margin: 0.5rem;
      padding: 0.6rem 1rem;
      font-family: 'Cinzel', serif;
      background: #8B0000;
      color: #FAF4E0;
      border: 1px solid #660000;
      border-radius: 4px;
      cursor: pointer;
      text-decoration: none;
    }
    .mapButton:hover {
      background: #660000;
    }

    .controls {
      margin: 1rem auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .controls label {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Procedural Battle Map Generator</h1>
    <p class="description">
      "Generate caverns, roads, buildings, single-floor villages, mixed biomes, coastal maps and more."
    </p>

    <div class="controls">
      <label>
        Map Biome:
        <select id="mapType">
          <option value="desert">Desert</option>
          <option value="city">City</option>
          <option value="village">Village</option>
          <option value="grassland" selected>Grassland</option>
          <option value="mountain">Mountain</option>
          <option value="forest">Forest</option>
          <option value="cavern">Cavern</option>
          <option value="volcanic">Volcanic</option>
          <option value="mudlands">Mudlands</option>
        </select>
      </label>

      <label>
        Map Style:
        <select id="mapStyle">
          <option value="village" selected>Village</option>
          <option value="wilds">Wilds (No Buildings)</option>
        </select>
      </label>

      <button class="mapButton" onclick="generateMap()">Generate Map</button>

      <label>
        Occupant Type:
        <select id="occupantType">
          <option value="none" selected>None</option>
          <option value="player">Player</option>
          <option value="enemy">Enemy</option>
          <option value="npc">NPC</option>
        </select>
      </label>

      <label>
        Sprite:
        <select id="occupantSprite">
          <option value="none" selected>None</option>
          <!-- Updated occupant sprite list to match new filenames -->
          <option value="assassin">assassin</option>
          <option value="bat">bat</option>
          <option value="berserker">berserker</option>
          <option value="brigand">brigand</option>
          <option value="chimera">chimera</option>
          <option value="cleric">cleric</option>
          <option value="cultist">cultist</option>
          <option value="darkguard">darkguard</option>
          <option value="darkpriestess">darkpriestess</option>
          <option value="demon">demon</option>
          <option value="druid">druid</option>
          <option value="edgelord">edgelord</option>
          <option value="fallenangel">fallenangel</option>
          <option value="fighter">fighter</option>
          <option value="ghost">ghost</option>
          <option value="goblin">goblin</option>
          <option value="guardian">guardian</option>
          <option value="halfblood">halfblood</option>
          <option value="imp">imp</option>
          <option value="mage">mage</option>
          <option value="ogre">ogre</option>
          <option value="orc">orc</option>
          <option value="orcbandit">orcbandit</option>
          <option value="orcchief">orcchief</option>
          <option value="orkshaman">orkshaman</option>
          <option value="orkfighter">orkfighter</option>
          <option value="paladin">paladin</option>
          <option value="priestess">priestess</option>
          <option value="ranger">ranger</option>
          <option value="rat">rat</option>
          <option value="rogue">rogue</option>
          <option value="serpent">serpent</option>
          <option value="sorcerer">sorcerer</option>
          <option value="spider">spider</option>
          <option value="spider2">spider2</option>
          <option value="warlock">warlock</option>
          <option value="wight">wight</option>
          <option value="zombie">zombie</option>
        </select>
      </label>

      <button class="mapButton" onclick="clearOccupantSelection()">Clear</button>
    </div>

    <div class="controls">
      <button class="mapButton" onclick="setMode('place')">Place</button>
      <button class="mapButton" onclick="setMode('delete')">Delete</button>
      <button class="mapButton" onclick="setMode('move')">Move</button>
    </div>

    <div class="mapWrapper">
      <canvas id="mapCanvas" width="1000" height="1000"></canvas>
    </div>

    <div style="margin-top: 1rem;">
      <a href="index.html" class="mapButton">Home</a>
    </div>
  </div>

  <script>
    /*******************************************************
     * BASIC CONFIG & GLOBALS
     *******************************************************/
    const TILE_SIZE = 20;
    const GRID_WIDTH = 50;
    const GRID_HEIGHT = 50;

    let mapData = []; // entire map structure
    let occupantInHand = null; // for Move mode

    // occupant border colours
    const occupantColours = {
      player: "#00FF00",
      enemy:  "#FF0000",
      npc:    "#0000FF"
    };

    // occupant management mode: 'place' | 'delete' | 'move'
    let currentMode = 'place';

    /*******************************************************
     * PAN & ZOOM
     *******************************************************/
    let scale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    const minScale = 0.3;
    const maxScale = 3.0;

    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    let activePointers = new Map();
    let initialPinchDistance = 0;
    let initialPinchScale = 1.0;

    /*******************************************************
     * TILE TYPES
     *
     * Each 'value' here is the relative path (without .png),
     * which we’ll prefix with "resources/mapgen/mapassets/"
     *******************************************************/
    const TILE_TYPES = {
      // Some “generic” references we’ll pick from randomly 
      // in generation steps. We store them as string keys; 
      // the code loads them from the new folder structure. 
      
      // Grass variants (grass/trees)
      GRASS_1:       "tiles/grass/grasstile1",
      GRASS_2:       "tiles/grass/grasstile2",
      GRASS_3:       "tiles/grass/grasstile3",
      GRASS_4:       "tiles/grass/grasstile4",
      GRASS_5:       "tiles/grass/grasstile5",
      TREE_1:        "tiles/grass/grasstree1",
      TREE_2:        "tiles/grass/grasstree2",

      // Dirt variants
      DIRT_1:        "tiles/dirt/dirt1",
      DIRT_2:        "tiles/dirt/dirt2",
      DIRT_3:        "tiles/dirt/dirt3",

      // Desert (sand/dunes/cacti, etc.)
      SAND_1:        "tiles/desert/sand1",
      SAND_2:        "tiles/desert/sand2",
      SAND_3:        "tiles/desert/sand3",
      DUNE_1:        "tiles/desert/dune1",
      CACTUS_1:      "tiles/desert/cactus1",
      CACTUS_2:      "tiles/desert/cactus2",

      // Water
      WATER:         "tiles/water/water",
      WATERROCKS:    "tiles/water/waterrocks",
      SWAMP:         "tiles/water/swamp",
      WHITESAND:     "tiles/water/whitesand",  // for beaches

      // Cavern
      CAVE_1:        "tiles/cavern/cave1",
      CAVE_2:        "tiles/cavern/cave2",
      CAVE_WALL:     "tiles/buildings/walls/caveWall", // or could use cavern/caveWall if you prefer
      SOLID_ROCK:    "tiles/cavern/caveRockLarge",

      // Volcanic
      LAVA_1:        "tiles/vulcanic/lava1",
      LAVA_2:        "tiles/vulcanic/lava2",
      MAGMA:         "tiles/vulcanic/magma",
      BRIMSTONE1:    "tiles/vulcanic/brimstone",
      BRIMSTONE2:    "tiles/vulcanic/brimstone2",
      LAVASTONE1:    "tiles/vulcanic/lavastone1",

      // 'Stone' for roads or mountains
      ROAD_STONE:    "tiles/dirt/roadDirt",     // We can still call it 'stone road' but use a file here
      ROAD_DIRT:     "tiles/dirt/dirtTile",
      WOOD_PLANKS:   "tiles/buildings/floors/woodfloor", // for bridging water

      // Additional shrubs etc. (we can reuse some from dirt folder)
      SHRUB_1:       "tiles/dirt/shrub1",
      SHRUB_2:       "tiles/dirt/shrub2",
      SHRUB_3:       "tiles/dirt/shrub3"
    };

    // Building walls
    const BUILDING_WALLS = [
      "tiles/buildings/walls/brick1",
      "tiles/buildings/walls/brick2",
      "tiles/buildings/walls/cobble1",
      "tiles/buildings/walls/cobble2",
      "tiles/buildings/walls/stoneBlock",
      "tiles/buildings/walls/darkStoneBlock"
    ];

    // Building floors
    const BUILDING_FLOORS = [
      "tiles/buildings/floors/marble1",
      "tiles/buildings/floors/marble2",
      "tiles/buildings/floors/marble3",
      "tiles/buildings/floors/marble4",
      "tiles/buildings/floors/woodfloor",
      "tiles/buildings/floors/PlainTileRubble1",
      "tiles/buildings/floors/sandstonetile"
    ];

    // Building doors (we’ll pick at random)
    const BUILDING_DOORS = [
      "tiles/buildings/doors/doorWood1",
      "tiles/buildings/doors/doorWood2",
      "tiles/buildings/doors/doorVault",
      "tiles/buildings/doors/gateStone"
    ];

    // A helper for terrain picking. E.g. Grass => random among GRASS_1.._5
    function pickRandomTileFrom(...tileKeys) {
      const chosen = tileKeys[Math.floor(Math.random()*tileKeys.length)];
      return TILE_TYPES[chosen];
    }

    // In practice, we’ll store the final “.png” path in mapData[y][x].type 
    // so drawCell can load it directly. 

    const tileTextures = {};       // to store loaded tile images
    const occupantSpritesMap = {}; // to store occupant sprite images

    /*******************************************************
     * getColorForTileType (fallback if no image found)
     *******************************************************/
    function getColorForTileType(tilePath) {
      // Just a random fallback
      return "#999999";
    }

    /*******************************************************
     * occupant sprite preloading
     *******************************************************/
    const occupantSpriteNames = [
      "assassin","bat","berserker","brigand","chimera","cleric","cultist","darkguard","darkpriestess",
      "demon","druid","edgelord","fallenangel","fighter","ghost","goblin","guardian","halfblood","imp",
      "mage","ogre","orc","orcbandit","orcchief","orkshaman","orkfighter","paladin","priestess","ranger",
      "rat","rogue","serpent","sorcerer","spider","spider2","warlock","wight","zombie"
    ];

    function preloadImages(onComplete) {
      // We'll gather all tile image paths from our tile references:
      const allTilePaths = [];
      for (const key in TILE_TYPES) {
        allTilePaths.push(TILE_TYPES[key]);
      }
      // Add building walls, floors, doors:
      BUILDING_WALLS.forEach(p => allTilePaths.push(p));
      BUILDING_FLOORS.forEach(p => allTilePaths.push(p));
      BUILDING_DOORS.forEach(p => allTilePaths.push(p));

      // Convert them into unique set to avoid duplicates
      const uniqueTilePaths = [...new Set(allTilePaths)];

      const totalToLoad = uniqueTilePaths.length + occupantSpriteNames.length;
      let loadedCount = 0;

      function checkDone() {
        loadedCount++;
        if (loadedCount >= totalToLoad && onComplete) {
          onComplete();
        }
      }

      // load tile textures
      uniqueTilePaths.forEach(path => {
        const img = new Image();
        img.src = `resources/mapgen/mapassets/${path}.png`;
        img.onload = checkDone;
        img.onerror = checkDone;
        tileTextures[path] = img;
      });

      // load occupant sprites
      occupantSpriteNames.forEach(spriteName => {
        const img = new Image();
        img.src = `resources/mapgen/mapassets/sprites/${spriteName}.png`;
        img.onload = checkDone;
        img.onerror = checkDone;
        occupantSpritesMap[spriteName] = img;
      });
    }

    /*******************************************************
     * BIOME SETTINGS
     * 
     * Similar to old approach, but we now pick from new tile sets
     *******************************************************/
    function getMapSettings(theme) {
      switch(theme) {
        case "desert":
          return {
            baseDist: {
              DESERT: 0.6, 
              DIRT:   0.2,
              GRASS:  0.1,
              TREE:   0.1
            },
            waterBodies: 1,
            waterMaxSize: 50,
            roads: 2,
            roadMaxLength: 40,
            buildings: 5,
            isCavern: false
          };
        case "city":
          return {
            baseDist: {
              DIRT: 0.25, 
              GRASS: 0.2, 
              TREE: 0.1,
              DESERT: 0.1,
              STONE: 0.35  // Maybe treat "STONE" as mountainous ground or paver
            },
            waterBodies: 2,
            waterMaxSize: 80,
            roads: 8,
            roadMaxLength: 80,
            buildings: 15,
            isCavern: false
          };
        case "village":
          return {
            baseDist: {
              GRASS: 0.4,
              DIRT:  0.3,
              TREE:  0.2,
              STONE: 0.1
            },
            waterBodies: 2,
            waterMaxSize: 60,
            roads: 4,
            roadMaxLength: 60,
            buildings: 8,
            isCavern: false
          };
        case "grassland":
          return {
            baseDist: {
              GRASS: 0.6,
              TREE:  0.2,
              DIRT:  0.1,
              STONE: 0.1
            },
            waterBodies: 3,
            waterMaxSize: 120,
            roads: 4,
            roadMaxLength: 60,
            buildings: 6,
            isCavern: false
          };
        case "mountain":
          return {
            baseDist: {
              STONE: 0.4,
              DIRT:  0.3,
              GRASS: 0.1,
              TREE:  0.2
            },
            waterBodies: 1,
            waterMaxSize: 40,
            roads: 3,
            roadMaxLength: 50,
            buildings: 4,
            isCavern: false
          };
        case "forest":
          return {
            baseDist: {
              TREE:  0.6,
              GRASS: 0.2,
              DIRT:  0.2
            },
            waterBodies: 3,
            waterMaxSize: 80,
            roads: 3,
            roadMaxLength: 50,
            buildings: 4,
            isCavern: false
          };
        case "cavern":
          return {
            baseDist: {},
            waterBodies: 0,
            waterMaxSize: 0,
            roads: 0,
            roadMaxLength: 0,
            buildings: 0,
            isCavern: true
          };
        case "volcanic":
          return {
            baseDist: {
              // lumps of black stone, maybe some “dirt” lumps
              STONE: 0.6, 
              DIRT:  0.3, 
              GRASS: 0.0,
              TREE:  0.0,
              DESERT:0.1
            },
            waterBodies: 0,
            waterMaxSize: 0,
            roads: 1,
            roadMaxLength: 20,
            buildings: 2,
            isCavern: false
          };
        case "mudlands":
          return {
            baseDist: {
              DIRT: 0.4,
              GRASS: 0.2,
              DESERT:0.1,
              TREE: 0.3
            },
            waterBodies: 3,
            waterMaxSize: 30,
            roads: 1,
            roadMaxLength: 20,
            buildings: 2,
            isCavern: false
          };
        default:
          return {
            baseDist: {
              GRASS: 0.6,
              TREE:  0.2,
              DIRT:  0.1,
              STONE: 0.1
            },
            waterBodies: 2,
            waterMaxSize: 60,
            roads: 4,
            roadMaxLength: 60,
            buildings: 6,
            isCavern: false
          };
      }
    }

    /*******************************************************
     * MAIN MAP GENERATION
     *******************************************************/
    function generateMap() {
      occupantInHand = null; 
      offsetX = 0;
      offsetY = 0;
      scale = 1.0;
      updateCanvasTransform();

      const theme = document.getElementById("mapType").value;
      const style = document.getElementById("mapStyle").value;
      const settings = getMapSettings(theme);

      if (settings.isCavern) {
        generateCavern();
      } else {
        initMap(settings.baseDist);
        for (let i = 0; i < settings.waterBodies; i++) {
          createWaterBody(settings.waterMaxSize);
        }
        for (let r = 0; r < settings.roads; r++) {
          createRoad(settings.roadMaxLength, 2, 3);
        }
      }

      if (!settings.isCavern && style === "village" && settings.buildings > 0) {
        createBuildings(settings.buildings);
      }

      decorateMap(theme);
      drawMap();
    }

    /*******************************************************
     * initMap => distribute base terrain
     *******************************************************/
    function initMap(dist) {
      mapData = [];
      for (let y = 0; y < GRID_HEIGHT; y++) {
        let row = [];
        for (let x = 0; x < GRID_WIDTH; x++) {
          const rand = Math.random();
          let chosenKey = 'GRASS_1'; // default fallback
          let cumul = 0;
          for (let cat in dist) {
            cumul += dist[cat];
            if (rand < cumul) {
              chosenKey = pickTileFromCategory(cat);
              break;
            }
          }
          row.push({ type: chosenKey, occupant: null });
        }
        mapData.push(row);
      }
    }

    // A helper to pick from new tile sets by “logical category”:
    function pickTileFromCategory(cat) {
      switch(cat) {
        case 'GRASS':
          return pickRandom([
            TILE_TYPES.GRASS_1, TILE_TYPES.GRASS_2, TILE_TYPES.GRASS_3,
            TILE_TYPES.GRASS_4, TILE_TYPES.GRASS_5
          ]);
        case 'TREE':
          return pickRandom([
            TILE_TYPES.TREE_1, TILE_TYPES.TREE_2
          ]);
        case 'DIRT':
          return pickRandom([
            TILE_TYPES.DIRT_1, TILE_TYPES.DIRT_2, TILE_TYPES.DIRT_3
          ]);
        case 'DESERT':
          return pickRandom([
            TILE_TYPES.SAND_1, TILE_TYPES.SAND_2, TILE_TYPES.SAND_3,
            TILE_TYPES.DUNE_1, TILE_TYPES.CACTUS_1, TILE_TYPES.CACTUS_2
          ]);
        case 'STONE':
          // We can treat STONE as a chunk of “roadStone” or a random “lavastone,” or something else
          return pickRandom([
            TILE_TYPES.ROAD_STONE, TILE_TYPES.LAVASTONE1, TILE_TYPES.ROAD_DIRT
          ]);
        default:
          // fallback
          return TILE_TYPES.GRASS_1;
      }
    }

    function pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    /*******************************************************
     * decorateMap => further special-case modifications
     *******************************************************/
    function decorateMap(theme){
      for (let y=0; y<GRID_HEIGHT; y++){
        for (let x=0; x<GRID_WIDTH; x++){
          const tile = mapData[y][x];
          
          // Some theming examples
          if(theme === "forest") {
            // Maybe occasionally swap a GRASS tile for shrub?
            if (tile.type.includes("grasstile") && Math.random() < 0.3) {
              tile.type = pickRandom([
                TILE_TYPES.SHRUB_1, TILE_TYPES.SHRUB_2, TILE_TYPES.SHRUB_3
              ]);
            }
          }
          if(theme === "volcanic") {
            // Turn some stone or dirt into lava
            if (tile.type.includes("lavastone") || tile.type.includes("roadDirt")) {
              let r = Math.random();
              if(r < 0.15) tile.type = TILE_TYPES.LAVA_1;
              else if(r < 0.25) tile.type = TILE_TYPES.LAVA_2;
              else if(r < 0.35) tile.type = pickRandom([
                TILE_TYPES.BRIMSTONE1, TILE_TYPES.BRIMSTONE2
              ]);
              else if(r < 0.45) tile.type = TILE_TYPES.MAGMA;
            }
          }
          if(theme === "mudlands") {
            // Make random dirt into swamp
            if(tile.type.includes("dirt") && Math.random()<0.15){
              tile.type = pickRandom([ TILE_TYPES.SWAMP, TILE_TYPES.WATERROCKS ]);
            }
          }
          if(theme === "desert") {
            // Possibly add some extra cacti or dunes
            if(tile.type.includes("sand") && Math.random()<0.2){
              tile.type = pickRandom([
                TILE_TYPES.CACTUS_1, TILE_TYPES.CACTUS_2,
                TILE_TYPES.DUNE_1
              ]);
            }
          }
        }
      }
    }

    /*******************************************************
     * CAVERN GENERATION
     *******************************************************/
    function generateCavern() {
      let boolMap = randomBoolMap(0.45);
      for (let i=0; i<5; i++){
        boolMap = doCAStep(boolMap);
      }
      const { largestMap } = keepLargestRegion(boolMap);
      carveExits(largestMap);
      convertBoolMapToCavern(largestMap);
    }

    function randomBoolMap(fillChance) {
      let bm=[];
      for (let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for (let x=0;x<GRID_WIDTH;x++){
          row.push(Math.random()<fillChance);
        }
        bm.push(row);
      }
      return bm;
    }
    function doCAStep(boolMap){
      let newMap=[];
      for (let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          const n = countFloorNeighbours(boolMap,x,y);
          const curr = boolMap[y][x];
          if(curr) row.push(n>=4);
          else     row.push(n>=5);
        }
        newMap.push(row);
      }
      return newMap;
    }
    function countFloorNeighbours(bm,cx,cy){
      let c=0;
      for(let dy=-1; dy<=1; dy++){
        for(let dx=-1; dx<=1; dx++){
          if(dx===0 && dy===0) continue;
          let nx=cx+dx, ny=cy+dy;
          if(nx>=0 && ny>=0 && nx<GRID_WIDTH && ny<GRID_HEIGHT){
            if(bm[ny][nx]) c++;
          }
        }
      }
      return c;
    }
    function keepLargestRegion(boolMap){
      let visited=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        visited[y]=new Array(GRID_WIDTH).fill(false);
      }
      let bestSize=0, bestRegion=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          if(boolMap[y][x] && !visited[y][x]){
            let queue=[[x,y]];
            visited[y][x]=true;
            let regionCells=[[x,y]];
            let size=1;
            while(queue.length){
              const[cx,cy]=queue.pop();
              for(let[nx,ny]of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]){
                if(nx>=0 && ny>=0 && nx<GRID_WIDTH && ny<GRID_HEIGHT){
                  if(boolMap[ny][nx] && !visited[ny][nx]){
                    visited[ny][nx]=true;
                    queue.push([nx,ny]);
                    regionCells.push([nx,ny]);
                    size++;
                  }
                }
              }
            }
            if(size>bestSize){
              bestSize=size;
              bestRegion=regionCells;
            }
          }
        }
      }
      let largestMap=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        largestMap[y]=boolMap[y].slice();
      }
      let regionSet=new Set(bestRegion.map(([xx,yy])=>`${xx},${yy}`));
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          if(largestMap[y][x] && !regionSet.has(`${x},${y}`)){
            largestMap[y][x]=false;
          }
        }
      }
      return { largestMap, largestRegion: bestRegion };
    }
    function carveExits(boolMap){
      let openings=0;
      for(let x=0;x<GRID_WIDTH;x++){
        if(boolMap[0][x]||boolMap[GRID_HEIGHT-1][x]) openings++;
      }
      for(let y=0;y<GRID_HEIGHT;y++){
        if(boolMap[y][0]||boolMap[y][GRID_WIDTH-1]) openings++;
      }
      if(openings<1) carveRandomLine(boolMap);
      if(openings<2) carveRandomLine(boolMap);
      if(openings<3 && Math.random()<0.5) carveRandomLine(boolMap);
    }
    function carveRandomLine(boolMap){
      let tries=0; let cx,cy;
      while(tries<500){
        cx=Math.floor(Math.random()*GRID_WIDTH);
        cy=Math.floor(Math.random()*GRID_HEIGHT);
        if(boolMap[cy][cx]) break;
        tries++;
      }
      let ex=(Math.random()<0.5)?0:GRID_WIDTH-1;
      let ey=Math.floor(Math.random()*GRID_HEIGHT);
      carveLine(boolMap,cx,cy,ex,ey);
    }
    function carveLine(boolMap,x1,y1,x2,y2){
      let steps=0;
      while((x1!==x2||y1!==y2)&&steps<2000){
        boolMap[y1][x1]=true;
        if(x1<x2)x1++; else if(x1>x2)x1--;
        if(y1<y2)y1++; else if(y1>y2)y1--;
        steps++;
      }
      if(x1>=0 && x1<GRID_WIDTH && y1>=0 && y1<GRID_HEIGHT){
        boolMap[y1][x1]=true;
      }
    }
    function convertBoolMapToCavern(boolMap){
      mapData=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        let row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          if(boolMap[y][x]){
            let r=Math.random();
            // fill with random cave floor or small water pockets
            if(r<0.03) row.push({type:TILE_TYPES.WATER, occupant:null});
            else if(r<0.1) row.push({type:TILE_TYPES.CAVE_2, occupant:null});
            else row.push({type:TILE_TYPES.CAVE_1, occupant:null});
          } else {
            // solid stone
            row.push({type:TILE_TYPES.SOLID_ROCK, occupant:null});
          }
        }
        mapData.push(row);
      }
    }

    /*******************************************************
     * WATER BODIES
     *******************************************************/
    function createWaterBody(maxSize){
      const sx=Math.floor(Math.random()*GRID_WIDTH);
      const sy=Math.floor(Math.random()*GRID_HEIGHT);
      floodFillWater(sx,sy,maxSize);
    }
    function floodFillWater(sx,sy,maxSize){
      let stack=[[sx,sy]];
      let size=0;
      while(stack.length && size<maxSize){
        const[cx,cy]=stack.pop();
        if(cx<0||cy<0||cx>=GRID_WIDTH||cy>=GRID_HEIGHT) continue;
        if(isWaterTile(mapData[cy][cx].type)) continue;
        if(Math.random()<0.2) continue;
        mapData[cy][cx].type=TILE_TYPES.WATER;
        size++;
        stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
      }
    }
    function isWaterTile(tileType){
      return tileType===TILE_TYPES.WATER || tileType===TILE_TYPES.SWAMP || tileType===TILE_TYPES.WATERROCKS;
    }

    /*******************************************************
     * ROADS (+ potential bridging over water)
     *******************************************************/
    function createRoad(maxLength, minW, maxW) {
      let x,y;
      if(Math.random()<0.5){
        x=Math.floor(Math.random()*GRID_WIDTH);
        y=(Math.random()<0.5)?0:GRID_HEIGHT-1;
      } else {
        x=(Math.random()<0.5)?0:GRID_WIDTH-1;
        y=Math.floor(Math.random()*GRID_HEIGHT);
      }
      let direction=getRandomDirection();
      const length=Math.floor(Math.random()*(maxLength/2)+maxLength/2);
      const w=Math.floor(Math.random()*(maxW-minW+1))+minW;

      for(let i=0;i<length;i++){
        carveRoad(x,y,w);
        x+=direction.dx; 
        y+=direction.dy;
        if(Math.random()<0.2) direction=getRandomDirection(direction);
        if(x<0||x>=GRID_WIDTH||y<0||y>=GRID_HEIGHT)break;
      }
    }

    function carveRoad(cx,cy,width){
      const r=Math.floor(width/2);
      for(let dy=-r;dy<=r;dy++){
        for(let dx=-r;dx<=r;dx++){
          let nx=cx+dx, ny=cy+dy;
          if(nx>=0&&nx<GRID_WIDTH&&ny>=0&&ny<GRID_HEIGHT){
            if(isWaterTile(mapData[ny][nx].type)) {
              // Use wood planks for bridging over water
              mapData[ny][nx].type = TILE_TYPES.WOOD_PLANKS;
            } else {
              // Road might be 'stone' or 'dirt'
              mapData[ny][nx].type = (Math.random()<0.4) 
                ? TILE_TYPES.ROAD_STONE
                : TILE_TYPES.ROAD_DIRT;
            }
          }
        }
      }
    }

    function getRandomDirection(prevDir){
      const dirs=[
        {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}
      ];
      if(prevDir&&Math.random()<0.6)return prevDir;
      return dirs[Math.floor(Math.random()*dirs.length)];
    }

    /*******************************************************
     * BUILDINGS
     *******************************************************/
    const buildingShapes = [
      {
        width:4,height:4,
        layout:[
          [1,1,1,1],
          [1,0,0,1],
          [1,0,0,1],
          [1,1,1,1]
        ]
      },
      {
        width:5,height:5,
        layout:[
          [1,1,1,1,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,1,1,1,1]
        ]
      },
      {
        width:6,height:5,
        layout:[
          [1,1,1,1,1,1],
          [1,0,0,0,0,1],
          [1,0,0,0,0,1],
          [1,0,0,0,0,1],
          [1,1,1,1,1,1]
        ]
      },
      {
        width:7,height:5,
        layout:[
          [1,1,1,1,1,1,1],
          [1,0,0,0,0,0,1],
          [1,0,0,0,0,0,1],
          [1,0,0,0,0,0,1],
          [1,1,1,1,1,1,1]
        ]
      }
    ];

    let chosenFloorTileForBuildings=null;

    function createBuildings(numBuildings){
      chosenFloorTileForBuildings = pickRandom(BUILDING_FLOORS);
      let attempts=0, placed=0;
      while(placed<numBuildings && attempts<numBuildings*50){
        attempts++;
        const shape=pickRandom(buildingShapes);
        const sx=Math.floor(Math.random()*(GRID_WIDTH - shape.width));
        const sy=Math.floor(Math.random()*(GRID_HEIGHT - shape.height));
        if(canPlaceBuilding(sx,sy,shape)){
          placeBuilding(sx,sy,shape);
          placed++;
        }
      }
    }
    function canPlaceBuilding(sx,sy,shape){
      for(let y=0;y<shape.height;y++){
        for(let x=0;x<shape.width;x++){
          const val=shape.layout[y][x];
          if(val===1||val===0){
            const tileType=mapData[sy+y][sx+x].type;
            if(isWaterTile(tileType) || tileType.includes("lava") 
               || tileType.includes("magma") || tileType.includes("brimstone")
               || tileType.includes("caveRock") ){
              return false;
            }
          }
        }
      }
      return true;
    }
    function placeBuilding(sx,sy,shape){
      let localLayout = shape.layout.map(r=>r.slice());
      subdivideBuilding(localLayout);
      placeExteriorDoor(localLayout);
      ensureAccessibility(localLayout);
      stampBuildingOntoMap(localLayout,sx,sy,chosenFloorTileForBuildings);
    }
    function subdivideBuilding(localLayout){
      const h=localLayout.length; 
      const w=localLayout[0].length;
      // vertical
      if(w>=7){
        let wx=Math.floor(w/2);
        for(let y=1;y<h-1;y++){
          localLayout[y][wx]=1; 
        }
        let doorY=Math.floor(Math.random()*(h-2))+1;
        localLayout[doorY][wx]=2; // door placeholder
      }
      // horizontal
      if(h>=7){
        let wy=Math.floor(h/2);
        for(let x=1;x<w-1;x++){
          localLayout[wy][x]=1;
        }
        let doorX=Math.floor(Math.random()*(w-2))+1;
        localLayout[wy][doorX]=2;
      }
    }
    function placeExteriorDoor(localLayout){
      const h=localLayout.length; 
      const w=localLayout[0].length;
      let candidates=[];
      for(let x=1;x<w-1;x++){
        if(isWallish(localLayout[0][x]) && hasExactlyTwoOrthWalls(localLayout,x,0)){
          candidates.push({px:x,py:0});
        }
        if(isWallish(localLayout[h-1][x]) && hasExactlyTwoOrthWalls(localLayout,x,h-1)){
          candidates.push({px:x,py:h-1});
        }
      }
      for(let y=1;y<h-1;y++){
        if(isWallish(localLayout[y][0]) && hasExactlyTwoOrthWalls(localLayout,0,y)){
          candidates.push({px:0,py:y});
        }
        if(isWallish(localLayout[y][w-1]) && hasExactlyTwoOrthWalls(localLayout,w-1,y)){
          candidates.push({px:w-1,py:y});
        }
      }
      if(candidates.length>0){
        let howMany=1+Math.floor(Math.random()*2);
        for(let i=0;i<howMany && candidates.length;i++){
          let idx=Math.floor(Math.random()*candidates.length);
          let chosen=candidates[idx];
          localLayout[chosen.py][chosen.px]=2; 
          candidates.splice(idx,1);
        }
      }
    }
    function isWallish(val){
      return val===1||val===2;
    }
    function hasExactlyTwoOrthWalls(localLayout,x,y){
      let up=(y>0)&&isWallish(localLayout[y-1][x]);
      let down=(y<localLayout.length-1)&&isWallish(localLayout[y+1][x]);
      let left=(x>0)&&isWallish(localLayout[y][x-1]);
      let right=(x<localLayout[0].length-1)&&isWallish(localLayout[y][x+1]);
      let c=(up?1:0)+(down?1:0)+(left?1:0)+(right?1:0);
      if(c===2){
        if(up&&down)return true;
        if(left&&right)return true;
      }
      return false;
    }
    function ensureAccessibility(localLayout){
      const floors=collectFloorCells(localLayout);
      if(!floors.length)return;
      let doorCoords=collectDoorCoords(localLayout);
      if(!doorCoords.length)return;
      let mainDoor=doorCoords.find(d=>isOnPerimeter(localLayout,d.x,d.y))||doorCoords[0];
      if(!mainDoor)return;

      let visited=new Set();
      let queue=[];
      queue.push({x:mainDoor.x,y:mainDoor.y});
      visited.add(`${mainDoor.x},${mainDoor.y}`);

      while(queue.length){
        let {x,y}=queue.shift();
        for(let [nx,ny]of[[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
          if(nx<0||ny<0||nx>=localLayout[0].length||ny>=localLayout.length)continue;
          let val=localLayout[ny][nx];
          if(val===0||val===2){
            let key=`${nx},${ny}`;
            if(!visited.has(key)){
              visited.add(key);
              queue.push({x:nx,y:ny});
            }
          }
        }
      }
      let allVisited=floors.every(c=>visited.has(`${c.x},${c.y}`));
      if(!allVisited){
        forceInteriorDoor(localLayout,visited);
      }
    }
    function collectFloorCells(localLayout){
      let res=[];
      for(let y=0;y<localLayout.length;y++){
        for(let x=0;x<localLayout[0].length;x++){
          if(localLayout[y][x]===0||localLayout[y][x]===2){
            res.push({x,y});
          }
        }
      }
      return res;
    }
    function collectDoorCoords(localLayout){
      let res=[];
      for(let y=0;y<localLayout.length;y++){
        for(let x=0;x<localLayout[0].length;x++){
          if(localLayout[y][x]===2){
            res.push({x,y});
          }
        }
      }
      return res;
    }
    function isOnPerimeter(localLayout,x,y){
      return (x===0||y===0||x===localLayout[0].length-1||y===localLayout.length-1);
    }
    function forceInteriorDoor(localLayout,visited){
      const h=localLayout.length; 
      const w=localLayout[0].length;
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          if(localLayout[y][x]===1 && hasExactlyTwoOrthWalls(localLayout,x,y)){
            let sides=[[1,0],[-1,0],[0,1],[0,-1]];
            let visitedSide=false,unvisitedSide=false;
            for(let s of sides){
              let nx=x+s[0], ny=y+s[1];
              if(nx>=0&&ny>=0&&nx<w&&ny<h){
                if(localLayout[ny][nx]===0||localLayout[ny][nx]===2){
                  if(visited.has(`${nx},${ny}`)) visitedSide=true;
                  else unvisitedSide=true;
                }
              }
            }
            if(visitedSide && unvisitedSide){
              localLayout[y][x]=2; // door
              return;
            }
          }
        }
      }
    }
    function stampBuildingOntoMap(localLayout,sx,sy,floorTile){
      const h=localLayout.length;
      const w=localLayout[0].length;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const val=localLayout[y][x];
          if(val===1){
            // pick random building wall
            mapData[sy+y][sx+x].type = pickRandom(BUILDING_WALLS);
          } else if(val===0){
            // assigned floor
            mapData[sy+y][sx+x].type = floorTile;
          } else if(val===2){
            // door
            mapData[sy+y][sx+x].type = pickRandom(BUILDING_DOORS);
          }
        }
      }
    }

    /*******************************************************
     * DRAWING
     *******************************************************/
    function drawMap(){
      const canvas = document.getElementById("mapCanvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);

      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          drawCell(ctx,x,y);
        }
      }
    }
    function drawCell(ctx,gx,gy){
      const tile=mapData[gy][gx];
      const px=gx*TILE_SIZE;
      const py=gy*TILE_SIZE;

      if(tile.occupant){
        drawOccupantSprite(ctx,tile.occupant,px,py);
      } else {
        const path = tile.type;
        const tex=tileTextures[path];
        if(tex && tex.complete){
          ctx.drawImage(tex,px,py,TILE_SIZE,TILE_SIZE);
        } else {
          ctx.fillStyle=getColorForTileType(path);
          ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
        }
      }
      ctx.strokeStyle="rgba(0,0,0,0.3)";
      ctx.strokeRect(px,py,TILE_SIZE,TILE_SIZE);
    }

    function drawOccupantSprite(ctx, occupant, px, py){
      if(occupant.sprite && occupant.sprite !== "none"){
        const spriteImg = occupantSpritesMap[occupant.sprite];
        if(spriteImg && spriteImg.complete){
          ctx.drawImage(spriteImg, px, py, TILE_SIZE, TILE_SIZE);
        } else {
          ctx.fillStyle="#999";
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      }
      const borderColor = occupantColours[occupant.type] || "#FF00FF";
      ctx.strokeStyle=borderColor;
      ctx.lineWidth=1;
      ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
    }

    /*******************************************************
     * MODE SELECTOR
     *******************************************************/
    function setMode(mode){
      currentMode = mode;
      if(currentMode !== 'move'){
        occupantInHand = null;
      }
    }

    /*******************************************************
     * CANVAS EVENTS (pointer, zoom, occupant placement)
     *******************************************************/
    const canvas = document.getElementById("mapCanvas");
    const mapWrapper = document.querySelector(".mapWrapper");

    function updateCanvasTransform(){
      canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
    }

    canvas.addEventListener("click",(e)=>{
      if(isDragging || activePointers.size > 1) return;

      const wrapperRect = mapWrapper.getBoundingClientRect();
      const mouseXInWrapper = e.clientX - wrapperRect.left;
      const mouseYInWrapper = e.clientY - wrapperRect.top;

      const worldX = (mouseXInWrapper - offsetX) / scale;
      const worldY = (mouseYInWrapper - offsetY) / scale;

      const tileX = Math.floor(worldX / TILE_SIZE);
      const tileY = Math.floor(worldY / TILE_SIZE);
      if(tileX<0||tileY<0||tileX>=GRID_WIDTH||tileY>=GRID_HEIGHT) return;

      const occupantType=document.getElementById("occupantType").value;
      const occupantSprite=document.getElementById("occupantSprite").value;
      const tile=mapData[tileY][tileX];

      switch(currentMode){
        case 'delete':
          if(tile.occupant){
            tile.occupant = null;
            occupantInHand = null;
            drawCell(canvas.getContext("2d"), tileX, tileY);
          }
          break;
        case 'move':
          if(!occupantInHand){
            if(tile.occupant){
              occupantInHand = tile.occupant;
              tile.occupant = null;
              drawCell(canvas.getContext("2d"), tileX, tileY);
            }
          } else {
            tile.occupant = occupantInHand;
            occupantInHand = null;
            drawCell(canvas.getContext("2d"), tileX, tileY);
          }
          break;
        case 'place':
        default:
          occupantInHand = null;
          if(occupantType === "none") return;
          tile.occupant = {
            type: occupantType,
            sprite: occupantSprite
          };
          drawCell(canvas.getContext("2d"), tileX, tileY);
          break;
      }
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const wrapperRect = mapWrapper.getBoundingClientRect();
      const mouseX = e.clientX - wrapperRect.left;
      const mouseY = e.clientY - wrapperRect.top;

      const worldX = (mouseX - offsetX) / scale;
      const worldY = (mouseY - offsetY) / scale;

      const zoomSpeed = 0.1;
      let newScale = scale;
      if(e.deltaY < 0) {
        newScale += zoomSpeed;
      } else {
        newScale -= zoomSpeed;
      }
      newScale = Math.min(Math.max(newScale, minScale), maxScale);

      offsetX = mouseX - worldX * newScale;
      offsetY = mouseY - worldY * newScale;
      scale = newScale;

      updateCanvasTransform();
    }, { passive: false });

    canvas.addEventListener("pointerdown", (e) => {
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (activePointers.size === 1) {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
      }
      else if (activePointers.size === 2) {
        isDragging = false; 
        initialPinchDistance = getPinchDistance();
        initialPinchScale = scale;
      }
    });
    window.addEventListener("pointermove", (e) => {
      if (!activePointers.has(e.pointerId)) return;

      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePointers.size === 1 && isDragging) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        offsetX += dx;
        offsetY += dy;
        updateCanvasTransform();
      } 
      else if (activePointers.size === 2) {
        const newDist = getPinchDistance();
        const scaleRatio = newDist / initialPinchDistance;
        let newScale = initialPinchScale * scaleRatio;
        newScale = Math.min(Math.max(newScale, minScale), maxScale);

        const midpoint = getPinchMidpoint();
        const wrapperRect = mapWrapper.getBoundingClientRect();
        const midXInWrapper = midpoint.x - wrapperRect.left;
        const midYInWrapper = midpoint.y - wrapperRect.top;

        const worldX = (midXInWrapper - offsetX) / scale;
        const worldY = (midYInWrapper - offsetY) / scale;

        scale = newScale;
        offsetX = midXInWrapper - worldX * newScale;
        offsetY = midYInWrapper - worldY * newScale;
        updateCanvasTransform();

        e.preventDefault();
      }
    });
    window.addEventListener("pointerup", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) {
        initialPinchDistance = 0;
      }
      if (activePointers.size === 0) {
        isDragging = false;
      }
    });
    window.addEventListener("pointercancel", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) {
        initialPinchDistance = 0;
      }
      if (activePointers.size === 0) {
        isDragging = false;
      }
    });
    function getPinchDistance() {
      if (activePointers.size !== 2) return 0;
      const points = [...activePointers.values()];
      const dx = points[0].x - points[1].x;
      const dy = points[0].y - points[1].y;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function getPinchMidpoint() {
      const points = [...activePointers.values()];
      const x = (points[0].x + points[1].x) / 2;
      const y = (points[0].y + points[1].y) / 2;
      return { x, y };
    }

    /*******************************************************
     * CLEAR button => occupantType = none, occupantSprite = none
     *******************************************************/
    function clearOccupantSelection() {
      document.getElementById("occupantType").value = "none";
      document.getElementById("occupantSprite").value = "none";
    }

    /*******************************************************
     * ON LOAD
     *******************************************************/
    window.onload=()=>{
      preloadImages(()=>{
        generateMap();
      });
    };
  </script>
</body>
</html>
