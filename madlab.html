<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>D&D Map Generator (Improved)</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Almendra&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* --- Global Styles --- */
    body {
      margin: 0;
      background: url('resources/alcazar.png') no-repeat center center fixed;
      background-size: cover;
      color: #FAF4E0;
      font-family: 'Almendra', serif;
      text-align: center;
    }
    .container {
      width: fit-content; /* Expand to fit the 1000px canvas */
      margin: 2rem auto;
      background: rgba(0, 0, 0, 0.7);
      padding: 2rem;
      border-radius: 10px;
    }
    h1, h2 {
      font-family: 'Cinzel', serif;
      margin: 0.5rem 0;
    }
    .description {
      font-size: 1.2rem;
      margin-top: 1rem;
    }
    .mapWrapper {
      text-align: center;
    }
    #mapCanvas {
      border: 2px solid #660000;
      background: #202020;
      display: block;
      margin: 1rem auto; 
      image-rendering: pixelated;
    }
    .mapButton {
      display: inline-block;
      margin: 0.5rem;
      padding: 0.6rem 1rem;
      font-family: 'Cinzel', serif;
      background: #8B0000;
      color: #FAF4E0;
      border: 1px solid #660000;
      border-radius: 4px;
      cursor: pointer;
      text-decoration: none;
    }
    .mapButton:hover {
      background: #660000;
    }
    .controls {
      margin: 1rem auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .controls label {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>D&D Map Generator (Improved)</h1>
    <p class="description">
      "Explore deserts, forests, caverns, or other lands. Choose whether it's a bustling village or a wild frontier!"
    </p>
    
    <div class="controls">
      <!-- Biome / Map Type Selection -->
      <label>
        Map Biome:
        <select id="mapType">
          <option value="desert">Desert</option>
          <option value="city">City</option>
          <option value="village">Village</option>
          <option value="grassland" selected>Grassland</option>
          <option value="mountain">Mountain</option>
          <option value="forest">Forest</option>
          <option value="cavern">Cavern</option>
        </select>
      </label>
      
      <!-- Style Selection -->
      <label>
        Map Style:
        <select id="mapStyle">
          <option value="village" selected>Village</option>
          <option value="wilds">Wilds (No Buildings)</option>
        </select>
      </label>
      
      <button class="mapButton">Generate Map</button>
      
      <!-- Occupant Selection -->
      <label>
        Occupant:
        <select id="occupantType">
          <option value="player">Player</option>
          <option value="enemy">Enemy</option>
          <option value="npc">NPC</option>
        </select>
      </label>
    </div>
    
    <div class="mapWrapper">
      <canvas id="mapCanvas" width="1000" height="1000"></canvas>
    </div>
  </div>

  <script type="module">
    /*******************************************************
     * CONFIGURATION & GLOBALS
     *******************************************************/
    const CONFIG = {
      tileSize: 20,
      gridWidth: 50,
      gridHeight: 50,
      assetPath: 'resources/mapassets/',
      canvasId: 'mapCanvas'
    };

    let mapData = [];
    let occupantInHand = null;

    // TILE TYPES (strings correspond to asset filenames)
    const TILE_TYPES = {
      GRASS:       "grass",
      TREE:        "tree",
      DIRT:        "dirt",
      SAND:        "sand",
      WATER:       "water",
      ROAD_STONE:  "roadStone",
      ROAD_DIRT:   "roadDirt",
      STONE:       "stone",
      WALL:        "wall",
      FLOOR:       "floor",
      DOOR:        "door",
      SOLID_STONE: "solidStone"
    };

    // Fallback colours (used if texture image isn't available)
    const baseTileColours = {
      [TILE_TYPES.GRASS]:       "#9AE582",
      [TILE_TYPES.TREE]:        "#7BC16E",
      [TILE_TYPES.DIRT]:        "#C2A15F",
      [TILE_TYPES.SAND]:        "#DDD593",
      [TILE_TYPES.WATER]:       "#2B64CF",
      [TILE_TYPES.ROAD_STONE]:  "#777777",
      [TILE_TYPES.ROAD_DIRT]:   "#A37E4C",
      [TILE_TYPES.STONE]:       "#AAAAAA",
      [TILE_TYPES.WALL]:        "#8B4513",
      [TILE_TYPES.FLOOR]:       "#555555",
      [TILE_TYPES.DOOR]:        "#552200",
      [TILE_TYPES.SOLID_STONE]: "#000000"
    };

    // Preloaded textures dictionary
    const tileTextures = {};

    // Utility: fallback colour retrieval
    const getColorForTileType = (tileType) => baseTileColours[tileType] || "#FFFFFF";

    // Utility: get key by value from TILE_TYPES (e.g. 'grass' â†’ 'GRASS')
    const getKeyByValue = (obj, val) => Object.keys(obj).find(key => obj[key] === val);

    // Canvas context
    const canvas = document.getElementById(CONFIG.canvasId);
    const ctx = canvas.getContext("2d");

    /*******************************************************
     * ASSET MANAGEMENT: Preload Textures with async/await
     *******************************************************/
    async function preloadTextures() {
      const tileKeys = Object.keys(TILE_TYPES);
      const promises = tileKeys.map(key => {
        return new Promise((resolve) => {
          const tileName = TILE_TYPES[key];
          const img = new Image();
          img.src = `${CONFIG.assetPath}${tileName}.png`;
          img.onload = () => {
            tileTextures[key] = img;
            resolve();
          };
          img.onerror = () => {
            console.error(`Error loading image: ${CONFIG.assetPath}${tileName}.png`);
            // Even if an image fails, we resolve (using fallback fill)
            tileTextures[key] = null;
            resolve();
          };
        });
      });
      await Promise.all(promises);
    }

    /*******************************************************
     * BIOME & MAP SETTINGS
     *******************************************************/
    function getMapSettings(theme) {
      switch(theme) {
        case "desert":
          return {
            baseDist: { SAND: 0.6, DIRT: 0.2, STONE: 0.1, TREE: 0.0, GRASS: 0.1 },
            waterBodies: 1,
            waterMaxSize: 50,
            roads: 2,
            roadMaxLength: 40,
            buildings: 5,
            isCavern: false
          };
        case "city":
          return {
            baseDist: { DIRT: 0.05, STONE: 0.2, GRASS: 0.15, TREE: 0.1 },
            waterBodies: 2,
            waterMaxSize: 80,
            roads: 8,
            roadMaxLength: 80,
            buildings: 15,
            isCavern: false
          };
        case "village":
          return {
            baseDist: { GRASS: 0.4, DIRT: 0.3, STONE: 0.05, TREE: 0.2 },
            waterBodies: 2,
            waterMaxSize: 60,
            roads: 4,
            roadMaxLength: 60,
            buildings: 8,
            isCavern: false
          };
        case "grassland":
          return {
            baseDist: { GRASS: 0.6, TREE: 0.2, DIRT: 0.1, STONE: 0.05 },
            waterBodies: 3,
            waterMaxSize: 120,
            roads: 4,
            roadMaxLength: 60,
            buildings: 6,
            isCavern: false
          };
        case "mountain":
          return {
            baseDist: { STONE: 0.4, DIRT: 0.3, GRASS: 0.1, TREE: 0.05 },
            waterBodies: 1,
            waterMaxSize: 40,
            roads: 3,
            roadMaxLength: 50,
            buildings: 4,
            isCavern: false
          };
        case "forest":
          return {
            baseDist: { TREE: 0.6, GRASS: 0.2, DIRT: 0.1, STONE: 0.05 },
            waterBodies: 3,
            waterMaxSize: 80,
            roads: 3,
            roadMaxLength: 50,
            buildings: 4,
            isCavern: false
          };
        case "cavern":
          return {
            baseDist: {},
            waterBodies: 0,
            waterMaxSize: 0,
            roads: 0,
            roadMaxLength: 0,
            buildings: 0,
            isCavern: true
          };
        default:
          return {
            baseDist: { GRASS: 0.6, TREE: 0.2, DIRT: 0.1, STONE: 0.05 },
            waterBodies: 2,
            waterMaxSize: 60,
            roads: 4,
            roadMaxLength: 60,
            buildings: 6,
            isCavern: false
          };
      }
    }

    /*******************************************************
     * MAP GENERATION FUNCTIONS
     *******************************************************/
    // Initialize non-cavern map using base distribution probabilities
    function initMap(dist) {
      mapData = [];
      let totalP = 0;
      for (let t in dist) { totalP += dist[t]; }
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          const rand = Math.random();
          let chosen = TILE_TYPES.GRASS;
          let cumul = 0;
          for (let t in dist) {
            cumul += dist[t];
            if (rand < cumul) {
              chosen = TILE_TYPES[t];
              break;
            }
          }
          row.push({ type: chosen, occupant: null });
        }
        mapData.push(row);
      }
    }

    // Cellular Automata-based cavern generation
    function generateCavern() {
      let boolMap = randomBoolMap(0.45);
      for (let i = 0; i < 5; i++) { boolMap = doCAStep(boolMap); }
      const { largestMap, largestRegion } = keepLargestRegion(boolMap);
      carveExits(largestMap, largestRegion);
      convertBoolMapToCavern(largestMap);
    }

    function randomBoolMap(fillChance) {
      const bm = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          row.push(Math.random() < fillChance);
        }
        bm.push(row);
      }
      return bm;
    }

    function doCAStep(bm) {
      const newMap = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          const n = countFloorNeighbours(bm, x, y);
          row.push(bm[y][x] ? (n >= 4) : (n >= 5));
        }
        newMap.push(row);
      }
      return newMap;
    }

    function countFloorNeighbours(bm, cx, cy) {
      let c = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = cx + dx, ny = cy + dy;
          if (nx >= 0 && ny >= 0 && nx < CONFIG.gridWidth && ny < CONFIG.gridHeight) {
            if (bm[ny][nx]) c++;
          }
        }
      }
      return c;
    }

    function keepLargestRegion(bm) {
      const visited = Array.from({ length: CONFIG.gridHeight }, () => Array(CONFIG.gridWidth).fill(false));
      let bestSize = 0, bestRegion = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          if (bm[y][x] && !visited[y][x]) {
            const queue = [[x, y]];
            visited[y][x] = true;
            const regionCells = [[x, y]];
            let size = 1;
            while (queue.length) {
              const [cx, cy] = queue.pop();
              for (let [nx, ny] of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]) {
                if (nx >= 0 && ny >= 0 && nx < CONFIG.gridWidth && ny < CONFIG.gridHeight) {
                  if (bm[ny][nx] && !visited[ny][nx]) {
                    visited[ny][nx] = true;
                    queue.push([nx, ny]);
                    regionCells.push([nx, ny]);
                    size++;
                  }
                }
              }
            }
            if (size > bestSize) {
              bestSize = size;
              bestRegion = regionCells;
            }
          }
        }
      }
      const largestMap = bm.map(row => row.slice());
      const regionSet = new Set(bestRegion.map(([xx, yy]) => `${xx},${yy}`));
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          if (largestMap[y][x] && !regionSet.has(`${x},${y}`)) {
            largestMap[y][x] = false;
          }
        }
      }
      return { largestMap, largestRegion: bestRegion };
    }

    function carveExits(bm, regionCells) {
      let boundaryCount = 0;
      for (const [x, y] of regionCells) {
        if (x === 0 || x === CONFIG.gridWidth - 1 || y === 0 || y === CONFIG.gridHeight - 1) {
          boundaryCount++;
          if (boundaryCount >= 3) break;
        }
      }
      if (boundaryCount < 1) {
        const needed = 1 + Math.floor(Math.random() * 3);
        for (let i = 0; i < needed; i++) { carveOneExit(bm, regionCells); }
      } else if (boundaryCount < 3) {
        const toAdd = Math.floor(Math.random() * (3 - boundaryCount + 1));
        for (let i = 0; i < toAdd; i++) { carveOneExit(bm, regionCells); }
      }
    }

    function carveOneExit(bm, regionCells) {
      if (!regionCells.length) return;
      const [rx, ry] = regionCells[Math.floor(Math.random() * regionCells.length)];
      let edgeX, edgeY;
      const side = Math.floor(Math.random() * 4);
      if (side === 0) { edgeY = 0; edgeX = Math.floor(Math.random() * CONFIG.gridWidth); }
      else if (side === 1) { edgeY = CONFIG.gridHeight - 1; edgeX = Math.floor(Math.random() * CONFIG.gridWidth); }
      else if (side === 2) { edgeX = 0; edgeY = Math.floor(Math.random() * CONFIG.gridHeight); }
      else { edgeX = CONFIG.gridWidth - 1; edgeY = Math.floor(Math.random() * CONFIG.gridHeight); }
      carveLine(bm, rx, ry, edgeX, edgeY);
    }

    function carveLine(bm, x1, y1, x2, y2) {
      let steps = 0;
      while ((x1 !== x2 || y1 !== y2) && steps < 2000) {
        bm[y1][x1] = true;
        if (x1 < x2) x1++;
        else if (x1 > x2) x1--;
        if (y1 < y2) y1++;
        else if (y1 > y2) y1--;
        steps++;
      }
      if (x1 >= 0 && x1 < CONFIG.gridWidth && y1 >= 0 && y1 < CONFIG.gridHeight) {
        bm[y1][x1] = true;
      }
    }

    function convertBoolMapToCavern(bm) {
      mapData = [];
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        const row = [];
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          if (bm[y][x]) {
            const r = Math.random();
            if (r < 0.03) row.push({ type: TILE_TYPES.WATER, occupant: null });
            else if (r < 0.15) row.push({ type: TILE_TYPES.DIRT, occupant: null });
            else row.push({ type: TILE_TYPES.STONE, occupant: null });
          } else {
            row.push({ type: TILE_TYPES.SOLID_STONE, occupant: null });
          }
        }
        mapData.push(row);
      }
    }

    /*******************************************************
     * WATER & ROAD FUNCTIONS
     *******************************************************/
    function createWaterBody(maxSize) {
      const sx = Math.floor(Math.random() * CONFIG.gridWidth);
      const sy = Math.floor(Math.random() * CONFIG.gridHeight);
      floodFillWater(sx, sy, maxSize);
    }
    function floodFillWater(sx, sy, maxSize) {
      const stack = [[sx, sy]];
      let size = 0;
      while (stack.length && size < maxSize) {
        const [cx, cy] = stack.pop();
        if (cx < 0 || cy < 0 || cx >= CONFIG.gridWidth || cy >= CONFIG.gridHeight) continue;
        if (mapData[cy][cx].type === TILE_TYPES.WATER) continue;
        if (Math.random() < 0.2) continue;
        mapData[cy][cx].type = TILE_TYPES.WATER;
        size++;
        stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
      }
    }
    function createRoad(maxLength, minW, maxW) {
      let x, y;
      if (Math.random() < 0.5) {
        x = Math.floor(Math.random() * CONFIG.gridWidth);
        y = (Math.random() < 0.5) ? 0 : CONFIG.gridHeight - 1;
      } else {
        x = (Math.random() < 0.5) ? 0 : CONFIG.gridWidth - 1;
        y = Math.floor(Math.random() * CONFIG.gridHeight);
      }
      let direction = getRandomDirection();
      const length = Math.floor(Math.random() * (maxLength / 2) + maxLength / 2);
      const w = Math.floor(Math.random() * (maxW - minW + 1)) + minW;
      for (let i = 0; i < length; i++) {
        carveRoad(x, y, w);
        x += direction.dx;
        y += direction.dy;
        if (Math.random() < 0.2) direction = getRandomDirection(direction);
        if (x < 0 || x >= CONFIG.gridWidth || y < 0 || y >= CONFIG.gridHeight) break;
      }
    }
    function carveRoad(cx, cy, width) {
      const r = Math.floor(width / 2);
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          const nx = cx + dx, ny = cy + dy;
          if (nx >= 0 && nx < CONFIG.gridWidth && ny >= 0 && ny < CONFIG.gridHeight) {
            mapData[ny][nx].type = (Math.random() < 0.6) ? TILE_TYPES.ROAD_STONE : TILE_TYPES.ROAD_DIRT;
          }
        }
      }
    }
    function getRandomDirection(prevDir) {
      const dirs = [{dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}];
      if (prevDir && Math.random() < 0.6) return prevDir;
      return dirs[Math.floor(Math.random() * dirs.length)];
    }

    /*******************************************************
     * BUILDING GENERATION (with improved door logic)
     *******************************************************/
    const buildingShapes = [
      { width: 4, height: 4, layout: [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]] },
      { width: 5, height: 5, layout: [[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1]] },
      { width: 6, height: 5, layout: [[1,1,1,1,1,1],[1,0,0,0,0,1],[1,0,0,0,0,1],[1,0,0,0,0,1],[1,1,1,1,1,1]] },
      { width: 7, height: 5, layout: [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] },
      { width: 7, height: 7, layout: [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] },
      { width: 8, height: 5, layout: [[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1]] }
    ];
    function createBuildings(numBuildings) {
      let attempts = 0, placed = 0;
      while (placed < numBuildings && attempts < numBuildings * 50) {
        attempts++;
        const shape = buildingShapes[Math.floor(Math.random() * buildingShapes.length)];
        const sx = Math.floor(Math.random() * (CONFIG.gridWidth - shape.width));
        const sy = Math.floor(Math.random() * (CONFIG.gridHeight - shape.height));
        if (canPlaceBuilding(sx, sy, shape)) {
          placeBuilding(sx, sy, shape);
          placed++;
        }
      }
    }
    function canPlaceBuilding(sx, sy, shape) {
      for (let y = 0; y < shape.height; y++) {
        for (let x = 0; x < shape.width; x++) {
          const val = shape.layout[y][x];
          if (val === 1 || val === 0) {
            const tileType = mapData[sy+y][sx+x].type;
            if ([TILE_TYPES.WATER, TILE_TYPES.ROAD_STONE, TILE_TYPES.ROAD_DIRT, TILE_TYPES.SOLID_STONE].includes(tileType)) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function placeBuilding(sx, sy, shape) {
      let localLayout = shape.layout.map(row => row.slice());
      subdivideBuilding(localLayout);
      placeExteriorDoor(localLayout);
      ensureAccessibility(localLayout);
      stampBuildingOntoMap(localLayout, sx, sy);
    }
    function subdivideBuilding(localLayout) {
      const h = localLayout.length;
      const w = localLayout[0].length;
      if (w >= 7) {
        const wx = Math.floor(w / 2);
        for (let y = 1; y < h - 1; y++) { localLayout[y][wx] = 1; }
        const doorY = Math.floor(Math.random() * (h - 2)) + 1;
        localLayout[doorY][wx] = 2;
      }
      if (h >= 7) {
        const wy = Math.floor(h / 2);
        for (let x = 1; x < w - 1; x++) { localLayout[wy][x] = 1; }
        const doorX = Math.floor(Math.random() * (w - 2)) + 1;
        localLayout[wy][doorX] = 2;
      }
    }
    function placeExteriorDoor(localLayout) {
      const h = localLayout.length;
      const w = localLayout[0].length;
      let candidates = [];
      for (let x = 1; x < w - 1; x++) {
        if (isWallish(localLayout[0][x]) && hasExactlyTwoOrthWalls(localLayout, x, 0)) {
          candidates.push({ px: x, py: 0 });
        }
        if (isWallish(localLayout[h-1][x]) && hasExactlyTwoOrthWalls(localLayout, x, h-1)) {
          candidates.push({ px: x, py: h-1 });
        }
      }
      for (let y = 1; y < h - 1; y++) {
        if (isWallish(localLayout[y][0]) && hasExactlyTwoOrthWalls(localLayout, 0, y)) {
          candidates.push({ px: 0, py: y });
        }
        if (isWallish(localLayout[y][w-1]) && hasExactlyTwoOrthWalls(localLayout, w-1, y)) {
          candidates.push({ px: w-1, py: y });
        }
      }
      if (candidates.length > 0) {
        const howMany = 1 + Math.floor(Math.random() * 2);
        for (let i = 0; i < howMany && candidates.length; i++) {
          const idx = Math.floor(Math.random() * candidates.length);
          const chosen = candidates[idx];
          localLayout[chosen.py][chosen.px] = 2;
          candidates.splice(idx, 1);
        }
      }
    }
    function ensureAccessibility(localLayout) {
      const floors = collectFloorCells(localLayout);
      if (!floors.length) return;
      const doorCoords = collectDoorCoords(localLayout);
      if (!doorCoords.length) return;
      const mainDoor = doorCoords.find(d => isOnPerimeter(localLayout, d.x, d.y)) || doorCoords[0];
      if (!mainDoor) return;
      const visited = new Set();
      const queue = [];
      queue.push({ x: mainDoor.x, y: mainDoor.y });
      visited.add(`${mainDoor.x},${mainDoor.y}`);
      while (queue.length) {
        const { x, y } = queue.shift();
        for (const [nx, ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]) {
          if (nx < 0 || ny < 0 || nx >= localLayout[0].length || ny >= localLayout.length) continue;
          const val = localLayout[ny][nx];
          if (val === 0 || val === 2) {
            const key = `${nx},${ny}`;
            if (!visited.has(key)) {
              visited.add(key);
              queue.push({ x: nx, y: ny });
            }
          }
        }
      }
      const allVisited = floors.every(cell => visited.has(`${cell.x},${cell.y}`));
      if (!allVisited) { forceInteriorDoor(localLayout, visited); }
    }
    function collectFloorCells(localLayout) {
      const res = [];
      for (let y = 0; y < localLayout.length; y++) {
        for (let x = 0; x < localLayout[0].length; x++) {
          if (localLayout[y][x] === 0 || localLayout[y][x] === 2) { res.push({ x, y }); }
        }
      }
      return res;
    }
    function collectDoorCoords(localLayout) {
      const res = [];
      for (let y = 0; y < localLayout.length; y++) {
        for (let x = 0; x < localLayout[0].length; x++) {
          if (localLayout[y][x] === 2) { res.push({ x, y }); }
        }
      }
      return res;
    }
    function isOnPerimeter(localLayout, x, y) {
      return (x === 0 || y === 0 || x === localLayout[0].length - 1 || y === localLayout.length - 1);
    }
    function isWallish(val) { return val === 1 || val === 2; }
    function hasExactlyTwoOrthWalls(localLayout, x, y) {
      const up = (y > 0) && isWallish(localLayout[y-1][x]);
      const down = (y < localLayout.length - 1) && isWallish(localLayout[y+1][x]);
      const left = (x > 0) && isWallish(localLayout[y][x-1]);
      const right = (x < localLayout[0].length - 1) && isWallish(localLayout[y][x+1]);
      const count = (up ? 1 : 0) + (down ? 1 : 0) + (left ? 1 : 0) + (right ? 1 : 0);
      if (count === 2) {
        if (up && down) return true;
        if (left && right) return true;
      }
      return false;
    }
    function forceInteriorDoor(localLayout, visited) {
      const h = localLayout.length, w = localLayout[0].length;
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          if (localLayout[y][x] === 1 && hasExactlyTwoOrthWalls(localLayout, x, y)) {
            const sides = [[1,0],[-1,0],[0,1],[0,-1]];
            let visitedSide = false, unvisitedSide = false;
            for (const [dx, dy] of sides) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < w && ny < h) {
                if (localLayout[ny][nx] === 0 || localLayout[ny][nx] === 2) {
                  if (visited.has(`${nx},${ny}`)) visitedSide = true;
                  else unvisitedSide = true;
                }
              }
            }
            if (visitedSide && unvisitedSide) { localLayout[y][x] = 2; return; }
          }
        }
      }
    }
    function stampBuildingOntoMap(localLayout, sx, sy) {
      const h = localLayout.length, w = localLayout[0].length;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const val = localLayout[y][x];
          if (val === 1) { mapData[sy+y][sx+x].type = TILE_TYPES.WALL; }
          else if (val === 0) { mapData[sy+y][sx+x].type = TILE_TYPES.FLOOR; }
          else if (val === 2) { mapData[sy+y][sx+x].type = TILE_TYPES.DOOR; }
        }
      }
    }

    /*******************************************************
     * DRAWING FUNCTIONS
     *******************************************************/
    function drawMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < CONFIG.gridHeight; y++) {
        for (let x = 0; x < CONFIG.gridWidth; x++) {
          drawTile(x, y);
        }
      }
    }
    function drawTile(x, y) {
      const tile = mapData[y][x];
      const px = x * CONFIG.tileSize, py = y * CONFIG.tileSize;
      const key = getKeyByValue(TILE_TYPES, tile.type);
      const tex = tileTextures[key];
      if (tex && tex.complete) { ctx.drawImage(tex, px, py, CONFIG.tileSize, CONFIG.tileSize); }
      else { ctx.fillStyle = getColorForTileType(tile.type); ctx.fillRect(px, py, CONFIG.tileSize, CONFIG.tileSize); }
      if (tile.occupant) {
        ctx.fillStyle = tile.occupant.color;
        const radius = CONFIG.tileSize * 0.3;
        ctx.beginPath();
        ctx.arc(px + CONFIG.tileSize/2, py + CONFIG.tileSize/2, radius, 0, 2 * Math.PI);
        ctx.fill();
      }
      ctx.strokeStyle = "rgba(0,0,0,0.3)";
      ctx.strokeRect(px, py, CONFIG.tileSize, CONFIG.tileSize);
    }

    /*******************************************************
     * EVENT HANDLING FOR OCCUPANT PLACEMENT
     *******************************************************/
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const tileX = Math.floor((e.clientX - rect.left) / CONFIG.tileSize);
      const tileY = Math.floor((e.clientY - rect.top) / CONFIG.tileSize);
      if (tileX < 0 || tileY < 0 || tileX >= CONFIG.gridWidth || tileY >= CONFIG.gridHeight) return;
      const tile = mapData[tileY][tileX];
      if (!occupantInHand) {
        if (!tile.occupant) {
          const occupantType = document.getElementById("occupantType").value;
          let occupantColor = "#FFFFFF";
          if (occupantType === "player") occupantColor = "#00FF00";
          else if (occupantType === "enemy") occupantColor = "#FF0000";
          else if (occupantType === "npc") occupantColor = "#0000FF";
          tile.occupant = { type: occupantType, color: occupantColor };
        } else {
          occupantInHand = tile.occupant;
          tile.occupant = null;
        }
      } else {
        tile.occupant = occupantInHand;
        occupantInHand = null;
      }
      drawTile(tileX, tileY);
    });

    /*******************************************************
     * MAIN INITIALISATION FUNCTION
     *******************************************************/
    async function init() {
      try { await preloadTextures(); }
      catch (err) { console.error("Error preloading textures:", err); }
      
      const theme = document.getElementById("mapType").value;
      const style = document.getElementById("mapStyle").value;
      const settings = getMapSettings(theme);
      
      if (settings.isCavern) { generateCavern(); }
      else {
        initMap(settings.baseDist);
        for (let i = 0; i < settings.waterBodies; i++) { createWaterBody(settings.waterMaxSize); }
        for (let r = 0; r < settings.roads; r++) { createRoad(settings.roadMaxLength, 2, 3); }
      }
      if (!settings.isCavern && style === "village" && settings.buildings > 0) {
        createBuildings(settings.buildings);
      }
      drawMap();
    }

    /*******************************************************
     * INITIALISATION & EVENT BINDING
     *******************************************************/
    document.querySelector(".mapButton").addEventListener("click", () => { init(); });
    window.addEventListener("load", () => {
      init();
      // Additional redraw via requestAnimationFrame after 1 second (belt-and-braces)
      setTimeout(() => { requestAnimationFrame(drawMap); }, 1000);
    });
  </script>
</body>
</html>
