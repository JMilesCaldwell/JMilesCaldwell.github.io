<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Procedural Battle Map Generator</title>
  <link 
    href="https://fonts.googleapis.com/css2?family=Almendra&family=Cinzel:wght@400;700&display=swap"
    rel="stylesheet"
  >
  <style>
    body {
      margin: 0;
      background: url('resources/mapgen.png') no-repeat center center fixed;
      background-size: cover;
      color: #FAF4E0;
      font-family: 'Almendra', serif;
      text-align: center;
      overscroll-behavior: none;
    }
    .container {
      margin: 2rem auto;
      background: rgba(0, 0, 0, 0.7);
      padding: 2rem;
      border-radius: 10px;
      max-width: 95vw;
    }
    h1, h2 {
      font-family: 'Cinzel', serif;
      margin: 0.5rem 0;
    }
    .description {
      font-size: 1.2rem;
      margin-top: 1rem;
    }
    .mapWrapper {
      width: 90vw;
      max-width: 1000px;
      height: 60vh;
      max-height: 700px;
      margin: 1rem auto;
      overflow: hidden;
      position: relative;
      display: block;
      border: 2px solid #660000;
      background: #202020;
    }
    #mapCanvas {
      width: 1000px;
      height: 1000px;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: top left;
      image-rendering: pixelated;
      touch-action: none;
    }
    .mapButton {
      display: inline-block;
      margin: 0.5rem;
      padding: 0.6rem 1rem;
      font-family: 'Cinzel', serif;
      background: #8B0000;
      color: #FAF4E0;
      border: 1px solid #660000;
      border-radius: 4px;
      cursor: pointer;
      text-decoration: none;
    }
    .mapButton:hover {
      background: #660000;
    }
    .controls {
      margin: 1rem auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .controls label {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      user-select: none;
    }
    /* Additional styling for sliders */
    .sliderContainer {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin: 0 10px;
    }
    .sliderContainer label {
      margin: 3px 0;
    }
    .sliderContainer input[type='range'] {
      width: 150px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Procedural Battle Map Generator</h1>
    <p class="description">
      "Generate maps, place sprites, roll dice..."
    </p>
    <div class="controls">
      <label>
        Map Biome:
        <select id="mapType" onchange="setupSliders()">
          <option value="desert">Desert</option>
          <option value="city">City</option>
          <option value="grassland" selected>Grassland</option>
          <option value="mountain">Mountain</option>
          <option value="forest">Forest</option>
          <option value="cavern">Cavern</option>
          <option value="volcanic">Volcanic</option>
          <option value="coastal">Coastal</option>
          <option value="riverlands">Riverlands</option>
          <option value="swamp">Swamp</option>
          <option value="jungle">Jungle</option>
          <option value="snow">Snow</option>
        </select>
      </label>
      <label>
        <input type="checkbox" id="buildingsCheck" />
        Generate Buildings
      </label>
      <label>
        <input type="checkbox" id="generateFields" />
        Generate Fields
      </label>
      <label>
        <input type="checkbox" id="cityWalls" />
        Add City Walls
      </label>
      <label>
        <input type="checkbox" id="waterCheck" />
        Generate Water
      </label>
      <label>
        <input type="checkbox" id="roadCheck" />
        Generate Roads
      </label>
      <button class="mapButton" onclick="generateMap()">Generate Map</button>
      <!-- A container that will hold our dynamic sliders -->
      <div id="sliderControls" class="controls" style="flex-wrap: wrap; border: 1px solid #660000; border-radius: 4px; padding: 1rem;">
        <!-- Sliders appear here via setupSliders() -->
      </div>
      <br>
      <label>
        Occupant Type:
        <select id="occupantType">
          <option value="none" selected>None</option>
          <option value="player">Player</option>
          <option value="enemy">Enemy</option>
          <option value="npc">NPC</option>
        </select>
      </label>
      <label>
        Sprite:
        <select id="occupantSprite">
          <option value="none" selected>None</option>
          <option value="paladin">paladin</option>
          <option value="fighter">fighter</option>
          <option value="guardian">guardian</option>
          <option value="halfblood">halfblood</option>
          <option value="berserker">berserker</option>
          <option value="assassin">assassin</option>
          <option value="warlock">warlock</option>
          <option value="sorcerer">sorcerer</option>
          <option value="priestess">priestess</option>
          <option value="cleric">cleric</option>
          <option value="druid">druid</option>
          <option value="demon">demon</option>
          <option value="mage">mage</option>
          <option value="serpent">serpent</option>
          <option value="chimera">chimera</option>
          <option value="ogre">ogre</option>
          <option value="edgelord">edgelord</option>
          <option value="fallenangel">fallenangel</option>
          <option value="darkpriestess">darkpriestess</option>
          <option value="darkguard">darkguard</option>
          <option value="cultist">cultist</option>
          <option value="goblin">goblin</option>
          <option value="spider">spider</option>
          <option value="bat">bat</option>
          <option value="zombie">zombie</option>
          <option value="orc">orc</option>
          <option value="orcbandit">orcbandit</option>
          <option value="orcchief">orcchief</option>
          <option value="orcshaman">orcshaman</option>
          <option value="orcfighter">orcfighter</option>
        </select>
      </label>
      <button class="mapButton" onclick="clearOccupantSelection()">Clear</button>
    </div>
    <div class="controls">
      <button class="mapButton" onclick="setMode('place')">Place</button>
      <button class="mapButton" onclick="setMode('delete')">Delete</button>
      <button class="mapButton" onclick="setMode('move')">Move</button>
    </div>
    <div class="mapWrapper">
      <canvas id="mapCanvas" width="1000" height="1000"></canvas>
    </div>
    <div style="margin-top: 1rem;">
      <a href="index.html" class="mapButton">Home</a>
    </div>
  <script>
    /*******************************************************
     * BASIC CONFIG & GLOBALS
     *******************************************************/
    const TILE_SIZE = 20;
    const GRID_WIDTH = 50;
    const GRID_HEIGHT = 50;

    let mapData = [];
    let occupantInHand = null;

    const occupantColours = {
      player: "#00FF00",
      enemy:  "#FF0000",
      npc:    "#0000FF"
    };

    let currentMode = 'place';

    // Pan & Zoom
    let scale = 1.0, offsetX = 0, offsetY = 0;
    const minScale = 0.3, maxScale = 3.0;
    let isDragging = false, dragStartX = 0, dragStartY = 0;
    let activePointers = new Map();
    let initialPinchDistance = 0, initialPinchScale = 1.0;

    // City walls, building occupancy
    let cityWallBounds = null;

    /*******************************************************
     * TILE TEXTURES & OCCUPANT SPRITES
     *******************************************************/
    const tileTextures = {};
    const occupantSpritesMap = {};

    const tileAssetMapping = {
      "grass": {
        folder: "grass",
        files: ["grasstile1.png","grasstile2.png","grasstile3.png","grasstile4.png","grasstile5.png"]
      },
      "tree": {
        folder: "grass",
        files: ["grasstree1.png","grasstree2.png"]
      },
      "denseforest": {
        folder: "forest",
        files: ["trees1.png","trees2.png","trees3.png","trees4.png","trees5.png"]
      },
      "junglegrass": {
        folder: "jungle",
        files: ["jungleGrass.png"]
      },
      "junglemud": {
        folder: "jungle",
        files: ["junglemud1.png","junglemud2.png","junglemud3.png"]
      },
      "jungletree": {
        folder: "jungle",
        files: ["jungletree1.png","jungletree2.png","jungletree3.png","jungletree4.png"]
      },
      "junglescatter": {
        folder: "jungle",
        files: ["jungleRoots.png","junglebush.png","junglebush2.png","junglefern.png","junglelog.png","junglelog2.png","junglevines.png"]
      },
      "snow": {
        folder: "snow",
        files: ["snow.png","powdersnow1.png","powdersnow2.png"]
      },
      "ice": {
        folder: "snow",
        files: ["ice1.png","ice2.png","blueice1.png","blueice2.png"]
      },
      "snowtree": {
        folder: "snow",
        files: ["snowTree.png"]
      },
      "dirt": {
        folder: "dirt",
        files: ["dirt1.png","dirt2.png","dirt3.png"] 
      },
      "dirtCracked": {
        folder: "dirt",
        files: ["dirtCracked.png"]
      },
      "mud": {
        folder: "dirt",
        files: ["dirtMud1.png","dirtMud2.png","dirtMud3.png"]
      },
      "floor1": {
        folder: "buildings/floors",
        files: ["floor1a.png", "floor1b.png", "floor1c.png"]
      },
      "sand": {
        folder: "desert",
        files: ["sand1.png","sand2.png","sand3.png"]
      },
      "cactus": {
        folder: "desert",
        files: ["cactus1.png","cactus2.png","cactus3.png","cactus4.png","cactus5.png","cactus6.png"]
      },
      "desertPalm": {
        folder: "desert",
        files: ["desertpalmtree1.png","desertpalmtree2.png","desertpalmtree3.png","desertpalmtree4.png","desertpalmtree5.png"]
      },
      "dune": {
        folder: "desert",
        files: ["dune1.png","duneRocks1.png","duneRocks2.png","duneRocks3.png"]
      },
      "desertBoulder": {
        folder: "desert",
        files: ["desertBoulder.png"]
      },
      "water": {
        folder: "water",
        files: ["water.png","waterrocks.png","waterrocks2.png","swamp.png","swamp2.png","whitesand.png"]
      },
      "whitesand": {
        folder: "water",
        files: ["whitesand.png"]
      },
      "roadstone": {
        folder: "buildings/floors",
        files: ["sandstonetile.png"]
      },
      "roaddirt": {
        folder: "dirt",
        files: ["roadDirt.png"]
      },
      "barrens": {
        folder: "vulcanic",
        files: ["barrens1.png","barrens2.png"]
      },
      "lavastone": {
        folder: "vulcanic",
        files: ["lavastone1.png","lavastone2.png","lavastone3.png","lavastone4.png","lavastone5.png"]
      },
      "lava": {
        folder: "vulcanic",
        files: ["lava1.png","lava2.png","lava3.png"]
      },
      "magma": {
        folder: "vulcanic",
        files: ["magma.png"]
      },
      "brimstone": {
        folder: "vulcanic",
        files: ["brimstone.png"]
      },
      "brimstone2": {
        folder: "vulcanic",
        files: ["brimstone2.png"]
      },
      "stone": {
        folder: "buildings/walls",
        files: ["stoneBlock.png"]
      },
      "wall": {
        folder: "buildings/walls",
        files: [
          "brick1.png","brick2.png","brick3.png","brick4.png","brick5.png",
          "cobble1.png","cobble2.png","cobble3.png","cobble4.png",
          "darkStoneBlock.png","darktile1.png","darktile2.png","darktile3.png","darktile4.png",
          "limestone1.png","limestone2.png","limestone3.png",
          "caveWall.png",
          "ancientTile.png"
        ]
      },
      "floor": {
        folder: "buildings/floors",
        files: [
          "PlainTileRubble1.png","PlainTileRubble2.png","PlainTileRubble3.png","floorCastle.png",
          "marble1.png","marble2.png","marble3.png","marble4.png","marbleCracked.png",
          "tilerubble4.png","tilerubble5.png","woodfloor.png"
        ]
      },
      "door": {
        folder: "buildings/doors",
        files: ["doorVault.png","doorWood1.png","doorWood2.png","gateStone.png","gateStone2.png","prisonBars.png","prisonGate.png"]
      },
      "solidstone": {
        folder: "cavern",
        files: ["caveRock.png","caveRockLarge.png"]
      },
      "cobblestone": {
        folder: "buildings/walls",
        files: ["cobble1.png","cobble2.png","cobble3.png","cobble4.png"]
      },
      "ancienttile": {
        folder: "buildings/walls",
        files: ["ancientTile.png"]
      },
      "sandstonetile": {
        folder: "buildings/floors",
        files: ["sandstonetile.png"]
      },
      "marble1": {
        folder: "buildings/floors",
        files: ["marble1.png"]
      },
      "marble2": {
        folder: "buildings/floors",
        files: ["marble2.png"]
      },
      "marble3": {
        folder: "buildings/floors",
        files: ["marble3.png"]
      },
      "marble4": {
        folder: "buildings/floors",
        files: ["marble4.png"]
      },
      "darktile": {
        folder: "buildings/walls",
        files: ["darktile1.png","darktile2.png","darktile3.png","darktile4.png"]
      },
      "farmland": {
        folder: "farmland",
        files: ["corn.png","pumpkins.png","rye.png","sunflowers.png","vinyard.png","wheat.png"]
      },
      "cave_floor": {
        folder: "cavern",
        files: [
          "cave1.png","cave2.png","caveBog.png","caveBones.png","caveCliff1.png","caveCliff2.png",
          "caveMoss1.png","caveMoss2.png","cavePool.png","cavePoolsmall.png","cavePuddle.png"
        ]
      },
      "negative": {
        folder: "",
        files: []
      },
      "scatterStoneGrass": {
        folder: "jungle",
        files: ["junglerock1.png"]
      },
      "limestone1": {
        folder: "buildings/walls",
        files: ["limestone1.png"]
      },
      "limestone2": {
        folder: "buildings/walls",
        files: ["limestone2.png"]
      },
      "limestone3": {
        folder: "buildings/walls",
        files: ["limestone3.png"]
      },
      "woodfloor": {
        folder: "buildings/floors",
        files: ["woodfloor.png"]
      },
      "marbleCracked": {
        folder: "buildings/floors",
        files: ["marbleCracked.png"]
      },
      // Additional plaza scatter:
      "marketscatter": {
        folder: "scatter",
        files: ["marketwares1.png","marketwares2.png","marketwares3.png","smalltent.png","marketstallx.png"]
      }
    };

    const fallbackColors = {
      grass:"#9AE582",
      tree: "#2f6a16",
      denseforest:"#1c3e0a",
      junglegrass:"#4a9142",
      junglemud:"#5a4d38",
      jungletree:"#335019",
      junglescatter:"#466028",
      snow:"#dee0f7",
      ice:"#88c2f0",
      snowtree:"#b1bacf",
      dirt: "#C2A15F",
      dirtCracked:"#b28a66",
      mud:"#6f4f3c",
      sand:"#DDD593",
      cactus: "#228b22",
      desertPalm: "#507f30",
      dune: "#d2c58c",
      desertBoulder:"#7f7b6c",
      water:"#2B64CF",
      whitesand:"#eeeecc",
      roadstone:"#777777",
      roaddirt:"#A37E4C",
      barrens:"#5f5347",
      lavastone:"#723d33",
      lava:"#cf3416",
      magma:"#aa2200",
      brimstone:"#ff5500",
      brimstone2:"#ee4400",
      stone:"#AAAAAA",
      wall:"#8B4513",
      floor:"#666666",
      door:"#552200",
      solidstone:"#222222",
      cobblestone:"#999999",
      ancienttile:"#897B42",
      sandstonetile:"#d0c5a5",
      marble1:"#f0f0f0",
      marble2:"#efefef",
      marble3:"#dddddd",
      marble4:"#cccccc",
      darktile:"#333333",
      farmland:"#9fc648",
      cave_floor:"#6e6e6e",
      negative:"#000000",
      scatterStoneGrass:"#655c47",
      limestone1:"#b6b699",
      limestone2:"#b3b196",
      limestone3:"#b0ae93",
      woodfloor:"#775b3e",
      marbleCracked:"#d6d6d6",
      marketscatter:"#775b3e"
    };

    function getColorForTileType(tt){
      return fallbackColors[tt] || "#FFFFFF";
    }

    function preloadImages(onComplete){
      const occupantSpriteNames = [
        "paladin","fighter","guardian","halfblood","berserker","assassin","warlock","sorcerer",
        "priestess","cleric","druid","demon","mage","serpent","chimera","ogre","edgelord",
        "fallenangel","darkpriestess","darkguard","cultist","goblin","spider","bat","zombie",
        "orc","orcbandit","orcchief","orcshaman","orcfighter"
      ];
      let totalToLoad = occupantSpriteNames.length;
      for(const k in tileAssetMapping){
        totalToLoad += tileAssetMapping[k].files.length;
      }
      let loadedCount = 0;
      const checkDone = () => {
        loadedCount++;
        if(loadedCount >= totalToLoad && onComplete){
          onComplete();
        }
      };
      for(const tkey in tileAssetMapping){
        tileTextures[tkey] = [];
        const { folder, files } = tileAssetMapping[tkey];
        if(!files.length) continue;
        for(const fname of files){
          const img = new Image();
          img.src = folder
            ? `resources/mapgen/mapassets/tiles/${folder}/${fname}`
            : `resources/mapgen/mapassets/tiles/${fname}`;
          img.onload = checkDone;
          img.onerror = checkDone;
          tileTextures[tkey].push(img);
        }
      }
      occupantSpriteNames.forEach(sp => {
        const img = new Image();
        img.src = `resources/mapgen/mapassets/sprites/${sp}.png`;
        img.onload = checkDone;
        img.onerror = checkDone;
        occupantSpritesMap[sp] = img;
      });
    }

    function weightedRandomIndex(weights) {
      const total = weights.reduce((sum, weight) => sum + weight, 0);
      let random = Math.random() * total;
      for (let i = 0; i < weights.length; i++) {
        if (random < weights[i]) {
          return i;
        }
        random -= weights[i];
      }
      return weights.length - 1; // fallback in case of rounding errors
    }

    // --- BEACH FUNCTIONS (for river/beach generation) ---
    // This function checks all water cells and converts those that border non-water cells into beach (whitesand)
    // with the given probability.
    function generateBeaches(probability) {
      let changed = false;
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (mapData[y][x].type === "water") {
            // Check the four orthogonal neighbors.
            const neighbors = [
              [x + 1, y],
              [x - 1, y],
              [x, y + 1],
              [x, y - 1]
            ];
            let isBorder = false;
            for (const [nx, ny] of neighbors) {
              if (nx >= 0 && ny >= 0 && nx < GRID_WIDTH && ny < GRID_HEIGHT) {
                // If any neighbor is not water, then this cell is on the border.
                if (mapData[ny][nx].type !== "water") {
                  isBorder = true;
                  break;
                }
              }
            }
            if (isBorder && Math.random() < probability) {
              mapData[y][x].type = "whitesand";
              changed = true;
            }
          }
        }
      }
      return changed;
    }

    // This function runs the beach-generation repeatedly (or "grows" the beach) for a given number of iterations.
    function growBeaches(probability, iterations) {
      for (let i = 0; i < iterations; i++) {
        generateBeaches(probability);
      }
    }
    // --- END BEACH FUNCTIONS ---

    /*******************************************************
     * MAP SETTINGS
     *******************************************************/
    // Original defaults, no forced caps here. We'll rely on code logic
    // to handle extreme usage (like 100 buildings in a 50x50).
    function getMapSettings(theme){
      switch(theme){
        case "desert":
          return {
            baseDist: { "sand":0.7, "dirtCracked":0.1, "dirt":0.2 },
            waterBodies:2, waterMaxSize:50, roads:2, roadMaxLength:40, buildings:5, isCavern:false
          };
        case "city":
          return {
            baseDist: { "dirt":0.05,"stone":0.2,"grass":0.15,"tree":0.1 },
            waterBodies:2, waterMaxSize:80, roads:8, roadMaxLength:80, buildings:15, isCavern:false
          };
        case "grassland":
          return {
            baseDist: { "grass":0.6, "tree":0.2, "dirt":0.1, "stone":0.05 },
            waterBodies:3, waterMaxSize:120, roads:4, roadMaxLength:60, buildings:6, isCavern:false
          };
        case "mountain":
          return {
            baseDist: { "stone":0.4,"dirt":0.3,"grass":0.1,"tree":0.05 },
            waterBodies:1, waterMaxSize:40, roads:3, roadMaxLength:50, buildings:4, isCavern:false
          };
        case "forest":
          return {
            baseDist: { "denseforest":0.25, "tree":0.3, "grass":0.3, "dirt":0.1, "stone":0.05 },
            waterBodies:2, waterMaxSize:60, roads:2, roadMaxLength:50, buildings:2, isCavern:false
          };
        case "cavern":
          return {
            baseDist:{}, waterBodies:0, waterMaxSize:0, roads:0, roadMaxLength:0, buildings:0, isCavern:true
          };
        case "volcanic":
          return {
            baseDist:{ "barrens":0.5, "lavastone":0.3, "brimstone":0.1, "dirtCracked":0.1 },
            waterBodies:1, waterMaxSize:50, roads:1, roadMaxLength:20, buildings:2, isCavern:false
          };
        case "coastal":
          return {
            baseDist:{ "grass":0.6, "dirt":0.4 },
            waterBodies:0, waterMaxSize:0, roads:3, roadMaxLength:50, buildings:6, isCavern:false
          };
        case "riverlands":
          return {
            baseDist:{ "grass":0.5,"dirt":0.3,"tree":0.2 },
            waterBodies:0, waterMaxSize:0, roads:4, roadMaxLength:60, buildings:7, isCavern:false
          };
        case "swamp":
          return {
            baseDist:{ "dirt":0.3,"water":0.3,"grass":0.2,"tree":0.1,"mud":0.1 },
            waterBodies:2, waterMaxSize:80, roads:2, roadMaxLength:40, buildings:3, isCavern:false
          };
        case "jungle":
          return {
            baseDist:{ "junglegrass":0.4, "junglemud":0.3, "jungletree":0.15, "junglescatter":0.15 },
            waterBodies:3, waterMaxSize:60, roads:2, roadMaxLength:40, buildings:3, isCavern:false
          };
        case "snow":
          return {
            baseDist:{ "snow":0.6,"ice":0.3,"snowtree":0.1 },
            waterBodies:2, waterMaxSize:40, roads:2, roadMaxLength:40, buildings:2, isCavern:false
          };
        default:
          return {
            baseDist:{ "grass":0.6,"tree":0.2,"dirt":0.1,"stone":0.05 },
            waterBodies:2, waterMaxSize:60, roads:4, roadMaxLength:60, buildings:6, isCavern:false
          };
      }
    }

    /*******************************************************
     * SLIDER HANDLING
     *******************************************************/
    let sliderCache = {};

    function setupSliders() {
      const sliderContainer = document.getElementById("sliderControls");
      sliderContainer.innerHTML = "";

      const theme = document.getElementById("mapType").value;
      const settings = getMapSettings(theme);

      // If it's a cavern, skip
      if(settings.isCavern){
        const msg = document.createElement("div");
        msg.innerHTML = "<p>No sliders for caverns.</p>";
        sliderContainer.appendChild(msg);
        return;
      }

      // Create a slider for each baseDist entry
      const distKeys = Object.keys(settings.baseDist);
      distKeys.forEach(tileType => {
        const val = settings.baseDist[tileType];
        const div = document.createElement("div");
        div.className = "sliderContainer";

        const label = document.createElement("label");
        label.textContent = `${tileType} : ${val.toFixed(2)}`;

        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = "0";
        slider.max = "1";
        slider.step = "0.01";
        slider.value = val;

        slider.oninput = () => {
          label.textContent = `${tileType} : ${slider.value}`;
        };

        sliderCache[tileType] = slider;

        div.appendChild(label);
        div.appendChild(slider);
        sliderContainer.appendChild(div);
      });

      // Additional sliders for waterBodies, waterMaxSize, roads, roadMaxLength, buildings
      // increased maximums:
      const paramSliders = [
        { key: "waterBodies",    min: 0,  max: 20, step: 1  },
        { key: "waterMaxSize",   min: 0,  max: 500, step: 10 },
        { key: "roads",          min: 0,  max: 20, step: 1  },
        { key: "roadMaxLength",  min: 0,  max: 300, step: 5 },
        { key: "buildings",      min: 0,  max: 50, step: 1  },
      ];

      paramSliders.forEach(({key, min, max, step}) => {
        const val = settings[key] || 0;
        const div = document.createElement("div");
        div.className = "sliderContainer";

        const label = document.createElement("label");
        label.textContent = `${key} : ${val}`;

        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = min;
        slider.max = max;
        slider.step = step;
        slider.value = val;

        slider.oninput = () => {
          label.textContent = `${key} : ${slider.value}`;
        };

        sliderCache[key] = slider;

        div.appendChild(label);
        div.appendChild(slider);
        sliderContainer.appendChild(div);
      });
    }

    function applySlidersToSettings(settings){
      if(settings.isCavern) return settings;
      // baseDist
      for(const tileType in settings.baseDist){
        if(sliderCache[tileType]){
          settings.baseDist[tileType] = parseFloat(sliderCache[tileType].value);
        }
      }
      // other numeric parameters
      const paramKeys = ["waterBodies","waterMaxSize","roads","roadMaxLength","buildings"];
      paramKeys.forEach(k=>{
        if(sliderCache[k]){
          const v = parseFloat(sliderCache[k].value);
          settings[k] = isNaN(v) ? settings[k] : v;
        }
      });
      return settings;
    }

    /*******************************************************
     * MAP GENERATION
     *******************************************************/
    function generateMap(){
      occupantInHand = null;
      offsetX=0; offsetY=0; scale=1.0;
      updateCanvasTransform();

      const theme = document.getElementById("mapType").value;
      let settings = getMapSettings(theme);
      settings = applySlidersToSettings(settings);

      const doBuildings = document.getElementById("buildingsCheck").checked;
      const doFields = document.getElementById("generateFields").checked;
      const doCityWalls = document.getElementById("cityWalls").checked;
      const doWater = document.getElementById("waterCheck").checked;
      const doRoads = document.getElementById("roadCheck").checked;

      if(settings.isCavern){
        generateCavern();
      } else {
        initMap(settings.baseDist);

        if(theme==="coastal"){
          createIrregularCoastLine();
        }
        else if(theme==="riverlands" && doWater){
          createMeanderingRiver(settings.roadMaxLength, "water", 2); 
        }
        else {
          if(doWater){
            for(let i = 0; i < settings.waterBodies; i++){
              if(theme === "volcanic"){
                createLavaBody(settings.waterMaxSize);
              } else {
                createWaterBody(settings.waterMaxSize);
              }
            }
            // Only grow beaches if not volcanic (lava) theme.
            if(theme !== "volcanic") {
              growBeaches(0.4, 3);
            }
            
            if(theme==="riverlands" || (Math.random()<0.2 && settings.waterBodies>0)){
              if(theme==="volcanic"){
                createMeanderingRiver(settings.roadMaxLength, "lava");
              } else {
                createMeanderingRiver(settings.roadMaxLength, "water");
              }
              if(theme !== "volcanic") {
                growBeaches(0.4, 3);
              }
            }
          }
        }
      }

      if(doCityWalls){
        createIrregularCityWalls(); 
      }

      // REMOVE the forced max of 3 roads:
      if(doRoads && !settings.isCavern){
        for(let i=0; i<settings.roads; i++){
          createRoadFromEdgeToEdge(theme);
        }
      }

      // Building is subject to space constraints, but no forced small cap
      if(doBuildings && !settings.isCavern && settings.buildings>0){
        createBuildings(settings.buildings);
      }

      decorateBiome(theme);

      if(doFields){
        createFields(3);
      }

      if(theme==="city"){
        createCitySquares();
      }

      if(theme==="coastal"){
        scatterCoastalTrees(50);
        createCoastalDocks(2);
      }

      drawMap();
    }

    function initMap(dist){
      mapData = [];
      for(let y=0; y<GRID_HEIGHT; y++){
        const row = [];
        for(let x=0; x<GRID_WIDTH; x++){
          const rand = Math.random();
          let chosen = "grass";
          let cumul = 0;
          for(const t in dist){
            cumul += dist[t];
            if(rand < cumul){
              chosen = t; 
              break;
            }
          }
          row.push({ 
            type: chosen, 
            occupant: null,
            _chosenTileIndex: null,
            hasBuilding: false
          });
        }
        mapData.push(row);
      }
    }

    /*******************************************************
     * CAVERN
     *******************************************************/
    function generateCavern(){
      const fillChance = 0.52;
      let boolMap = randomBoolMap(fillChance);
      const steps = 3;
      for(let i=0; i<steps; i++){
        boolMap = doCAStep(boolMap);
      }
      const { largestMap } = keepLargestRegion(boolMap);
      carveWideExits(largestMap,3);
      convertBoolMapToCavern(largestMap);
    }
    function randomBoolMap(chance){
      const out = [];
      for(let y=0; y<GRID_HEIGHT; y++){
        const row=[];
        for(let x=0; x<GRID_WIDTH; x++){
          row.push(Math.random()<chance);
        }
        out.push(row);
      }
      return out;
    }
    function doCAStep(bm){
      const newM=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        const row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          const n = countFloorNeighbours(bm,x,y);
          const curr = bm[y][x];
          row.push(curr ? (n>=4) : (n>=5));
        }
        newM.push(row);
      }
      return newM;
    }
    function countFloorNeighbours(bm,x,y){
      let c=0;
      for(let dy=-1; dy<=1; dy++){
        for(let dx=-1; dx<=1; dx++){
          if(dx===0 && dy===0) continue;
          const nx=x+dx, ny=y+dy;
          if(nx>=0 && ny>=0 && nx<GRID_WIDTH && ny<GRID_HEIGHT){
            if(bm[ny][nx]) c++;
          }
        }
      }
      return c;
    }
    function keepLargestRegion(bm){
      const visited=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        visited[y]=new Array(GRID_WIDTH).fill(false);
      }
      let bestSize=0, bestRegion=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          if(bm[y][x] && !visited[y][x]){
            const queue=[[x,y]];
            visited[y][x]=true;
            const regionCells=[[x,y]];
            let size=1;
            while(queue.length){
              const [cx,cy] = queue.pop();
              for(const [nx,ny] of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]){
                if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT){
                  if(bm[ny][nx] && !visited[ny][nx]){
                    visited[ny][nx]=true;
                    queue.push([nx,ny]);
                    regionCells.push([nx,ny]);
                    size++;
                  }
                }
              }
            }
            if(size>bestSize){
              bestSize=size;
              bestRegion=regionCells;
            }
          }
        }
      }
      const largestMap = bm.map(row=>row.slice());
      const regSet = new Set(bestRegion.map(([xx,yy])=>`${xx},${yy}`));
      for(let y=0;y<GRID_HEIGHT;y++){
        for(let x=0;x<GRID_WIDTH;x++){
          if(largestMap[y][x] && !regSet.has(`${x},${y}`)){
            largestMap[y][x]=false;
          }
        }
      }
      return { largestMap, largestRegion: bestRegion };
    }
    function carveWideExits(boolMap,width){
      let needed=2;
      while(needed>0){
        carveRandomWideTunnel(boolMap,width);
        needed--;
      }
    }
    function carveRandomWideTunnel(boolMap,w){
      let tries=0, cx,cy;
      while(tries<300){
        cx=Math.floor(Math.random()*GRID_WIDTH);
        cy=Math.floor(Math.random()*GRID_HEIGHT);
        if(boolMap[cy][cx]) break;
        tries++;
      }
      const ex = (Math.random()<0.5)? 0 : (GRID_WIDTH-1);
      const ey = Math.floor(Math.random()*GRID_HEIGHT);
      carveCorridor(boolMap,cx,cy,ex,ey,w);
    }
    function carveCorridor(boolMap,x1,y1,x2,y2,w){
      let steps=0;
      while((x1!==x2||y1!==y2) && steps<9999){
        carveCircle(boolMap,x1,y1,w);
        if(x1<x2)x1++; else if(x1>x2)x1--;
        if(y1<y2)y1++; else if(y1>y2)y1--;
        steps++;
      }
      carveCircle(boolMap,x1,y1,w);
    }
    function carveCircle(boolMap,cx,cy,r){
      for(let dy=-r;dy<=r;dy++){
        for(let dx=-r;dx<=r;dx++){
          if(dx*dx+dy*dy<=r*r){
            const nx=cx+dx, ny=cy+dy;
            if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT){
              boolMap[ny][nx]=true;
            }
          }
        }
      }
    }
    function convertBoolMapToCavern(bm){
      mapData=[];
      for(let y=0;y<GRID_HEIGHT;y++){
        const row=[];
        for(let x=0;x<GRID_WIDTH;x++){
          if(bm[y][x]){
            row.push({ type:"cave_floor", occupant:null, _chosenTileIndex:null, hasBuilding:false });
          } else {
            row.push({ type:"negative", occupant:null, _chosenTileIndex:null, hasBuilding:false });
          }
        }
        mapData.push(row);
      }
    }

    /*******************************************************
     * WATER / LAVA
     *******************************************************/
    function createWaterBody(maxSize){
      createFluidBody(maxSize,"water");
    }
    function createLavaBody(maxSize){
      createFluidBody(maxSize,"lava");
    }
    function createFluidBody(maxSize,tileType){
      const sx=Math.floor(Math.random()*GRID_WIDTH);
      const sy=Math.floor(Math.random()*GRID_HEIGHT);
      floodFillFluid(sx, sy, maxSize, tileType);
    }
    function floodFillFluid(sx,sy,maxSize,tileType){
      const stack=[[sx,sy]];
      let size=0;
      while(stack.length && size<maxSize){
        const [cx,cy] = stack.pop();
        if(cx<0||cy<0||cx>=GRID_WIDTH||cy>=GRID_HEIGHT) continue;
        if(mapData[cy][cx].type===tileType) continue;
        if(Math.random()<0.1) continue;
        mapData[cy][cx].type=tileType;
        size++;
        stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
      }
    }

    /*******************************************************
     * RIVERS
     *******************************************************/
    function createMeanderingRiver(maxLength, fluid="water", r=1){
      const edges=["top","bottom","left","right"];
      const chosen=edges[Math.floor(Math.random()*edges.length)];
      let x=0, y=0;
      if(chosen==="top"){
        x=Math.floor(Math.random()*GRID_WIDTH); y=0;
      } else if(chosen==="bottom"){
        x=Math.floor(Math.random()*GRID_WIDTH); y=GRID_HEIGHT-1;
      } else if(chosen==="left"){
        x=0; y=Math.floor(Math.random()*GRID_HEIGHT);
      } else {
        x=GRID_WIDTH-1; y=Math.floor(Math.random()*GRID_HEIGHT);
      }
      let dir=pickRiverDir(chosen);
      const steps=Math.floor(Math.random()*(maxLength/2)+maxLength/2);
      for(let i=0; i<steps; i++){
        if(x<0||y<0||x>=GRID_WIDTH||y>=GRID_HEIGHT) break;
        carveRiverCircle(x,y,r,fluid);
        if(Math.random()<0.2) dir=turnSlightly(dir);
        x+=dir.dx; y+=dir.dy;
      }
    }
    function carveRiverCircle(cx, cy, radius, fluid){
      for(let dy=-radius; dy<=radius; dy++){
        for(let dx=-radius; dx<=radius; dx++){
          if(dx*dx+dy*dy <= radius*radius){
            const nx=cx+dx, ny=cy+dy;
            if(nx>=0&&ny>=0&&nx<GRID_WIDTH&&ny<GRID_HEIGHT){
              mapData[ny][nx].type = fluid;
            }
          }
        }
      }
    }
    function pickRiverDir(edge){
      switch(edge){
        case "top":    return {dx: (Math.random()<0.5?1:-1), dy:1};
        case "bottom": return {dx: (Math.random()<0.5?1:-1), dy:-1};
        case "left":   return {dx:1, dy: (Math.random()<0.5?1:-1)};
        case "right":  return {dx:-1,dy: (Math.random()<0.5?1:-1)};
        default:       return {dx:0,dy:1};
      }
    }
    function turnSlightly(dir){
      const leftTurn = {
        "1,0":  {dx:0,dy:-1},
        "-1,0": {dx:0,dy:1},
        "0,1":  {dx:-1,dy:0},
        "0,-1": {dx:1,dy:0}
      };
      const rightTurn = {
        "1,0":  {dx:0,dy:1},
        "-1,0": {dx:0,dy:-1},
        "0,1":  {dx:1,dy:0},
        "0,-1": {dx:-1,dy:0}
      };
      const key = `${dir.dx},${dir.dy}`;
      if(Math.random()<0.5 && leftTurn[key]) return leftTurn[key];
      if(rightTurn[key]) return rightTurn[key];
      return dir;
    }

    /*******************************************************
     * IRREGULAR COAST
     *******************************************************/
    function createIrregularCoastLine(){
      const topCoast = Math.random()<0.5;
      let coastY = topCoast
        ? 2 + Math.floor(Math.random()*5)
        : GRID_HEIGHT - 2 - Math.floor(Math.random()*5);
      for(let x=0; x<GRID_WIDTH; x++){
        if(topCoast){
          for(let y=0; y<coastY; y++){
            mapData[y][x].type="water";
          }
          for(let y=coastY; y<coastY+2; y++){
            if(y>=0 && y<GRID_HEIGHT){
              mapData[y][x].type="whitesand";
            }
          }
        } else {
          for(let y=GRID_HEIGHT-1; y>coastY; y--){
            mapData[y][x].type="water";
          }
          for(let y=coastY; y>coastY-2; y--){
            if(y>=0 && y<GRID_HEIGHT){
              mapData[y][x].type="whitesand";
            }
          }
        }
        const direction = (Math.random()<0.5? -1: 1);
        coastY += direction;
        if(topCoast){
          if(coastY<2) coastY=2;
          if(coastY>GRID_HEIGHT-3) coastY=GRID_HEIGHT-3;
        } else {
          if(coastY>GRID_HEIGHT-2) coastY=GRID_HEIGHT-2;
          if(coastY<2) coastY=2;
        }
      }
    }

    /*******************************************************
     * ROADS (no forced capping now)
     *******************************************************/
    function createRoadFromEdgeToEdge(theme){
      const edgeList = ["top","bottom","left","right"];
      let startEdge = edgeList[Math.floor(Math.random()*edgeList.length)];
      let endEdge = edgeList[Math.floor(Math.random()*edgeList.length)];
      let tries=0;
      while(endEdge===startEdge && tries<10){
        endEdge = edgeList[Math.floor(Math.random()*edgeList.length)];
        tries++;
      }
      let sx, sy, ex, ey;
      switch(startEdge){
        case "top":    sx=Math.floor(Math.random()*GRID_WIDTH); sy=0; break;
        case "bottom": sx=Math.floor(Math.random()*GRID_WIDTH); sy=GRID_HEIGHT-1; break;
        case "left":   sx=0; sy=Math.floor(Math.random()*GRID_HEIGHT); break;
        case "right":  sx=GRID_WIDTH-1; sy=Math.floor(Math.random()*GRID_HEIGHT); break;
      }
      switch(endEdge){
        case "top":    ex=Math.floor(Math.random()*GRID_WIDTH); ey=0; break;
        case "bottom": ex=Math.floor(Math.random()*GRID_WIDTH); ey=GRID_HEIGHT-1; break;
        case "left":   ex=0; ey=Math.floor(Math.random()*GRID_HEIGHT); break;
        case "right":  ex=GRID_WIDTH-1; ey=Math.floor(Math.random()*GRID_HEIGHT); break;
      }
      carveStraightRoad(theme, sx, sy, ex, ey);
    }

    function carveStraightRoad(theme, sx, sy, ex, ey){
      let dx=Math.abs(ex-sx), sxSign=sx<ex?1:-1;
      let dy=-Math.abs(ey-sy), sySign=sy<ey?1:-1;
      let err=dx+dy;
      let x=sx, y=sy;
      while(true){
        carveRoadTile(theme, x, y);
        if(x===ex && y===ey) break;
        const e2=2*err;
        if(e2>=dy){err+=dy; x+=sxSign;}
        if(e2<=dx){err+=dx; y+=sySign;}
      }
    }

    function carveRoadTile(theme, rx, ry){
      for(let dy=-1; dy<=1; dy++){
        for(let dx=-1; dx<=1; dx++){
          if(Math.abs(dx)+Math.abs(dy)<=1){
            const nx=rx+dx, ny=ry+dy;
            if(nx<0||ny<0||nx>=GRID_WIDTH||ny>=GRID_HEIGHT) continue;
            const cell=mapData[ny][nx];
            // If the tile is water/lava:
            if(cell.type==="water"||cell.type==="lava"){
              // If we are coastal, do not replace water => skip bridging
              if(theme!=="coastal"){
                cell.type="woodfloor";
              }
            }
            else {
              if(Math.random()<0.05){
                cell.type="roadstone";
              } else {
                cell.type="roaddirt";
              }
            }
          }
        }
      }
    }

    /*******************************************************
     * BUILDINGS
     *******************************************************/
    const buildingShapes=[
      { width:4,height:4, layout:[
        [1,1,1,1],
        [1,0,0,1],
        [1,0,0,1],
        [1,1,1,1]
      ]},
      { width:5,height:5, layout:[
        [1,1,1,1,1],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,1,1,1,1]
      ]},
      { width:6,height:5, layout:[
        [1,1,1,1,1,1],
        [1,0,0,0,0,1],
        [1,0,0,0,0,1],
        [1,0,0,0,0,1],
        [1,1,1,1,1,1]
      ]},
      { width:7,height:5, layout:[
        [1,1,1,1,1,1,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,1,1,1,1,1,1]
      ]},
      { width:8,height:6, layout:[
        [1,1,1,1,1,1,1,1],
        [1,0,0,1,0,0,0,1],
        [1,0,0,1,0,0,0,1],
        [1,0,0,1,1,1,0,1],
        [1,0,0,0,0,1,0,1],
        [1,1,1,1,1,1,1,1]
      ]},
      { width:9,height:7, layout:[
        [1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,1],
        [1,0,0,1,1,1,0,0,1],
        [1,0,0,1,0,1,0,0,1],
        [1,0,0,1,0,1,0,0,1],
        [1,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1]
      ]},
      { width: 5, height: 5, layout: [
          [1, 1, 1, 1, 1],
          [1, 0, 0, 0, 1],
          [1, 0, 3, 0, 1],
          [1, 0, 0, 0, 1],
          [1, 1, 1, 1, 1]
      ]},
      { width: 5, height: 5, layout: [
          [3, 3, 1, 1, 1],
          [3, 1, 0, 0, 1],
          [1, 1, 0, 0, 1],
          [1, 0, 0, 0, 1],
          [1, 1, 1, 1, 1]
      ]},
      { width: 7, height: 5, layout: [
          [1, 1, 1, 1, 1, 1, 1],
          [1, 3, 3, 3, 3, 3, 1],
          [1, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1]
      ]},
      { width: 7, height: 7, layout: [
          [3, 3, 1, 1, 1, 3, 3],
          [3, 3, 1, 0, 1, 3, 3],
          [1, 1, 1, 0, 1, 1, 1],
          [0, 0, 0, 0, 0, 0, 0],
          [3, 3, 1, 0, 1, 3, 3],
          [3, 3, 1, 0, 1, 3, 3],
          [1, 1, 1, 1, 1, 1, 1]
      ]},
      { width: 7, height: 7, layout: [
          [3, 3, 1, 3, 1, 3, 3],
          [3, 3, 1, 3, 1, 3, 3],
          [1, 1, 1, 0, 1, 1, 1],
          [3, 3, 0, 0, 0, 3, 3],
          [1, 1, 1, 0, 1, 1, 1],
          [3, 3, 1, 3, 1, 3, 3],
          [3, 3, 1, 3, 1, 3, 3]
      ]},
      { width: 6, height: 6, layout: [
          [1, 1, 1, 1, 1, 1],
          [1, 0, 3, 0, 0, 1],
          [1, 0, 1, 1, 0, 1],
          [1, 0, 3, 1, 0, 1],
          [1, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1]
      ]},
      { width: 8, height: 6, layout: [
          [3, 1, 1, 1, 1, 1, 1, 3],
          [1, 0, 0, 3, 0, 0, 1, 1],
          [1, 0, 1, 1, 1, 0, 0, 1],
          [1, 0, 1, 3, 1, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 1, 1],
          [3, 1, 1, 1, 1, 1, 1, 3]
      ]},
      { width: 9, height: 5, layout: [
          [1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 3, 0, 3, 0, 3, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 3, 0, 3, 0, 3, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1]
      ]},
      { width: 10, height: 10, layout: [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
          [1, 0, 3, 1, 0, 0, 1, 3, 0, 1],
          [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
          [1, 1, 1, 1, 3, 3, 1, 1, 1, 1],
          [1, 0, 0, 1, 3, 3, 1, 0, 0, 1],
          [1, 0, 3, 1, 0, 0, 1, 3, 0, 1],
          [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
          [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      ]},
      { width: 8, height: 8, layout: [
          [1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 3, 0, 0, 3, 0, 1],
          [1, 0, 3, 0, 0, 3, 0, 1],
          [1, 1, 1, 3, 1, 1, 1, 1],
          [1, 0, 3, 0, 0, 3, 0, 1],
          [1, 0, 3, 0, 0, 3, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1]
      ]}
    };

    let chosenFloorTile = null;

    function createBuildings(numBuildings){
      const possibleFloors = ["floor1"];
      chosenFloorTile = possibleFloors[Math.floor(Math.random()*possibleFloors.length)];
      
      // Loosen the attempts logic so higher slider values get a better chance:
      // We'll go up to some bigger ceiling, e.g. 10,000 attempts max.
      let attempts = 0, placed = 0;
      const maxAttempts = 10000; 
      while(placed < numBuildings && attempts < maxAttempts){
        attempts++;
        const shape = buildingShapes[Math.floor(Math.random()*buildingShapes.length)];
        const sx = Math.floor(Math.random()*(GRID_WIDTH - shape.width));
        const sy = Math.floor(Math.random()*(GRID_HEIGHT - shape.height));
        if(canPlaceBuilding(sx,sy,shape)){
          placeBuilding(sx,sy,shape);
          placed++;
        }
      }
    }

    function canPlaceBuilding(sx,sy,shape){
      if(cityWallBounds) {
        const bx2 = sx + shape.width - 1;
        const by2 = sy + shape.height - 1;
        const cwX2 = cityWallBounds.x + cityWallBounds.w - 1;
        const cwY2 = cityWallBounds.y + cityWallBounds.h - 1;
        if(sx < cityWallBounds.x || sy < cityWallBounds.y ||
           bx2 > cwX2          || by2 > cwY2 ) {
          return false;
        }
      }
      for(let y = 0; y < shape.height; y++){
        for(let x = 0; x < shape.width; x++){
          const val = shape.layout[y][x];
          if(val === 1 || val === 0){
            const cell = mapData[sy+y][sx+x];
            if(["water","lava","roadstone","roaddirt","solidstone","magma","woodfloor"].includes(cell.type)){
              return false;
            }
            if(cell.type === "wall" || cell.type === "door" || cell.type === "negative" || cell.hasBuilding){
              return false;
            }
          }
        }
      }
      return true;
    }

    function placeBuilding(sx,sy,shape){
      const localLayout = shape.layout.map(r => r.slice());
      subdivideBuilding(localLayout);
      placeExteriorDoor(localLayout);
      ensureAccessibility(localLayout);
      stampBuilding(localLayout,sx,sy);
    }
    function subdivideBuilding(lay){
      const h = lay.length, w = lay[0].length;
      if(w >= 7){
        const wx = Math.floor(w/2);
        for(let y = 1; y < h-1; y++){
          lay[y][wx] = 1;
        }
        const doorY = Math.floor(Math.random()*(h-2)) + 1;
        lay[doorY][wx] = 2;
      }
      if(h >= 7){
        const wy = Math.floor(h/2);
        for(let x = 1; x < w-1; x++){
          lay[wy][x] = 1;
        }
        const doorX = Math.floor(Math.random()*(w-2)) + 1;
        lay[wy][doorX] = 2;
      }
    }
    function placeExteriorDoor(lay){
      const h = lay.length, w = lay[0].length;
      const cands = [];
      for(let x = 1; x < w-1; x++){
        if(isWallish(lay[0][x]) && hasExactlyTwoOrthWalls(lay, x, 0)) cands.push({px:x, py:0});
        if(isWallish(lay[h-1][x]) && hasExactlyTwoOrthWalls(lay, x, h-1)) cands.push({px:x, py:h-1});
      }
      for(let y = 1; y < h-1; y++){
        if(isWallish(lay[y][0]) && hasExactlyTwoOrthWalls(lay, 0, y)) cands.push({px:0, py:y});
        if(isWallish(lay[y][w-1]) && hasExactlyTwoOrthWalls(lay, w-1, y)) cands.push({px:w-1, py:y});
      }
      if(cands.length){
        let howMany = 1 + Math.floor(Math.random()*2);
        for(let i = 0; i < howMany && cands.length; i++){
          const idx = Math.floor(Math.random()*cands.length);
          const chosen = cands[idx];
          lay[chosen.py][chosen.px] = 2;
          cands.splice(idx,1);
        }
      }
    }
    function isWallish(v){ return v === 1 || v === 2; }
    function hasExactlyTwoOrthWalls(lay, x, y){
      const up = (y > 0) && isWallish(lay[y-1][x]);
      const down = (y < lay.length-1) && isWallish(lay[y+1][x]);
      const left = (x > 0) && isWallish(lay[y][x-1]);
      const right = (x < lay[0].length-1) && isWallish(lay[y][x+1]);
      const c = (up ? 1 : 0) + (down ? 1 : 0) + (left ? 1 : 0) + (right ? 1 : 0);
      return (c === 2) && ((up && down) || (left && right));
    }
    function ensureAccessibility(lay){
      const floors = collectFloor(lay);
      if(!floors.length) return;
      const doors = collectDoorCoords(lay);
      if(!doors.length) return;
      const mainDoor = doors.find(d => onPerimeter(lay, d.x, d.y)) || doors[0];
      if(!mainDoor) return;

      const visited = new Set();
      const queue = [{x: mainDoor.x, y: mainDoor.y}];
      visited.add(`${mainDoor.x},${mainDoor.y}`);

      while(queue.length){
        const {x, y} = queue.shift();
        for(const [nx, ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
          if(nx < 0 || ny < 0 || nx >= lay[0].length || ny >= lay.length) continue;
          const v = lay[ny][nx];
          if(v === 0 || v === 2){
            const key = `${nx},${ny}`;
            if(!visited.has(key)){
              visited.add(key);
              queue.push({x: nx, y: ny});
            }
          }
        }
      }
      const allVisited = floors.every(c => visited.has(`${c.x},${c.y}`));
      if(!allVisited){
        forceInteriorDoor(lay, visited);
      }
    }
    function collectFloor(lay){
      const out = [];
      for(let y = 0; y < lay.length; y++){
        for(let x = 0; x < lay[0].length; x++){
          const v = lay[y][x];
          if(v === 0 || v === 2) out.push({x, y});
        }
      }
      return out;
    }
    function collectDoorCoords(lay){
      const out = [];
      for(let y = 0; y < lay.length; y++){
        for(let x = 0; x < lay[0].length; x++){
          if(lay[y][x] === 2) out.push({x, y});
        }
      }
      return out;
    }
    function onPerimeter(lay, x, y){
      return (x === 0 || y === 0 || x === lay[0].length-1 || y === lay.length-1);
    }
    function forceInteriorDoor(lay, visited){
      const h = lay.length, w = lay[0].length;
      for(let y = 1; y < h-1; y++){
        for(let x = 1; x < w-1; x++){
          if(lay[y][x] === 1 && hasExactlyTwoOrthWalls(lay, x, y)){
            const sides = [[1,0],[-1,0],[0,1],[0,-1]];
            let visitedSide = false, unvisitedSide = false;
            for(const s of sides){
              const nx = x + s[0], ny = y + s[1];
              if(nx >= 0 && ny >= 0 && nx < w && ny < h){
                const val = lay[ny][nx];
                if(val === 0 || val === 2){
                  if(visited.has(`${nx},${ny}`)) visitedSide = true;
                  else unvisitedSide = true;
                }
              }
            }
            if(visitedSide && unvisitedSide){
              lay[y][x] = 2;
              return;
            }
          }
        }
      }
    }
    function stampBuilding(lay, sx, sy){
      const chosenWallType = "cobblestone"; 
      for(let y = 0; y < lay.length; y++){
        for(let x = 0; x < lay[0].length; x++){
          const val = lay[y][x];
          const cell = mapData[sy + y][sx + x];
          if(val === 1){
            cell.type = chosenWallType;
            cell.hasBuilding = true;
          } else if(val === 0){
            cell.type = chosenFloorTile;
            cell.hasBuilding = true;
          } else if(val === 2){
            cell.type = "door";
            cell.hasBuilding = true;
          }
        }
      }
    }

    /*******************************************************
     * CITY SQUARES + MARKET SCATTER
     *******************************************************/
    function createCitySquares(){
      const squareCount = 2 + Math.floor(Math.random()*3);
      let attempts = 0, placed = 0;
      while(placed < squareCount && attempts < squareCount*20){
        attempts++;
        const w = 4 + Math.floor(Math.random()*3);
        const h = 4 + Math.floor(Math.random()*3);
        const sx = Math.floor(Math.random()*(GRID_WIDTH - w));
        const sy = Math.floor(Math.random()*(GRID_HEIGHT - h));
        if(!canPlacePlaza(sx,sy,w,h)) continue;
        stampPlaza(sx,sy,w,h);
        placed++;
      }
    }
    function canPlacePlaza(sx,sy,w,h){
      for(let y = sy; y < sy+h; y++){
        for(let x = sx; x < sx+w; x++){
          const t = mapData[y][x];
          if(t.hasBuilding || t.type === "wall" || t.type === "door" || t.type === "negative"){
            return false;
          }
        }
      }
      return true;
    }
    function stampPlaza(sx,sy,w,h){
      for(let yy = sy; yy < sy+h; yy++){
        for(let xx = sx; xx < sx+w; xx++){
          const cell = mapData[yy][xx];
          if(cell.hasBuilding || cell.type === "wall" || cell.type === "door" || cell.type === "negative") continue;
          // Base: roaddirt or a random limestone
          if(Math.random() < 0.2){
            const limestones = ["limestone1","limestone2","limestone3"];
            cell.type = limestones[Math.floor(Math.random()*limestones.length)];
          } else {
            cell.type = "roaddirt";
          }
          // 10% chance to place market scatter
          if(Math.random() < 0.1){
            cell.type = "marketscatter";
          }
        }
      }
    }

    /*******************************************************
     * FIELDS
     *******************************************************/
    function createFields(numFields){
      for(let i = 0; i < numFields; i++){
        const fw = 3 + Math.floor(Math.random()*5);
        const fh = 3 + Math.floor(Math.random()*5);
        const sx = Math.floor(Math.random()*(GRID_WIDTH - fw));
        const sy = Math.floor(Math.random()*(GRID_HEIGHT - fh));
        const farmlandCount = tileAssetMapping["farmland"].files.length;
        const cropIndex = Math.floor(Math.random()*farmlandCount);
        for(let yy = sy; yy < sy+fh; yy++){
          for(let xx = sx; xx < sx+fw; xx++){
            const c = mapData[yy][xx];
            c.type = "farmland";
            c.crop = cropIndex;
          }
        }
      }
    }

    /*******************************************************
     * CITY WALLS
     *******************************************************/
    function createIrregularCityWalls(){
      const darkStoneWallFiles = [
        "darkStoneBlock.png",
        "darktile1.png","darktile2.png","darktile3.png","darktile4.png"
      ];
      const chosenWallFile = darkStoneWallFiles[Math.floor(Math.random()*darkStoneWallFiles.length)];
      const rectW = Math.floor(GRID_WIDTH/2);
      const rectH = Math.floor(GRID_HEIGHT/2);
      const startX = 2 + Math.floor(Math.random()*(GRID_WIDTH - rectW -4));
      const startY = 2 + Math.floor(Math.random()*(GRID_HEIGHT - rectH -4));
      const thickness = 2 + Math.floor(Math.random()*2);
      cityWallBounds = {
        x: startX + thickness,
        y: startY + thickness,
        w: rectW - thickness*2,
        h: rectH - thickness*2
      };
      carveWallEdge(chosenWallFile, startX, startY, startX+rectW, startY, thickness, true);
      carveWallEdge(chosenWallFile, startX+rectW, startY, startX+rectW, startY+rectH, thickness, false);
      carveWallEdge(chosenWallFile, startX+rectW, startY+rectH, startX, startY+rectH, thickness, true);
      carveWallEdge(chosenWallFile, startX, startY+rectH, startX, startY, thickness, false);
    }
    function carveWallEdge(chosenWallFile, x1, y1, x2, y2, thickness, horizontal){
      const dx = (x2 === x1) ? 0 : (x2 > x1 ? 1 : -1);
      const dy = (y2 === y1) ? 0 : (y2 > y1 ? 1 : -1);
      let cx = x1, cy = y1;
      while(cx !== x2 || cy !== y2){
        const offset = (Math.random() < 0.2) ? (Math.random() < 0.5 ? 1 : -1) : 0;
        carveWallBand(cx, cy, thickness, horizontal, offset, chosenWallFile);
        cx += dx;
        cy += dy;
      }
      carveWallBand(cx, cy, thickness, horizontal, 0, chosenWallFile); 
    }
    function carveWallBand(baseX, baseY, thickness, horizontal, offset, chosenFile){
      for(let i = 0; i < thickness; i++){
        const xx = baseX + (horizontal ? 0 : i+offset);
        const yy = baseY + (horizontal ? i+offset : 0);
        if(xx < 0 || yy < 0 || xx >= GRID_WIDTH || yy >= GRID_HEIGHT) continue;
        const cell = mapData[yy][xx];
        if(cell.type === "roadstone" || cell.type === "roaddirt" || cell.type === "woodfloor"){
          continue; 
        }
        cell.type = "wall";
        cell.chosenWallFile = chosenFile;
      }
    }

    /*******************************************************
     * BIOME DECORATION
     *******************************************************/
    function decorateBiome(theme){
      if(theme === "desert"){
        decorateDesert();
      } else if(theme === "grassland" || theme === "forest" || theme === "mountain"){
        scatterGrassRocks(80); 
      }
    }
    function scatterPalmsNearWater() {
      // Iterate through every cell in the grid.
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          // Only consider desert-like cells.
          if (["sand", "dune"].includes(mapData[y][x].type)) {
            // Check the four orthogonal neighbors for water.
            const neighbors = [[x+1,y], [x-1,y], [x,y+1], [x,y-1]];
            for (let [nx, ny] of neighbors) {
              if (nx >= 0 && ny >= 0 && nx < GRID_WIDTH && ny < GRID_HEIGHT) {
                if (mapData[ny][nx].type === "water") {
                  // With a 20% chance, convert this desert cell to a palm tree.
                  if (Math.random() < 0.2) {
                    mapData[y][x].type = "desertPalm";
                  }
                  // Break after finding at least one water neighbor.
                  break;
                }
              }
            }
          }
        }
      }
    }

    // Function to create a palm oasis patch in the desert.
    function createPalmOasis() {
      // Choose a random centre for the oasis within the grid.
      const cx = Math.floor(Math.random() * GRID_WIDTH);
      const cy = Math.floor(Math.random() * GRID_HEIGHT);
      
      // Define the water circle's radius (the oasis's centre).
      const waterRadius = 2 + Math.floor(Math.random() * 3); // radius between 2 and 4
      
      // Create the water centre.
      for (let y = cy - waterRadius; y <= cy + waterRadius; y++) {
        for (let x = cx - waterRadius; x <= cx + waterRadius; x++) {
          if (x >= 0 && y >= 0 && x < GRID_WIDTH && y < GRID_HEIGHT) {
            const dx = x - cx, dy = y - cy;
            if (dx * dx + dy * dy <= waterRadius * waterRadius) {
              mapData[y][x].type = "water";
            }
          }
        }
      }
      
      // Create a sandy beach (using 'whitesand') surrounding the water.
      const beachRadius = waterRadius + 1; // one tile thicker than the water
      for (let y = cy - beachRadius; y <= cy + beachRadius; y++) {
        for (let x = cx - beachRadius; x <= cx + beachRadius; x++) {
          if (x >= 0 && y >= 0 && x < GRID_WIDTH && y < GRID_HEIGHT) {
            const dx = x - cx, dy = y - cy;
            const distSq = dx * dx + dy * dy;
            if (distSq > waterRadius * waterRadius && distSq <= beachRadius * beachRadius) {
              mapData[y][x].type = "whitesand";
            }
          }
        }
      }
      
      // Optionally, sprinkle some water rocks along the water's edge.
      for (let y = cy - waterRadius; y <= cy + waterRadius; y++) {
        for (let x = cx - waterRadius; x <= cx + waterRadius; x++){
          if (x >= 0 && y >= 0 && x < GRID_WIDTH && y < GRID_HEIGHT) {
            const dx = x - cx, dy = y - cy;
            const distSq = dx * dx + dy * dy;
            if (distSq > (waterRadius - 1) * (waterRadius - 1) && distSq <= waterRadius * waterRadius) {
              if (Math.random() < 0.3) { 
                // Leaving as "water" lets the random selection within the water asset choose a water-rock image.
                mapData[y][x].type = "water";
              }
            }
          }
        }
      }
      
      // Scatter palm trees around the oasis.
      // Define an annular region beyond the beach where palms might grow.
      const palmStart = beachRadius + 1;
      const palmEnd = beachRadius + 3;
      for (let y = cy - palmEnd; y <= cy + palmEnd; y++){
        for (let x = cx - palmEnd; x <= cx + palmEnd; x++){
          if (x >= 0 && y >= 0 && x < GRID_WIDTH && y < GRID_HEIGHT){
            const dx = x - cx, dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist >= palmStart && dist <= palmEnd) {
              // Plant a palm only if the cell is still desert-like (e.g. "sand" or "dune").
              if (["sand", "dune"].includes(mapData[y][x].type)) {
                if (Math.random() < 0.4) { // 40% chance to plant a palm here
                  mapData[y][x].type = "desertPalm";
                }
              }
            }
          }
        }
      }
    }

    // Updated desert decoration function with oasis patch inserted.
    function decorateDesert(){
      for (let i = 0; i < 250; i++){
        const x = Math.floor(Math.random() * GRID_WIDTH);
        const y = Math.floor(Math.random() * GRID_HEIGHT);
        const cell = mapData[y][x];
        if (["sand", "dirtCracked", "dirt"].includes(cell.type)){
          const r = Math.random();
          if (r < 0.08){
            cell.type = "cactus";
          } else if (r < 0.12){
            cell.type = "desertPalm";
          } else if (r < 0.16){
            cell.type = "dune";
          } else if (r < 0.2){
            cell.type = "desertBoulder";
          }
        }
      }
      
      // Optionally add an oasis patch.
      if (Math.random() < 0.3) {
        createPalmOasis();
      }
      
      // Now, scatter additional palm trees near water.
      scatterPalmsNearWater();
    }

    function scatterGrassRocks(num){
      for(let i = 0; i < num; i++){
        const gx = Math.floor(Math.random()*GRID_WIDTH);
        const gy = Math.floor(Math.random()*GRID_HEIGHT);
        const c = mapData[gy][gx];
        if(["grass","dirt","stone"].includes(c.type) && Math.random() < 0.2){
          c.type = "scatterStoneGrass";
        }
      }
    }

    /*******************************************************
     * COASTAL: TREES & DOCKS
     *******************************************************/
    function scatterCoastalTrees(count){
      let placed = 0, attempts = 0;
      while(placed < count && attempts < 1000){
        attempts++;
        const x = Math.floor(Math.random()*GRID_WIDTH);
        const y = Math.floor(Math.random()*GRID_HEIGHT);
        const cell = mapData[y][x];
        if(cell.type === "grass" && !cell.hasBuilding){
          if(Math.random() < 0.25){
            cell.type = "tree";
            placed++;
          }
        }
      }
    }
    function createCoastalDocks(numDocks){
      let attempts = 0, built = 0;
      while(built < numDocks && attempts < 1000){
        attempts++;
        const x = Math.floor(Math.random()*GRID_WIDTH);
        const y = Math.floor(Math.random()*GRID_HEIGHT);
        if(!isLandEdge(x,y)) continue;
        const dir = canFindConsecutiveWaterLine(x,y,10);
        if(!dir) continue;
        if(buildDock(x,y,dir,10)){
          built++;
        }
      }
    }
    function isLandEdge(x,y){
      const c = mapData[y][x];
      if(["water","lava","negative"].includes(c.type)) return false;
      if(c.hasBuilding) return false;
      const nbrs = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
      return nbrs.some(([nx,ny])=>{
        if(nx < 0 || ny < 0 || nx >= GRID_WIDTH || ny >= GRID_HEIGHT) return false;
        return (mapData[ny][nx].type === "water");
      });
    }
    function canFindConsecutiveWaterLine(x,y,length){
      const possibleDirs = [];
      if(y > 0 && mapData[y-1][x].type === "water") possibleDirs.push({dx:0,dy:-1});
      if(y < GRID_HEIGHT-1 && mapData[y+1][x].type === "water") possibleDirs.push({dx:0,dy:1});
      if(x > 0 && mapData[y][x-1].type === "water") possibleDirs.push({dx:-1,dy:0});
      if(x < GRID_WIDTH-1 && mapData[y][x+1].type === "water") possibleDirs.push({dx:1,dy:0});
      for(const dir of possibleDirs){
        let ccount = 0, cx = x+dir.dx, cy = y+dir.dy;
        while(ccount < length){
          if(cx < 0 || cy < 0 || cx >= GRID_WIDTH || cy >= GRID_HEIGHT) break;
          if(mapData[cy][cx].type !== "water") break;
          cx += dir.dx; cy += dir.dy;
          ccount++;
        }
        if(ccount >= length){
          if(dir.dx !== 0) return "horizontal"; 
          else return "vertical";
        }
      }
      return null;
    }
    function buildDock(x,y,orientation,len){
      let dx = 0, dy = 0, foundLine = false;
      if(orientation === "horizontal"){
        if(x > 0 && mapData[y][x-1].type === "water"){
          dx = -1; dy = 0; foundLine = true;
        } else if(x < GRID_WIDTH-1 && mapData[y][x+1].type === "water"){
          dx = 1; dy = 0; foundLine = true;
        }
      } else {
        if(y > 0 && mapData[y-1][x].type === "water"){
          dx = 0; dy = -1; foundLine = true;
        } else if(y < GRID_HEIGHT-1 && mapData[y+1][x].type === "water"){
          dx = 0; dy = 1; foundLine = true;
        }
      }
      if(!foundLine) return false;
      let sideX = 0, sideY = 0;
      if(orientation === "horizontal"){
        sideX = 0; sideY = 1;
      } else {
        sideX = 1; sideY = 0;
      }
      let cx = x, cy = y;
      for(let i = 0; i < len; i++){
        cx += dx; cy += dy;
        if(cx < 0 || cy < 0 || cx >= GRID_WIDTH || cy >= GRID_HEIGHT) return false;
        if(mapData[cy][cx].type !== "water") return false;
      }
      cx = x; cy = y;
      for(let i = 0; i < len; i++){
        cx += dx; cy += dy;
        mapData[cy][cx].type = "woodfloor";
        const sx = cx + sideX, sy = cy + sideY;
        if(sx >= 0 && sy >= 0 && sx < GRID_WIDTH && sy < GRID_HEIGHT){
          if(mapData[sy][sx].type === "water"){
            mapData[sy][sx].type = "woodfloor";
          }
        }
      }
      return true;
    }

    /*******************************************************
     * DRAWING
     *******************************************************/
    function drawMap(){
      const canvas = document.getElementById("mapCanvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let y = 0; y < GRID_HEIGHT; y++){
        for(let x = 0; x < GRID_WIDTH; x++){
          drawCell(ctx,x,y);
        }
      }
    }

    function drawCell(ctx,gx,gy){
      const cell = mapData[gy][gx];
      const px = gx * TILE_SIZE, py = gy * TILE_SIZE;
      if(cell.type === "water") {
        const arr = tileTextures["water"];
        if(arr.length > 0){
          if(cell._chosenTileIndex == null){
            // Define custom weights: for example,
            // plain water (water.png) gets a high weight,
            // waterrocks and waterrocks2 get lower weights,
            // and the remaining images get moderate weights.
            const weights = [60, 10, 10, 5, 5, 10];
            cell._chosenTileIndex = weightedRandomIndex(weights);
          }
          const chosen = arr[cell._chosenTileIndex];
          if(chosen && chosen.complete){
            ctx.drawImage(chosen, px, py, TILE_SIZE, TILE_SIZE);
          } else {
            ctx.fillStyle = getColorForTileType(cell.type);
            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
          }
        } else {
          ctx.fillStyle = getColorForTileType(cell.type);
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      } else {
        // Existing logic for other cell types
        const arr = tileTextures[cell.type] || [];
        if(arr.length > 0){
          if(cell._chosenTileIndex == null){
            cell._chosenTileIndex = Math.floor(Math.random() * arr.length);
          }
          const chosen = arr[cell._chosenTileIndex];
          if(chosen && chosen.complete){
            ctx.drawImage(chosen, px, py, TILE_SIZE, TILE_SIZE);
          } else {
            ctx.fillStyle = getColorForTileType(cell.type);
            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
          }
        } else {
          ctx.fillStyle = getColorForTileType(cell.type);
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      }
      if(cell.type === "farmland" && cell.crop !== undefined){
        const farmlandImgs = tileTextures["farmland"];
        const chosen = farmlandImgs[cell.crop];
        if(chosen && chosen.complete){
          ctx.drawImage(chosen, px, py, TILE_SIZE, TILE_SIZE);
        } else {
          ctx.fillStyle = getColorForTileType("farmland");
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      }
      else if(cell.type === "wall" && cell.chosenWallFile){
        const arr = tileTextures["wall"] || [];
        const forcedImg = arr.find(img => img.src.includes(cell.chosenWallFile));
        if(forcedImg && forcedImg.complete){
          ctx.drawImage(forcedImg, px, py, TILE_SIZE, TILE_SIZE);
        } else {
          ctx.fillStyle = getColorForTileType("wall");
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      }
      else if(cell.occupant){
        drawOccupantSprite(ctx, cell.occupant, px, py);
      }
      else {
        const arr = tileTextures[cell.type] || [];
        if(arr.length > 0){
          if(cell._chosenTileIndex == null){
            cell._chosenTileIndex = Math.floor(Math.random()*arr.length);
          }
          const chosen = arr[cell._chosenTileIndex];
          if(chosen && chosen.complete){
            ctx.drawImage(chosen, px, py, TILE_SIZE, TILE_SIZE);
          } else {
            ctx.fillStyle = getColorForTileType(cell.type);
            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
          }
        } else {
          ctx.fillStyle = getColorForTileType(cell.type);
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      }
      ctx.strokeStyle = "rgba(0,0,0,0.3)";
      ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
    }

    function drawOccupantSprite(ctx, occupant, px, py){
      if(occupant.sprite && occupant.sprite !== "none"){
        const spr = occupantSpritesMap[occupant.sprite];
        if(spr && spr.complete){
          ctx.drawImage(spr, px, py, TILE_SIZE, TILE_SIZE);
        } else {
          ctx.fillStyle = "#999";
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        }
      } else {
        ctx.fillStyle = "#999";
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
      }
      const borderColor = occupantColours[occupant.type] || "#FF00FF";
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 1;
      ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
    }

    /*******************************************************
     * MODE SELECTOR
     *******************************************************/
    function setMode(mode){
      currentMode = mode;
      if(mode !== "move"){
        occupantInHand = null;
      }
    }

    /*******************************************************
     * CANVAS EVENTS => occupant, panning, pinch
     *******************************************************/
    const canvas = document.getElementById("mapCanvas");
    const mapWrapper = document.querySelector(".mapWrapper");

    function updateCanvasTransform(){
      canvas.style.transform = `translate(${offsetX}px,${offsetY}px) scale(${scale})`;
    }

    canvas.addEventListener("click", (e) => {
      if(isDragging || activePointers.size > 1) return;
      const rect = mapWrapper.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      const wx = (mx - offsetX) / scale, wy = (my - offsetY) / scale;
      const tx = Math.floor(wx / TILE_SIZE), ty = Math.floor(wy / TILE_SIZE);
      if(tx < 0 || ty < 0 || tx >= GRID_WIDTH || ty >= GRID_HEIGHT) return;
      const occupantType = document.getElementById("occupantType").value;
      const occupantSprite = document.getElementById("occupantSprite").value;
      const tile = mapData[ty][tx];
      switch(currentMode){
        case "delete":
          if(tile.occupant){
            tile.occupant = null;
            occupantInHand = null;
            drawCell(canvas.getContext("2d"), tx, ty);
          }
          break;
        case "move":
          if(!occupantInHand){
            if(tile.occupant){
              occupantInHand = tile.occupant;
              tile.occupant = null;
              drawCell(canvas.getContext("2d"), tx, ty);
            }
          } else {
            tile.occupant = occupantInHand;
            occupantInHand = null;
            drawCell(canvas.getContext("2d"), tx, ty);
          }
          break;
        case "place":
        default:
          occupantInHand = null;
          if(occupantType === "none") return;
          tile.occupant = {type: occupantType, sprite: occupantSprite};
          drawCell(canvas.getContext("2d"), tx, ty);
          break;
      }
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = mapWrapper.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      const wx = (mx - offsetX) / scale, wy = (my - offsetY) / scale;
      const zoomSpeed = 0.1;
      let newScale = scale + (e.deltaY < 0 ? zoomSpeed : -zoomSpeed);
      newScale = Math.min(Math.max(newScale, minScale), maxScale);
      offsetX = mx - wx * newScale;
      offsetY = my - wy * newScale;
      scale = newScale;
      updateCanvasTransform();
    }, { passive: false });

    canvas.addEventListener("pointerdown", (e) => {
      activePointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
      if(activePointers.size === 1){
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
      } else if(activePointers.size === 2){
        isDragging = false;
        initialPinchDistance = getPinchDistance();
        initialPinchScale = scale;
      }
    });

    window.addEventListener("pointermove", (e) => {
      if(!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
      if(activePointers.size === 1 && isDragging){
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        dragStartX = e.clientX; 
        dragStartY = e.clientY;
        offsetX += dx; 
        offsetY += dy;
        updateCanvasTransform();
      } else if(activePointers.size === 2){
        const newDist = getPinchDistance();
        const scaleRatio = newDist / initialPinchDistance;
        let newScale = initialPinchScale * scaleRatio;
        newScale = Math.min(Math.max(newScale, minScale), maxScale);
        const rect = mapWrapper.getBoundingClientRect();
        const ps = [...activePointers.values()];
        const midX = (ps[0].x + ps[1].x) / 2 - rect.left;
        const midY = (ps[0].y + ps[1].y) / 2 - rect.top;
        const wx = (midX - offsetX) / scale, wy = (midY - offsetY) / scale;
        scale = newScale;
        offsetX = midX - wx * newScale;
        offsetY = midY - wy * newScale;
        updateCanvasTransform();
        e.preventDefault();
      }
    });
    ["pointerup","pointercancel"].forEach(evtName => {
      window.addEventListener(evtName, (e) => {
        activePointers.delete(e.pointerId);
        if(activePointers.size < 2) initialPinchDistance = 0;
        if(activePointers.size === 0) isDragging = false;
      });
    });

    function getPinchDistance(){
      if(activePointers.size !== 2) return 0;
      const arr = [...activePointers.values()];
      const dx = arr[0].x - arr[1].x;
      const dy = arr[0].y - arr[1].y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function clearOccupantSelection(){
      document.getElementById("occupantType").value = "none";
      document.getElementById("occupantSprite").value = "none";
    }

    // Initialise sliders on page load, then preload images and generate
    window.onload = () => {
      setupSliders();
      preloadImages(() => {
        generateMap();
      });
    };
  </script>
</body>
</html>
