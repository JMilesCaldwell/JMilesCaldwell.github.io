<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mandala Generator · Lab 1 · Imogen</title>
  <link rel="icon" href="resources/Imogen.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
      color: #e0e0e0;
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Navigation Bar */
    .navbar {
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(10, 10, 15, 0.95);
      padding: 1rem 2rem;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
      box-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }

    .navbar a {
      color: #a0a0a0;
      font-size: 0.95rem;
      font-weight: 500;
      text-decoration: none;
      margin: 0 1.5rem;
      padding: 0.5rem 0;
      border-bottom: 2px solid transparent;
      transition: all 0.3s ease;
      letter-spacing: 0.3px;
    }

    .navbar a:hover {
      color: #ffffff;
      border-bottom-color: #8b5cf6;
    }

    /* Main Container */
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 6rem 2rem 2rem;
      gap: 2rem;
    }

    /* Title */
    .title {
      font-size: 1.8rem;
      font-weight: 300;
      color: #8b5cf6;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
      text-shadow: 0 0 30px rgba(139, 92, 246, 0.3);
    }

    .subtitle {
      font-size: 0.9rem;
      color: #606060;
      text-align: center;
      max-width: 400px;
    }

    /* Input Section */
    .input-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      width: 100%;
      max-width: 500px;
    }

    .seed-input {
      width: 100%;
      padding: 1rem 1.5rem;
      font-size: 1.2rem;
      font-family: inherit;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: #ffffff;
      text-align: center;
      transition: all 0.3s ease;
      outline: none;
    }

    .seed-input::placeholder {
      color: #505050;
    }

    .seed-input:focus {
      border-color: #8b5cf6;
      box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
      background: rgba(255, 255, 255, 0.08);
    }

    .seed-display {
      font-size: 0.8rem;
      color: #505050;
      font-family: monospace;
      letter-spacing: 1px;
    }

    /* Canvas Container */
    .canvas-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #mandala-canvas {
      border-radius: 50%;
      box-shadow:
        0 0 60px rgba(139, 92, 246, 0.2),
        0 0 120px rgba(139, 92, 246, 0.1),
        inset 0 0 60px rgba(0, 0, 0, 0.5);
      transition: box-shadow 0.5s ease;
    }

    #mandala-canvas:hover {
      box-shadow:
        0 0 80px rgba(139, 92, 246, 0.3),
        0 0 160px rgba(139, 92, 246, 0.15),
        inset 0 0 60px rgba(0, 0, 0, 0.5);
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 0.7rem 1.5rem;
      font-size: 0.85rem;
      font-family: inherit;
      font-weight: 500;
      background: rgba(139, 92, 246, 0.2);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 8px;
      color: #c4b5fd;
      cursor: pointer;
      transition: all 0.3s ease;
      letter-spacing: 0.5px;
    }

    .btn:hover {
      background: rgba(139, 92, 246, 0.3);
      border-color: rgba(139, 92, 246, 0.5);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(139, 92, 246, 0.2);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.small {
      padding: 0.5rem 0.8rem;
      font-size: 0.75rem;
      min-width: 2.5rem;
    }

    .speed-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .speed-display {
      font-size: 0.75rem;
      color: #606060;
      min-width: 3rem;
      text-align: center;
    }

    /* Fullscreen Mode */
    .fullscreen-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 9999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .fullscreen-overlay.active {
      display: flex;
    }

    .fullscreen-overlay canvas {
      max-width: 95vmin;
      max-height: 95vmin;
      border-radius: 50%;
    }

    .fullscreen-controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      align-items: center;
      padding: 1rem 2rem;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-overlay:hover .fullscreen-controls,
    .fullscreen-controls:focus-within {
      opacity: 1;
    }

    .fullscreen-hint {
      position: fixed;
      top: 2rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: #404040;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-overlay:hover .fullscreen-hint {
      opacity: 1;
    }

    /* Info Panel */
    .info-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      max-width: 500px;
      width: 100%;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .info-item {
      text-align: center;
    }

    .info-label {
      font-size: 0.7rem;
      color: #505050;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 0.3rem;
    }

    .info-value {
      font-size: 1rem;
      color: #8b5cf6;
      font-weight: 500;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .navbar {
        flex-wrap: wrap;
        padding: 1rem;
      }

      .navbar a {
        margin: 0.5rem 1rem;
        font-size: 0.85rem;
      }

      .title {
        font-size: 1.4rem;
      }

      .container {
        padding: 5rem 1rem 1rem;
        gap: 1.5rem;
      }

      #mandala-canvas {
        max-width: 90vw;
        max-height: 90vw;
      }

      .info-panel {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>

<body>

  <!-- Navigation Bar -->
  <div class="navbar">
    <a href="../index.html">Caldwell's Repository</a>
    <a href="../apocrypha.html">Apocrypha</a>
    <a href="../imogen.html">Imogen</a>
  </div>

  <!-- Main Container -->
  <div class="container">
    <h1 class="title">Mandala Generator</h1>
    <p class="subtitle">Enter any text to generate a unique mandala. Each character shapes the pattern.</p>

    <div class="input-section">
      <input
        type="text"
        class="seed-input"
        id="seed-input"
        placeholder="Enter your seed text..."
        autocomplete="off"
        spellcheck="false"
      >
      <div class="seed-display" id="seed-display">seed: 0</div>
    </div>

    <div class="canvas-container">
      <canvas id="mandala-canvas" width="500" height="500"></canvas>
    </div>

    <div class="controls">
      <button class="btn" id="random-btn">Random Seed</button>
      <button class="btn" id="animate-btn">Animate</button>
      <div class="speed-controls">
        <button class="btn small" id="slower-btn">−</button>
        <span class="speed-display" id="speed-display">1.0x</span>
        <button class="btn small" id="faster-btn">+</button>
      </div>
      <button class="btn" id="bloom-btn">Bloom</button>
      <button class="btn" id="fullscreen-btn">Fullscreen</button>
      <button class="btn" id="save-btn">Save Image</button>
    </div>

    <div class="info-panel">
      <div class="info-item">
        <div class="info-label">Symmetry</div>
        <div class="info-value" id="info-symmetry">-</div>
      </div>
      <div class="info-item">
        <div class="info-label">Layers</div>
        <div class="info-value" id="info-layers">-</div>
      </div>
      <div class="info-item">
        <div class="info-label">Elements</div>
        <div class="info-value" id="info-elements">-</div>
      </div>
      <div class="info-item">
        <div class="info-label">Palette</div>
        <div class="info-value" id="info-palette">-</div>
      </div>
    </div>
  </div>

  <!-- Fullscreen Overlay -->
  <div class="fullscreen-overlay" id="fullscreen-overlay">
    <canvas id="fullscreen-canvas" width="800" height="800"></canvas>
    <div class="fullscreen-hint">ESC to exit · ← → to adjust speed · B to toggle bloom</div>
    <div class="fullscreen-controls">
      <button class="btn small" id="fs-slower-btn">−</button>
      <span class="speed-display" id="fs-speed-display">1.0x</span>
      <button class="btn small" id="fs-faster-btn">+</button>
      <button class="btn" id="fs-bloom-btn">Bloom</button>
      <button class="btn" id="fs-exit-btn">Exit</button>
    </div>
  </div>

  <script>
    // ============================================
    // SEEDED PSEUDO-RANDOM NUMBER GENERATOR
    // ============================================

    // Mulberry32 - fast, high-quality 32-bit PRNG
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // Convert any unicode string to a numeric seed
    function stringToSeed(str) {
      if (!str || str.length === 0) return 0;

      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.codePointAt(i);
        hash = ((hash << 5) - hash + char) | 0;
        // Handle surrogate pairs
        if (char > 0xFFFF) i++;
      }
      return Math.abs(hash);
    }

    // ============================================
    // COLOR GENERATION
    // ============================================

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
    }

    function generatePalette(rand) {
      const baseHue = rand();
      const scheme = Math.floor(rand() * 4);
      const palette = [];

      const paletteName = ['Analogous', 'Complementary', 'Triadic', 'Split'][scheme];

      switch(scheme) {
        case 0: // Analogous
          for (let i = 0; i < 5; i++) {
            palette.push(hslToRgb((baseHue + i * 0.08) % 1, 0.6 + rand() * 0.3, 0.4 + rand() * 0.3));
          }
          break;
        case 1: // Complementary
          for (let i = 0; i < 3; i++) {
            palette.push(hslToRgb(baseHue, 0.6 + rand() * 0.3, 0.3 + rand() * 0.4));
          }
          for (let i = 0; i < 2; i++) {
            palette.push(hslToRgb((baseHue + 0.5) % 1, 0.6 + rand() * 0.3, 0.3 + rand() * 0.4));
          }
          break;
        case 2: // Triadic
          for (let i = 0; i < 5; i++) {
            palette.push(hslToRgb((baseHue + (i % 3) * 0.333) % 1, 0.5 + rand() * 0.4, 0.35 + rand() * 0.35));
          }
          break;
        case 3: // Split complementary
          palette.push(hslToRgb(baseHue, 0.6 + rand() * 0.3, 0.4 + rand() * 0.3));
          palette.push(hslToRgb((baseHue + 0.42) % 1, 0.6 + rand() * 0.3, 0.4 + rand() * 0.3));
          palette.push(hslToRgb((baseHue + 0.58) % 1, 0.6 + rand() * 0.3, 0.4 + rand() * 0.3));
          palette.push(hslToRgb(baseHue, 0.3 + rand() * 0.2, 0.2 + rand() * 0.2));
          palette.push(hslToRgb(baseHue, 0.3 + rand() * 0.2, 0.6 + rand() * 0.2));
          break;
      }

      return { colors: palette, name: paletteName };
    }

    // ============================================
    // MANDALA DRAWING
    // ============================================

    const canvas = document.getElementById('mandala-canvas');
    const ctx = canvas.getContext('2d');
    const fsCanvas = document.getElementById('fullscreen-canvas');
    const fsCtx = fsCanvas.getContext('2d');

    // Offscreen canvas for bloom effect
    let bloomCanvas = document.createElement('canvas');
    let bloomCtx = bloomCanvas.getContext('2d');

    let currentParams = null;
    let animationId = null;
    let isAnimating = false;
    let isFullscreen = false;
    let animationSpeed = 1.0;
    let isBloomEnabled = false;
    let bloomIntensity = 0.6;

    // Get canvas properties dynamically
    function getCanvasProps(targetCanvas) {
      const centerX = targetCanvas.width / 2;
      const centerY = targetCanvas.height / 2;
      const maxRadius = Math.min(centerX, centerY) - 10;
      return { centerX, centerY, maxRadius };
    }

    function generateMandalaParams(seed) {
      const rand = mulberry32(seed);

      // Core parameters
      const symmetry = [6, 8, 10, 12, 16, 18, 20, 24][Math.floor(rand() * 8)];
      const layerCount = 4 + Math.floor(rand() * 5);
      const palette = generatePalette(rand);

      // Generate layer specifications (as ratios, scaled at draw time)
      const layers = [];
      let totalElements = 0;

      for (let i = 0; i < layerCount; i++) {
        const radiusRatio = 0.15 + (i / layerCount) * 0.8;
        const elementType = Math.floor(rand() * 7);
        const elementCount = symmetry * (1 + Math.floor(rand() * 2));
        const colorIndex = Math.floor(rand() * palette.colors.length);
        const strokeWidth = 0.5 + rand() * 2.5;
        const filled = rand() > 0.5;
        const rotationOffset = rand() * Math.PI * 2;
        const scale = 0.3 + rand() * 0.7;

        totalElements += elementCount;

        layers.push({
          radiusRatio: radiusRatio,
          type: elementType,
          count: elementCount,
          colorIndex: colorIndex,
          strokeWidth: strokeWidth,
          filled: filled,
          rotationOffset: rotationOffset,
          scale: scale,
          secondaryColorIndex: Math.floor(rand() * palette.colors.length)
        });
      }

      // Add some connecting elements
      const hasConnectors = rand() > 0.4;
      const connectorStyle = Math.floor(rand() * 3);

      return {
        seed: seed,
        symmetry: symmetry,
        layerCount: layerCount,
        layers: layers,
        palette: palette,
        totalElements: totalElements,
        hasConnectors: hasConnectors,
        connectorStyle: connectorStyle,
        backgroundStyle: Math.floor(rand() * 3)
      };
    }

    function getColor(palette, colorIndex) {
      return palette.colors[colorIndex];
    }

    // Apply bloom post-processing effect
    function applyBloom(targetCtx, targetCanvas) {
      if (!isBloomEnabled) return;

      // Ensure bloom canvas matches target size
      if (bloomCanvas.width !== targetCanvas.width || bloomCanvas.height !== targetCanvas.height) {
        bloomCanvas.width = targetCanvas.width;
        bloomCanvas.height = targetCanvas.height;
      }

      // Copy the original image to bloom canvas
      bloomCtx.clearRect(0, 0, bloomCanvas.width, bloomCanvas.height);
      bloomCtx.drawImage(targetCanvas, 0, 0);

      // Apply blur filter for the glow
      bloomCtx.filter = 'blur(15px) brightness(1.5)';
      bloomCtx.globalCompositeOperation = 'source-over';
      bloomCtx.drawImage(targetCanvas, 0, 0);
      bloomCtx.filter = 'none';

      // Composite the blurred glow back onto the original with additive blending
      targetCtx.globalCompositeOperation = 'lighter';
      targetCtx.globalAlpha = bloomIntensity;
      targetCtx.drawImage(bloomCanvas, 0, 0);

      // Second pass for extra dreamy glow
      bloomCtx.filter = 'blur(30px) brightness(1.2)';
      bloomCtx.clearRect(0, 0, bloomCanvas.width, bloomCanvas.height);
      bloomCtx.drawImage(targetCanvas, 0, 0);
      bloomCtx.filter = 'none';

      targetCtx.globalAlpha = bloomIntensity * 0.5;
      targetCtx.drawImage(bloomCanvas, 0, 0);

      // Reset composite mode
      targetCtx.globalCompositeOperation = 'source-over';
      targetCtx.globalAlpha = 1;
    }

    function drawMandala(params, rotationPhase = 0, targetCtx = ctx, targetCanvas = canvas) {
      const { centerX, centerY, maxRadius } = getCanvasProps(targetCanvas);

      // Clear and draw background
      targetCtx.fillStyle = '#0a0a0f';
      targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);

      // Background decoration
      drawBackground(params, targetCtx, centerX, centerY, maxRadius);

      // Draw each layer
      params.layers.forEach((layer, idx) => {
        drawLayer(layer, params, rotationPhase, idx, targetCtx, centerX, centerY, maxRadius);
      });

      // Draw connectors if enabled
      if (params.hasConnectors) {
        drawConnectors(params, rotationPhase, targetCtx, centerX, centerY, maxRadius);
      }

      // Center decoration
      drawCenter(params, targetCtx, centerX, centerY, maxRadius);

      // Apply bloom post-processing
      applyBloom(targetCtx, targetCanvas);
    }

    function drawBackground(params, targetCtx, centerX, centerY, maxRadius) {
      const gradient = targetCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);

      // Get bloomed background colors
      const bgColors = [
        ['rgba(139, 92, 246, 0.1)', 'rgba(59, 130, 246, 0.05)'],
        ['rgba(236, 72, 153, 0.1)', 'rgba(139, 92, 246, 0.05)'],
        ['rgba(16, 185, 129, 0.1)', 'rgba(59, 130, 246, 0.05)']
      ][params.backgroundStyle];

      gradient.addColorStop(0, bgColors[0]);
      gradient.addColorStop(0.5, bgColors[1]);
      gradient.addColorStop(1, 'transparent');

      targetCtx.fillStyle = gradient;
      targetCtx.beginPath();
      targetCtx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
      targetCtx.fill();
    }

    function drawLayer(layer, params, rotationPhase, layerIndex, targetCtx, centerX, centerY, maxRadius) {
      const angleStep = (Math.PI * 2) / layer.count;
      const layerRadius = maxRadius * layer.radiusRatio;
      const color = getColor(params.palette, layer.colorIndex);

      for (let i = 0; i < layer.count; i++) {
        const angle = i * angleStep + layer.rotationOffset + rotationPhase * (layerIndex % 2 === 0 ? 1 : -1) * 0.5;
        const x = centerX + Math.cos(angle) * layerRadius;
        const y = centerY + Math.sin(angle) * layerRadius;

        targetCtx.save();
        targetCtx.translate(x, y);
        targetCtx.rotate(angle + Math.PI / 2);

        const size = (maxRadius / 15) * layer.scale;

        targetCtx.strokeStyle = color;
        targetCtx.fillStyle = layer.filled ? color : 'transparent';
        targetCtx.lineWidth = layer.strokeWidth;
        targetCtx.lineCap = 'round';
        targetCtx.lineJoin = 'round';

        drawElement(layer.type, size, layer, targetCtx);

        targetCtx.restore();
      }
    }

    function drawElement(type, size, layer, targetCtx) {
      targetCtx.beginPath();

      switch(type) {
        case 0: // Circle
          targetCtx.arc(0, 0, size, 0, Math.PI * 2);
          break;

        case 1: // Petal / Teardrop
          targetCtx.moveTo(0, -size * 1.5);
          targetCtx.bezierCurveTo(size, -size, size, size * 0.5, 0, size);
          targetCtx.bezierCurveTo(-size, size * 0.5, -size, -size, 0, -size * 1.5);
          break;

        case 2: // Diamond
          targetCtx.moveTo(0, -size);
          targetCtx.lineTo(size * 0.6, 0);
          targetCtx.lineTo(0, size);
          targetCtx.lineTo(-size * 0.6, 0);
          targetCtx.closePath();
          break;

        case 3: // Triangle
          targetCtx.moveTo(0, -size);
          targetCtx.lineTo(size * 0.866, size * 0.5);
          targetCtx.lineTo(-size * 0.866, size * 0.5);
          targetCtx.closePath();
          break;

        case 4: // Star
          for (let i = 0; i < 5; i++) {
            const outerAngle = (i * Math.PI * 2 / 5) - Math.PI / 2;
            const innerAngle = outerAngle + Math.PI / 5;
            if (i === 0) {
              targetCtx.moveTo(Math.cos(outerAngle) * size, Math.sin(outerAngle) * size);
            } else {
              targetCtx.lineTo(Math.cos(outerAngle) * size, Math.sin(outerAngle) * size);
            }
            targetCtx.lineTo(Math.cos(innerAngle) * size * 0.4, Math.sin(innerAngle) * size * 0.4);
          }
          targetCtx.closePath();
          break;

        case 5: // Crescent
          targetCtx.arc(0, 0, size, 0, Math.PI * 2);
          targetCtx.moveTo(size * 0.5, 0);
          targetCtx.arc(size * 0.3, 0, size * 0.7, 0, Math.PI * 2, true);
          break;

        case 6: // Lotus petal (complex)
          targetCtx.moveTo(0, -size * 1.2);
          targetCtx.quadraticCurveTo(size * 1.2, -size * 0.3, size * 0.8, size * 0.5);
          targetCtx.quadraticCurveTo(size * 0.3, size * 0.8, 0, size);
          targetCtx.quadraticCurveTo(-size * 0.3, size * 0.8, -size * 0.8, size * 0.5);
          targetCtx.quadraticCurveTo(-size * 1.2, -size * 0.3, 0, -size * 1.2);
          break;
      }

      if (layer.filled) {
        targetCtx.fill();
      }
      targetCtx.stroke();
    }

    function drawConnectors(params, rotationPhase, targetCtx, centerX, centerY, maxRadius) {
      const innerLayer = params.layers[0];
      const outerLayer = params.layers[params.layers.length - 1];
      const innerRadius = maxRadius * innerLayer.radiusRatio;
      const outerRadius = maxRadius * outerLayer.radiusRatio;

      targetCtx.strokeStyle = getColor(params.palette, 0);
      targetCtx.fillStyle = getColor(params.palette, 0);
      targetCtx.lineWidth = 0.5;
      targetCtx.globalAlpha = 0.3;

      const count = params.symmetry;
      const angleStep = (Math.PI * 2) / count;

      for (let i = 0; i < count; i++) {
        const angle = i * angleStep + rotationPhase * 0.3;

        switch(params.connectorStyle) {
          case 0: // Straight lines
            targetCtx.beginPath();
            targetCtx.moveTo(
              centerX + Math.cos(angle) * innerRadius,
              centerY + Math.sin(angle) * innerRadius
            );
            targetCtx.lineTo(
              centerX + Math.cos(angle) * outerRadius,
              centerY + Math.sin(angle) * outerRadius
            );
            targetCtx.stroke();
            break;

          case 1: // Curved lines
            targetCtx.beginPath();
            const midRadius = (innerRadius + outerRadius) / 2;
            targetCtx.moveTo(
              centerX + Math.cos(angle) * innerRadius,
              centerY + Math.sin(angle) * innerRadius
            );
            targetCtx.quadraticCurveTo(
              centerX + Math.cos(angle + 0.2) * midRadius,
              centerY + Math.sin(angle + 0.2) * midRadius,
              centerX + Math.cos(angle) * outerRadius,
              centerY + Math.sin(angle) * outerRadius
            );
            targetCtx.stroke();
            break;

          case 2: // Dots along radii
            const dotSpacing = maxRadius / 15;
            for (let r = innerRadius; r < outerRadius; r += dotSpacing) {
              targetCtx.beginPath();
              targetCtx.arc(
                centerX + Math.cos(angle) * r,
                centerY + Math.sin(angle) * r,
                1.5, 0, Math.PI * 2
              );
              targetCtx.fill();
            }
            break;
        }
      }

      targetCtx.globalAlpha = 1;
    }

    function drawCenter(params, targetCtx, centerX, centerY, maxRadius) {
      const color0 = getColor(params.palette, 0);
      const color1 = getColor(params.palette, 1 % params.palette.colors.length);

      // Central circle
      const gradient = targetCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius * 0.15);
      gradient.addColorStop(0, color0);
      gradient.addColorStop(0.5, color1);
      gradient.addColorStop(1, 'transparent');

      targetCtx.fillStyle = gradient;
      targetCtx.beginPath();
      targetCtx.arc(centerX, centerY, maxRadius * 0.12, 0, Math.PI * 2);
      targetCtx.fill();

      // Inner decoration
      targetCtx.strokeStyle = color0;
      targetCtx.lineWidth = 1;
      targetCtx.beginPath();
      targetCtx.arc(centerX, centerY, maxRadius * 0.08, 0, Math.PI * 2);
      targetCtx.stroke();

      targetCtx.beginPath();
      targetCtx.arc(centerX, centerY, maxRadius * 0.03, 0, Math.PI * 2);
      targetCtx.fillStyle = color0;
      targetCtx.fill();
    }

    // ============================================
    // UI & INTERACTION
    // ============================================

    const seedInput = document.getElementById('seed-input');
    const seedDisplay = document.getElementById('seed-display');
    const randomBtn = document.getElementById('random-btn');
    const animateBtn = document.getElementById('animate-btn');
    const saveBtn = document.getElementById('save-btn');
    const slowerBtn = document.getElementById('slower-btn');
    const fasterBtn = document.getElementById('faster-btn');
    const speedDisplay = document.getElementById('speed-display');
    const bloomBtn = document.getElementById('bloom-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const fullscreenOverlay = document.getElementById('fullscreen-overlay');
    const fsSlowerBtn = document.getElementById('fs-slower-btn');
    const fsFasterBtn = document.getElementById('fs-faster-btn');
    const fsSpeedDisplay = document.getElementById('fs-speed-display');
    const fsBloomBtn = document.getElementById('fs-bloom-btn');
    const fsExitBtn = document.getElementById('fs-exit-btn');

    function updateMandala(text) {
      const seed = stringToSeed(text);
      seedDisplay.textContent = `seed: ${seed}`;

      currentParams = generateMandalaParams(seed);
      drawMandala(currentParams);

      // Update info panel
      document.getElementById('info-symmetry').textContent = currentParams.symmetry + '-fold';
      document.getElementById('info-layers').textContent = currentParams.layerCount;
      document.getElementById('info-elements').textContent = currentParams.totalElements;
      document.getElementById('info-palette').textContent = currentParams.palette.name;
    }

    // Input handling with debounce for smooth typing
    let debounceTimer;
    seedInput.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        updateMandala(e.target.value);
      }, 100);
    });

    // Random seed generation
    const randomWords = [
      'cosmos', 'serenity', 'aurora', 'ethereal', 'zenith',
      'harmony', 'celestial', 'whisper', 'infinity', 'solstice',
      'nebula', 'tranquil', 'luminous', 'mystical', 'radiant',
      'echoes', 'velvet', 'crystal', 'twilight', 'sacred',
      'om', 'namaste', 'shanti', 'dharma', 'karma',
      '42', 'fibonacci', 'golden', 'fractal', 'mandala'
    ];

    randomBtn.addEventListener('click', () => {
      const word = randomWords[Math.floor(Math.random() * randomWords.length)];
      const suffix = Math.floor(Math.random() * 1000);
      seedInput.value = `${word}${suffix}`;
      updateMandala(seedInput.value);
    });

    // Animation
    let rotationPhase = 0;

    function animate() {
      if (!isAnimating) return;

      rotationPhase += 0.005 * animationSpeed;

      // Draw to appropriate canvas
      if (isFullscreen) {
        drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
      } else {
        drawMandala(currentParams, rotationPhase);
      }

      animationId = requestAnimationFrame(animate);
    }

    animateBtn.addEventListener('click', () => {
      isAnimating = !isAnimating;
      animateBtn.textContent = isAnimating ? 'Stop' : 'Animate';

      if (isAnimating) {
        animate();
      } else {
        cancelAnimationFrame(animationId);
        drawMandala(currentParams, 0);
      }
    });

    // Speed controls
    const speedSteps = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 3.0, 4.0];

    function updateSpeedDisplay() {
      const text = animationSpeed.toFixed(animationSpeed < 1 ? 2 : 1) + 'x';
      speedDisplay.textContent = text;
      fsSpeedDisplay.textContent = text;
    }

    function adjustSpeed(delta) {
      const currentIdx = speedSteps.findIndex(s => s >= animationSpeed);
      const newIdx = Math.max(0, Math.min(speedSteps.length - 1, currentIdx + delta));
      animationSpeed = speedSteps[newIdx];
      updateSpeedDisplay();
    }

    slowerBtn.addEventListener('click', () => adjustSpeed(-1));
    fasterBtn.addEventListener('click', () => adjustSpeed(1));
    fsSlowerBtn.addEventListener('click', () => adjustSpeed(-1));
    fsFasterBtn.addEventListener('click', () => adjustSpeed(1));

    // Bloom toggle (HDR glow effect)
    function toggleBloom() {
      isBloomEnabled = !isBloomEnabled;
      const text = isBloomEnabled ? 'Bloom On' : 'Bloom';
      bloomBtn.textContent = text;
      fsBloomBtn.textContent = text;

      // Redraw to show/hide bloom effect
      if (isFullscreen) {
        drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
      } else {
        drawMandala(currentParams, rotationPhase);
      }
    }

    bloomBtn.addEventListener('click', toggleBloom);
    fsBloomBtn.addEventListener('click', toggleBloom);

    // Fullscreen mode
    function enterFullscreen() {
      isFullscreen = true;
      fullscreenOverlay.classList.add('active');

      // Resize fullscreen canvas to fit viewport
      const size = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      fsCanvas.width = size;
      fsCanvas.height = size;

      // Start animation if not already running
      if (!isAnimating) {
        isAnimating = true;
        animateBtn.textContent = 'Stop';
        animate();
      }

      // Draw immediately
      drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
    }

    function exitFullscreen() {
      isFullscreen = false;
      fullscreenOverlay.classList.remove('active');

      // Redraw main canvas
      if (isAnimating) {
        drawMandala(currentParams, rotationPhase);
      }
    }

    fullscreenBtn.addEventListener('click', enterFullscreen);
    fsExitBtn.addEventListener('click', exitFullscreen);

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (isFullscreen) {
        switch(e.key) {
          case 'Escape':
            exitFullscreen();
            break;
          case 'ArrowLeft':
            adjustSpeed(-1);
            e.preventDefault();
            break;
          case 'ArrowRight':
            adjustSpeed(1);
            e.preventDefault();
            break;
          case 'b':
          case 'B':
            toggleBloom();
            break;
          case ' ':
            isAnimating = !isAnimating;
            animateBtn.textContent = isAnimating ? 'Stop' : 'Animate';
            if (isAnimating) {
              animate();
            } else {
              cancelAnimationFrame(animationId);
            }
            e.preventDefault();
            break;
        }
      }
    });

    // Handle window resize in fullscreen
    window.addEventListener('resize', () => {
      if (isFullscreen) {
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.9;
        fsCanvas.width = size;
        fsCanvas.height = size;
        drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
      }
    });

    // Save image
    saveBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      const seedText = seedInput.value || 'mandala';
      link.download = `mandala-${seedText.replace(/[^a-z0-9]/gi, '_')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // Initialize with a default seed
    updateMandala('');
  </script>

</body>
</html>
