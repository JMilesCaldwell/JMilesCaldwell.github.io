<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mandala Generator ¬∑ Lab 1 ¬∑ Imogen</title>
  <link rel="icon" href="resources/Imogen.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    /* ---------------------------------------------------- */
    /* 1. MINIMALIST DESIGN AESTHETIC */
    /* ---------------------------------------------------- */
    :root {
      --color-primary-accent: #C8AA6E; /* Polished Brass / Metallic Accent */
      --color-primary-canvas: #C8AA6E; /* Canvas highlight color */
      --color-neutral-dark: #111111;   /* Primary Background */
      --color-neutral-medium: #888888; /* Secondary text */
      --color-bg-light: #EEEEEE;      /* White/Light Background for Contrast Elements */
      --color-bg-panel: #1A1A1A;      /* Dark Panel Background */
      --color-text-light: #EEEEEE;    /* Primary Text Color */
      --color-border: #333333;        /* Dark Border Color */
      --shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--color-neutral-dark);
      color: var(--color-text-light);
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }
    .navbar {
      display: flex; justify-content: center; align-items: center;
      background: var(--color-bg-panel); padding: 1.2rem 2rem;
      position: sticky; top: 0; width: 100%; z-index: 1000;
      border-bottom: 1px solid var(--color-border); box-shadow: var(--shadow-soft);
    }
    .navbar a { color: var(--color-neutral-medium); font-size: 0.8rem; font-weight: 500; text-decoration: none; margin: 0 2rem; transition: color 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
    .navbar a:hover { color: var(--color-primary-accent); }

    .container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5rem 2rem 3rem; gap: 3rem; width: 95%; max-width: 1500px; margin: 0 auto; }
    .main-content-grid { display: flex; gap: 4rem; width: 100%; align-items: flex-start; }
    .center-column { display: flex; flex-direction: column; align-items: center; gap: 2rem; flex: 0 0 650px; }

    /* Info Panels - Structured, Technical Look */
    .explanation-panel { flex: 1; max-width: 420px; padding: 2.2rem; background: var(--color-bg-panel); border-radius: 4px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); position: sticky; top: 7rem; min-height: 400px; }
    .explanation-panel h3 { color: var(--color-primary-accent); font-size: 1rem; font-weight: 500; border-bottom: 1px solid var(--color-border); padding-bottom: 0.75rem; margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px; }
    .explanation-panel h4 { color: var(--color-text-light); font-size: 0.9rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.6rem; }
    .explanation-panel p, .explanation-panel ul, .explanation-panel li { font-size: 0.85rem; color: var(--color-neutral-medium); margin-bottom: 0.8rem; line-height: 1.5; list-style-position: inside; padding-left: 0; }
    .explanation-panel strong { color: var(--color-text-light); font-weight: 600; }
    .color-block { display: inline-block; width: 14px; height: 14px; border-radius: 50%; margin-right: 8px; border: 1px solid var(--color-border); vertical-align: middle;}

    .header-group { text-align: center; max-width: 900px; padding: 0 1rem; margin-bottom: 0rem; }
    .title { font-size: 3rem; font-weight: 300; color: var(--color-text-light); letter-spacing: 5px; text-transform: uppercase; margin-bottom: 0.5rem; }
    .subtitle { font-size: 1rem; color: var(--color-neutral-medium); font-weight: 400; letter-spacing: 0.5px; }

    /* Input Card - Dark and clean */
    .input-group { display: flex; flex-direction: column; gap: 1.5rem; width: 100%; background: var(--color-bg-panel); padding: 1.5rem 2rem; border-radius: 4px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); }
    .input-row { display: flex; gap: 1rem; }
    
    .text-input, .date-input { 
      background: var(--color-neutral-dark); border: 1px solid var(--color-border); border-radius: 4px; 
      color: var(--color-text-light); padding: 0.9rem; font-family: inherit; outline: none; transition: border-color 0.3s, box-shadow 0.3s;
    }
    .text-input { flex: 2; font-size: 1rem; }
    .date-input { flex: 1; font-size: 0.9rem; text-align: center; cursor: pointer; }
    .text-input:focus, .date-input:focus { border-color: var(--color-primary-accent); box-shadow: 0 0 0 3px rgba(200, 170, 110, 0.2); background: #222; }

    /* Meta Info */
    .meta-display { display: flex; justify-content: space-between; align-items: flex-end; border-top: 1px solid var(--color-border); padding-top: 1.2rem; margin-top: 0.5rem; }
    .meta-box { display: flex; flex-direction: column; }
    .meta-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.5px; color: var(--color-neutral-medium); margin-bottom: 4px; font-weight: 500; }
    .meta-value { color: var(--color-primary-accent); font-size: 1rem; font-weight: 700; }
    .rune-font { font-size: 1.6rem; line-height: 1; color: var(--color-primary-accent); letter-spacing: 2px; }

    /* Canvas */
    .canvas-wrapper { position: relative; margin: 1rem 0; background: #080706; border-radius: 50%; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.8), inset 0 0 10px rgba(255, 255, 255, 0.1); }
    #mandala-canvas { border-radius: 50%; display: block; max-width: 90vw; height: auto; cursor: crosshair; }

    /* Controls - Clean, button-heavy */
    .controls { display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: center; max-width: 650px; }
    .btn { background: var(--color-bg-panel); border: 1px solid var(--color-border); color: var(--color-neutral-medium); padding: 0.8rem 1.4rem; border-radius: 4px; cursor: pointer; transition: all 0.3s; font-size: 0.8rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }
    .btn:hover { border-color: var(--color-primary-accent); color: var(--color-primary-accent); background: #222; }

    .audio-controls { display: flex; gap: 0.5rem; align-items: center; padding: 0.6rem 1rem; border-radius: 4px; background: var(--color-bg-panel); border: 1px solid var(--color-border); flex-wrap: wrap; max-width: 650px; }
    .audio-controls label { font-size: 0.65rem; color: var(--color-neutral-medium); text-transform: uppercase; letter-spacing: 0.5px; }
    .audio-controls input[type="range"] { width: 50px; appearance: none; height: 3px; background: var(--color-border); border-radius: 2px; }
    .audio-controls input[type="range"]::-webkit-slider-thumb { appearance: none; width: 10px; height: 10px; border-radius: 50%; background: var(--color-primary-accent); cursor: pointer; }

    /* Fullscreen */
    .fullscreen-overlay { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 9999; justify-content: center; align-items: center; }
    .fullscreen-overlay.active { display: flex; cursor: none; }
    
    .fs-hover-zone { position: absolute; bottom: 0; left: 0; width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; z-index: 10000; transition: opacity 0.3s; pointer-events: none; }
    .fs-controls { background: rgba(30,30,30,0.95); border: 1px solid var(--color-border); padding: 15px 25px; border-radius: 4px; display: flex; gap: 15px; opacity: 0; transition: opacity 0.3s; pointer-events: auto; }
    .fs-controls .btn { background: var(--color-primary-accent); color: var(--color-neutral-dark); border-color: var(--color-primary-accent); font-weight: 600; }
    .fs-controls .btn:hover { background: #B99C5E; }
    .fullscreen-overlay.active:hover .fs-hover-zone { opacity: 1; pointer-events: auto; }
    .fs-hover-zone:hover .fs-controls { opacity: 1; }

    .fs-stat { background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 4px; position: fixed; top: 20px; right: 20px; color: var(--color-primary-canvas); font-size: 0.8rem; transition: opacity 0.3s; opacity: 0; pointer-events: none; }
    .fs-stat.visible { opacity: 1; }

    @media (max-width: 1200px) {
      .main-content-grid { flex-direction: column; align-items: center; }
      .explanation-panel { max-width: 650px; width: 100%; position: static; }
      .center-column { flex: 1; }
    }
    @media (max-width: 650px) {
      .input-row { flex-direction: column; }
      .controls { gap: 0.8rem; }
      .audio-controls { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>

<body>

  <div class="navbar">
    <a href="../index.html">Caldwell's Repository</a>
    <a href="../apocrypha.html">Apocrypha</a>
    <a href="../imogen.html">Imogen</a>
  </div>

  <div class="container">
    <div class="header-group">
      <h1 class="title">SIG.01: Generative Geometry</h1>
      <p class="subtitle">
        An engineered visualization of semantic and temporal input data.<br>
        Rendering a unique structural diagram based on user-defined parameters.
      </p>
    </div>

    <div class="main-content-grid">
      <div class="explanation-panel left-panel">
        <div id="left-panel-content">
          </div>
      </div>

      <div class="center-column">
        <div class="input-group">
          <div class="input-row">
            <input type="text" class="text-input" id="seed-input" placeholder="Project Name or Data String..." autocomplete="off">
            <input type="date" class="date-input" id="date-input">
          </div>
          
          <div class="meta-display">
            <div class="meta-box">
              <span class="meta-label">Runic Signature</span>
              <span class="meta-value rune-font" id="rune-display"></span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Input Signature</span>
              <span class="meta-value" id="element-display">VOID / VOID</span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Complexity Index</span>
              <span class="meta-value" id="archetype-display">Grid Type / 0.0</span>
            </div>
          </div>
        </div>

        <div class="canvas-wrapper">
          <canvas id="mandala-canvas" width="650" height="650"></canvas>
        </div>

        <div class="controls">
          <button class="btn" id="random-btn">Generate New Data</button>
          <button class="btn" id="animate-btn">Start Flow</button>
          <button class="btn" id="bloom-btn">Toggle Light Spill</button>
          <button class="btn" id="save-btn">Export Image (PNG)</button>

          <select class="btn" id="script-selector" style="cursor: pointer;">
            <option value="runic">Runic (Elder Futhark)</option>
            <option value="tibetan">Tibetan</option>
            <option value="devanagari">Sanskrit (Devanagari)</option>
            <option value="theban">Theban (Witches' Alphabet)</option>
            <option value="coptic">Coptic</option>
            <option value="hebrew">Hebrew</option>
          </select>

          <select class="btn" id="color-mode-selector" style="cursor: pointer;">
            <option value="elemental">Elemental (Default)</option>
            <option value="primary">Primary Colors</option>
            <option value="secondary">Secondary Colors</option>
            <option value="rainbow">Rainbow Spectrum</option>
            <option value="monochrome">Monochrome</option>
            <option value="neon">Neon Glow</option>
          </select>

          <div class="audio-controls" id="audio-controls">
            <button class="btn" id="audio-toggle">Tone OFF</button>

            <label for="waveform-select">Wave</label>
            <select id="waveform-select" style="padding: 4px; background: var(--color-neutral-dark); color: var(--color-text-light); border: 1px solid var(--color-border); border-radius: 3px; font-size: 0.7rem;">
              <option value="auto">Auto</option>
              <option value="sine">Sine</option>
              <option value="triangle">Triangle</option>
              <option value="sawtooth">Sawtooth</option>
              <option value="square">Square</option>
            </select>

            <label for="beat-range">Beat</label>
            <input id="beat-range" type="range" min="1" max="12" step="0.1" value="6" data-touched="0">
            <label for="vol-range">Vol</label>
            <input id="vol-range" type="range" min="0" max="0.15" step="0.005" value="0.06">
            <label for="filter-range">Filter</label>
            <input id="filter-range" type="range" min="200" max="8000" step="50" value="4000">
            <label for="detune-range">Detune</label>
            <input id="detune-range" type="range" min="-50" max="50" step="1" value="0">
            <label for="lfo-range">Drift</label>
            <input id="lfo-range" type="range" min="0.01" max="2" step="0.01" value="0.1">
            <label for="harmonics-range">Harmonics</label>
            <input id="harmonics-range" type="range" min="0" max="1" step="0.05" value="0">
            <label for="interval-range">Interval</label>
            <input id="interval-range" type="range" min="0" max="12" step="1" value="0">
            <label for="reverb-range">Reverb</label>
            <input id="reverb-range" type="range" min="0" max="1" step="0.05" value="0">
            <label for="iso-range">Isochronic</label>
            <input id="iso-range" type="range" min="0" max="1" step="0.05" value="0">
            <label for="am-range">AM Depth</label>
            <input id="am-range" type="range" min="0" max="1" step="0.05" value="0">
          </div>

          <div class="audio-controls" id="kick-controls">
            <button class="btn" id="kick-toggle">Kick OFF</button>
            <label for="kick-bpm">BPM</label>
            <input id="kick-bpm" type="range" min="30" max="180" step="1" value="60">
            <label for="kick-pitch">Pitch</label>
            <input id="kick-pitch" type="range" min="30" max="100" step="1" value="50">
            <label for="kick-decay">Decay</label>
            <input id="kick-decay" type="range" min="0.05" max="0.5" step="0.01" value="0.15">
            <label for="kick-punch">Punch</label>
            <input id="kick-punch" type="range" min="0" max="1" step="0.05" value="0.5">
            <label for="kick-vol">Vol</label>
            <input id="kick-vol" type="range" min="0" max="1" step="0.05" value="0.5">
          </div>

          <button class="btn" id="morph-btn">Morph: ON</button>
          <button class="btn" id="fullscreen-btn">Full Screen Mode (F11)</button>
        </div>
      </div>

      <div class="explanation-panel right-panel">
        <div id="right-panel-content">
          </div>
      </div>

    </div>
  </div>

  <div class="fullscreen-overlay" id="fullscreen-overlay">
    <canvas id="fullscreen-canvas"></canvas>
    
    <div class="fs-stat" id="fs-stat"></div>

    <div class="fs-hover-zone">
      <div class="fs-controls">
        <button class="btn" id="fs-exit">Exit (ESC)</button>
        <div style="display:flex;flex-direction:column;align-items:flex-start;color:#EEE;margin-left:8px;font-size:0.8rem;">
          <div>[‚Üë/‚Üì] Light Intensity: <span id="bloom-display">0.60</span></div>
          <div>[‚Üê/‚Üí] Motion Index: <span id="speed-display">1.00</span></div>
          <div>[+/-] Tone Volume: <span id="volume-display">0.06</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====================================================================
    // 1. CONSTANTS & UTILITIES (Refined for Minimalist/Technical Language)
    // ====================================================================
    const W = 650, H = 650; 

    // Multi-Script Mapping Systems
    const SCRIPT_MAPPINGS = {
      // Elder Futhark Runes (U+16A0-U+16FF)
      runic: {
        'a': '·ö®', 'b': '·õí', 'c': '·ö≤', 'd': '·õû', 'e': '·õñ', 'f': '·ö†', 'g': '·ö∑', 'h': '·ö∫',
        'i': '·õÅ', 'j': '·õÉ', 'k': '·ö≤', 'l': '·õö', 'm': '·õó', 'n': '·öæ', 'o': '·õü', 'p': '·õà',
        'q': '·ö≤', 'r': '·ö±', 's': '·õä', 't': '·õè', 'u': '·ö¢', 'v': '·öπ', 'w': '·öπ', 'x': '·ö≤·õä',
        'y': '·õÉ', 'z': '·õâ', ' ': '‚ñµ',
        'th': '·ö¶', 'ng': '·õú', 'ei': '·õá', 'ae': '·ö®·õñ',
        font: "'Segoe UI Symbol', 'Noto Sans Runic', sans-serif"
      },

      // Tibetan (U+0F00-U+0FFF)
      tibetan: {
        'a': '‡Ω®', 'b': '‡Ωñ', 'c': '‡Ωô', 'd': '‡Ωë', 'e': '‡Ω∫', 'f': '‡Ωï', 'g': '‡ΩÇ', 'h': '‡Ωß',
        'i': '‡Ω≤', 'j': '‡Ωá', 'k': '‡ΩÄ', 'l': '‡Ω£', 'm': '‡Ωò', 'n': '‡Ωì', 'o': '‡Ωº', 'p': '‡Ωî',
        'q': '‡ΩÄ', 'r': '‡Ω¢', 's': '‡Ω¶', 't': '‡Ωè', 'u': '‡Ω¥', 'v': '‡Ωù', 'w': '‡Ωù', 'x': '‡ΩÄ‡Ω¶',
        'y': '‡Ω°', 'z': '‡Ωü', ' ': '‚ñµ',
        font: "'Noto Sans Tibetan', 'Microsoft Himalaya', sans-serif"
      },

      // Devanagari/Sanskrit (U+0900-U+097F)
      devanagari: {
        'a': '‡§Ö', 'b': '‡§¨', 'c': '‡§ö', 'd': '‡§¶', 'e': '‡§è', 'f': '‡§´', 'g': '‡§ó', 'h': '‡§π',
        'i': '‡§á', 'j': '‡§ú', 'k': '‡§ï', 'l': '‡§≤', 'm': '‡§Æ', 'n': '‡§®', 'o': '‡§ì', 'p': '‡§™',
        'q': '‡§ï', 'r': '‡§∞', 's': '‡§∏', 't': '‡§§', 'u': '‡§â', 'v': '‡§µ', 'w': '‡§µ', 'x': '‡§ï‡•ç‡§∑',
        'y': '‡§Ø', 'z': '‡§ú', ' ': '‚ñµ',
        font: "'Noto Sans Devanagari', 'Mangal', sans-serif"
      },

      // Theban/Witches' Alphabet - using close Unicode approximations
      theban: {
        'a': 'êåÄ', 'b': 'êåÅ', 'c': 'êåÇ', 'd': 'êåÉ', 'e': 'êåÑ', 'f': 'êåÖ', 'g': 'êåÜ', 'h': 'êåá',
        'i': 'êåâ', 'j': 'êåâ', 'k': 'êåä', 'l': 'êåã', 'm': 'êåå', 'n': 'êåç', 'o': 'êåè', 'p': 'êåê',
        'q': 'êåí', 'r': 'êåì', 's': 'êåî', 't': 'êåï', 'u': 'êåñ', 'v': 'êåñ', 'w': 'êåÖ', 'x': 'êåó',
        'y': 'êåô', 'z': 'êåÜ', ' ': '‚ñµ',
        font: "'Noto Sans Old Italic', 'Segoe UI Historic', sans-serif"
      },

      // Coptic (U+2C80-U+2CFF)
      coptic: {
        'a': '‚≤Ä', 'b': '‚≤Ç', 'c': '‚≤§', 'd': '‚≤Ü', 'e': '‚≤à', 'f': '‚≤™', 'g': '‚≤Ñ', 'h': 'œ®',
        'i': '‚≤í', 'j': '‚≥í', 'k': '‚≤î', 'l': '‚≤ñ', 'm': '‚≤ò', 'n': '‚≤ö', 'o': '‚≤û', 'p': '‚≤†',
        'q': '‚≤î', 'r': '‚≤¢', 's': '‚≤§', 't': '‚≤¶', 'u': '‚≤®', 'v': '‚≤Ç', 'w': '‚≤∞', 'x': '‚≤ú',
        'y': '‚≤®', 'z': '‚≤å', ' ': '‚ñµ',
        font: "'Noto Sans Coptic', 'Antinoou', sans-serif"
      },

      // Hebrew (U+0590-U+05FF)
      hebrew: {
        'a': '◊ê', 'b': '◊ë', 'c': '◊õ', 'd': '◊ì', 'e': '◊î', 'f': '◊§', 'g': '◊í', 'h': '◊ó',
        'i': '◊ô', 'j': '◊ô', 'k': '◊õ', 'l': '◊ú', 'm': '◊û', 'n': '◊†', 'o': '◊¢', 'p': '◊§',
        'q': '◊ß', 'r': '◊®', 's': '◊°', 't': '◊™', 'u': '◊ï', 'v': '◊ï', 'w': '◊ï', 'x': '◊õ◊°',
        'y': '◊ô', 'z': '◊ñ', ' ': '‚ñµ',
        font: "'Noto Sans Hebrew', 'David', 'Arial Hebrew', sans-serif"
      }
    };

    // Maintain backward compatibility
    const LATIN_TO_RUNE = SCRIPT_MAPPINGS.runic;

    // Element definitions with lookup keys
    const ELEMENTS = {
      METAL: { key: 'METAL', name: 'Alloy (Metal)', colors: ['#D0D0D0', '#A0A0A0', '#707070', '#555555', '#FFFFFF'], meaning: 'Represents Structural Integrity and Data Clarity.' },
      WATER: { key: 'WATER', name: 'Fluidic (Water)', colors: ['#30404C', '#576775', '#7A8C98', '#9DB0C0', '#B0B0B0'], meaning: 'Represents System Flow and Dynamic Input.' },
      WOOD: { key: 'WOOD', name: 'Composite (Wood)', colors: ['#2D5743', '#4E8A6E', '#7DB49A', '#BCC8BF', '#A0A0A0'], meaning: 'Represents Growth Vectors and Expansion.' },
      FIRE: { key: 'FIRE', name: 'Thermal (Fire)', colors: ['#D24B4F', '#A04A4E', '#E98E92', '#F9C2C4', '#FEE6E7'], meaning: 'Represents Energy State and Transformation Rate.' },
      EARTH: { key: 'EARTH', name: 'Foundation (Earth)', colors: ['#8A735E', '#A6927C', '#C2B19F', '#DDD0C3', '#909090'], meaning: 'Represents Core Stability and Base Coordinates.' }
    };
    const MONTH_ELEMENTS = [
      ELEMENTS.EARTH, ELEMENTS.EARTH, ELEMENTS.WOOD, ELEMENTS.WOOD, ELEMENTS.FIRE, ELEMENTS.FIRE,
      ELEMENTS.METAL, ELEMENTS.METAL, ELEMENTS.WATER, ELEMENTS.WATER, ELEMENTS.EARTH, ELEMENTS.EARTH
    ];
    // A=432Hz tuning note frequencies from C2 to C4
    // Formula: freq = 432 * 2^((semitone - 49) / 12) where A4 = 49
    const NOTE_FREQUENCIES_432 = [
      { note: 'C2',  freq: 64.22,  semitone: 0 },
      { note: 'C#2', freq: 68.04,  semitone: 1 },
      { note: 'D2',  freq: 72.08,  semitone: 2 },
      { note: 'D#2', freq: 76.37,  semitone: 3 },
      { note: 'E2',  freq: 80.91,  semitone: 4 },
      { note: 'F2',  freq: 85.72,  semitone: 5 },
      { note: 'F#2', freq: 90.82,  semitone: 6 },
      { note: 'G2',  freq: 96.22,  semitone: 7 },
      { note: 'G#2', freq: 101.94, semitone: 8 },
      { note: 'A2',  freq: 108.00, semitone: 9 },
      { note: 'A#2', freq: 114.42, semitone: 10 },
      { note: 'B2',  freq: 121.23, semitone: 11 },
      { note: 'C3',  freq: 128.43, semitone: 12 },
      { note: 'C#3', freq: 136.07, semitone: 13 },
      { note: 'D3',  freq: 144.16, semitone: 14 },
      { note: 'D#3', freq: 152.74, semitone: 15 },
      { note: 'E3',  freq: 161.82, semitone: 16 },
      { note: 'F3',  freq: 171.44, semitone: 17 },
      { note: 'F#3', freq: 181.63, semitone: 18 },
      { note: 'G3',  freq: 192.43, semitone: 19 },
      { note: 'G#3', freq: 203.88, semitone: 20 },
      { note: 'A3',  freq: 216.00, semitone: 21 },
      { note: 'A#3', freq: 228.84, semitone: 22 },
      { note: 'B3',  freq: 242.45, semitone: 23 },
      { note: 'C4',  freq: 256.87, semitone: 24 }
    ];

    // Solfeggio / Planetary Frequencies (legacy, used for element mapping)
    const SOUND_ELEMENT_MAPPING = {
      METAL: { freq: 432, note: "A4 (432 Hz)", explanation: "Target for Cognitive Clarity." },
      WATER: { freq: 192.43, note: "G3", explanation: "Target for System Dynamics." },
      WOOD: { freq: 144.16, note: "D3", explanation: "Target for Vector Optimization." },
      FIRE: { freq: 216.00, note: "A3", explanation: "Target for State Transition." },
      EARTH: { freq: 128.43, note: "C3", explanation: "Target for Base Stability." }
    };

    // Waveform selection based on Element
    const WAVEFORM_MAP = {
      'METAL': 'triangle', // Sharp, clear, structural
      'WATER': 'sine',     // Smooth, fluid
      'WOOD': 'sawtooth',  // Growing, forward
      'FIRE': 'square',    // Intense, energetic
      'EARTH': 'sine'      // Stable, fundamental
    };

    // Color mode palettes
    const COLOR_MODES = {
      elemental: null, // Uses element-based colors (default behavior)
      primary: {
        colors: ['#FF0000', '#0000FF', '#FFFF00', '#FF0000', '#0000FF'], // Red, Blue, Yellow
        accent: '#FFFFFF'
      },
      secondary: {
        colors: ['#FF8000', '#00FF00', '#8000FF', '#FF8000', '#00FF00'], // Orange, Green, Purple
        accent: '#FFFFFF'
      },
      rainbow: {
        colors: ['#FF0000', '#FF8000', '#FFFF00', '#00FF00', '#0080FF', '#8000FF'],
        accent: '#FFFFFF'
      },
      monochrome: {
        colors: ['#FFFFFF', '#CCCCCC', '#999999', '#666666', '#333333'],
        accent: '#FFFFFF'
      },
      neon: {
        colors: ['#FF00FF', '#00FFFF', '#FF00AA', '#AAFF00', '#00AAFF'],
        accent: '#FFFFFF'
      }
    };

    // Symbol systems for each script with traditional meanings
    const SCRIPT_SYMBOLS = {
      runic: [
        { char: '·ö†', desc: 'Fehu (Wealth)', meaning: 'Abundance, prosperity, and mobile power. The primal fire of creation.' },
        { char: '·ö¢', desc: 'Uruz (Aurochs)', meaning: 'Strength, vitality, and raw untamed potential. The life force.' },
        { char: '·ö¶', desc: 'Thurisaz (Thor)', meaning: 'Protection, defense, and directed force. The hammer of change.' },
        { char: '·ö®', desc: 'Ansuz (Odin)', meaning: 'Wisdom, communication, and divine breath. The voice of insight.' },
        { char: '·ö±', desc: 'Raido (Journey)', meaning: 'Movement, rhythm, and right action. The path forward.' },
        { char: '·ö≤', desc: 'Kenaz (Torch)', meaning: 'Knowledge, illumination, and creative fire. The inner light.' },
        { char: '·õä', desc: 'Sowilo (Sun)', meaning: 'Success, victory, and vital energy. Solar power and clarity.' },
        { char: '·öπ', desc: 'Wunjo (Joy)', meaning: 'Harmony, fellowship, and aligned will. The binding force.' },
        { char: '·õû', desc: 'Dagaz (Dawn)', meaning: 'Transformation, breakthrough, and awakening. The turning point.' },
        { char: '·õü', desc: 'Othala (Heritage)', meaning: 'Ancestral power, foundation, and sacred enclosure. The roots.' },
        { char: '·õö', desc: 'Laguz (Water)', meaning: 'Flow, intuition, and the unconscious depths. The primal waters.' }
      ],
      tibetan: [
        { char: '‡Ω®', desc: 'A (Primordial)', meaning: 'The source of all sound. Beginning of manifestation and pure awareness.' },
        { char: '‡Ω®‡Ωº‡Ωæ', desc: 'Om (Sacred)', meaning: 'Universal consciousness. The sound of creation and divine presence.' },
        { char: '‡Ωî‡Ωë‡æ®', desc: 'Padma (Lotus)', meaning: 'Purity rising from mud. Spiritual awakening and enlightenment.' },
        { char: '‡Ωò', desc: 'Ma (Mother)', meaning: 'Compassion and nurturing. The feminine principle of wisdom.' },
        { char: '‡Ωß‡Ω±‡Ω¥‡æÉ', desc: 'Hum (Wisdom)', meaning: 'Indestructible reality. Diamond mind and transformative power.' },
        { char: '‡Ω¶‡æ≠‡Ω±', desc: 'Soha (Offering)', meaning: 'Dedication and completion. Sealing of intention and practice.' },
        { char: '‡Ωñ‡Ωõ‡æ≤', desc: 'Vajra (Diamond)', meaning: 'Indestructible truth. Clarity cutting through illusion.' },
        { char: '‡Ωë‡æ∑‡Ω¢‡æ®', desc: 'Dharma (Truth)', meaning: 'Universal law. The path of righteousness and cosmic order.' },
        { char: '‡Ω¶‡ΩÑ‡æí', desc: 'Sangha (Community)', meaning: 'Sacred fellowship. Unity in spiritual practice and purpose.' },
        { char: '‡Ωñ‡Ωº‡Ωë‡æ∑‡Ω≤', desc: 'Bodhi (Awakening)', meaning: 'Perfect enlightenment. Realization of ultimate truth.' },
        { char: '‡Ω§‡Ω±‡Ωì‡æü‡Ω≤', desc: 'Shanti (Peace)', meaning: 'Supreme tranquility. Cessation of suffering and inner calm.' }
      ],
      devanagari: [
        { char: '‡•ê', desc: 'Om (Pranava)', meaning: 'The primordial sound. Creation, preservation, and dissolution unified.' },
        { char: '‡§∂‡•ç‡§∞‡•Ä', desc: 'Shri (Sacred)', meaning: 'Auspiciousness and prosperity. Divine grace and abundance.' },
        { char: '‡§ó‡§Ç', desc: 'Gam (Ganesha)', meaning: 'Removing obstacles. Wisdom and new beginnings blessed.' },
        { char: '‡§π‡•ç‡§∞‡•Ä‡§Ç', desc: 'Hreem (Shakti)', meaning: 'Divine feminine energy. Creative power and transformation.' },
        { char: '‡§ï‡•ç‡§≤‡•Ä‡§Ç', desc: 'Kleem (Attraction)', meaning: 'Magnetic force. Drawing desires into manifestation.' },
        { char: '‡§ê‡§Ç', desc: 'Aim (Saraswati)', meaning: 'Knowledge and arts. Flow of creative wisdom and speech.' },
        { char: '‡§∏‡§§‡•ç', desc: 'Sat (Truth)', meaning: 'Pure existence. Eternal unchanging reality beyond form.' },
        { char: '‡§ö‡§ø‡§§‡•ç', desc: 'Chit (Consciousness)', meaning: 'Awareness itself. The light of pure knowing.' },
        { char: '‡§Ü‡§®‡§®‡•ç‡§¶', desc: 'Ananda (Bliss)', meaning: 'Supreme joy. The nature of realized consciousness.' },
        { char: '‡§¨‡•ç‡§∞‡§π‡•ç‡§Æ', desc: 'Brahman (Absolute)', meaning: 'Ultimate reality. The infinite source beyond conception.' },
        { char: '‡§∂‡§æ‡§®‡•ç‡§§‡§ø', desc: 'Shanti (Peace)', meaning: 'Threefold peace. Body, mind, spirit in harmony.' }
      ],
      theban: [
        { char: 'êåÄ', desc: 'A (Beginning)', meaning: 'First breath of magic. Initiation into hidden knowledge.' },
        { char: 'êåÅ', desc: 'B (Protection)', meaning: 'Shield against harm. Warding and defensive mysteries.' },
        { char: 'êåÇ', desc: 'C (Circle)', meaning: 'Sacred boundary. The witch\'s circle of power cast.' },
        { char: 'êåÉ', desc: 'D (Door)', meaning: 'Threshold between worlds. Gateway to otherworldly realms.' },
        { char: 'êåÑ', desc: 'E (Elements)', meaning: 'Command of natural forces. Mastery over earth and sky.' },
        { char: 'êåÖ', desc: 'F (Fire)', meaning: 'Transformative flame. Purification and magical will ignited.' },
        { char: 'êåÜ', desc: 'G (Growth)', meaning: 'Green witchcraft. Herbs, healing, and natural magic.' },
        { char: 'êåá', desc: 'H (Hex)', meaning: 'Binding and cursing. Shadow work and karmic balance.' },
        { char: 'êåâ', desc: 'I (Intuition)', meaning: 'Psychic sight. Third eye opened to hidden truths.' },
        { char: 'êåå', desc: 'M (Moon)', meaning: 'Lunar mysteries. Tides of magic waxing and waning.' },
        { char: 'êåî', desc: 'S (Spell)', meaning: 'Woven enchantment. Words of power spoken into being.' }
      ],
      coptic: [
        { char: '‚≤Ä', desc: 'Alpha (Source)', meaning: 'Divine beginning. The eternal word spoken into creation.' },
        { char: '‚≤∞', desc: 'Omega (End)', meaning: 'Divine completion. All returns to the source of being.' },
        { char: '‚≤¨', desc: 'Chi (Christ)', meaning: 'Anointed light. Spiritual awakening and divine presence.' },
        { char: '‚≤†', desc: 'Pi (Spirit)', meaning: 'Holy pneuma. Breath of life and sacred inspiration.' },
        { char: '‚≤§', desc: 'Sophia (Wisdom)', meaning: 'Divine knowledge. Feminine aspect of cosmic intelligence.' },
        { char: '‚≤ò', desc: 'Maria (Mother)', meaning: 'Sacred femininity. Compassion and divine nurturing.' },
        { char: '‚≤ö', desc: 'Nous (Mind)', meaning: 'Divine intellect. Pure consciousness transcending thought.' },
        { char: '‚≤ñ', desc: 'Logos (Word)', meaning: 'Creative principle. Divine reason structuring reality.' },
        { char: '‚≤™', desc: 'Phos (Light)', meaning: 'Uncreated radiance. Illumination of spiritual truth.' },
        { char: '‚≤Ä‚≤Ö‚≤Å', desc: 'Agape (Love)', meaning: 'Divine love. Unconditional embrace of all existence.' },
        { char: '‚≤å', desc: 'Zoe (Life)', meaning: 'Eternal vitality. The animating force of creation.' }
      ],
      hebrew: [
        { char: '◊ê', desc: 'Aleph (Ox)', meaning: 'Primal strength and divine unity. Silent breath of creation.' },
        { char: '◊ë', desc: 'Bet (House)', meaning: 'Container of blessing. Divine dwelling and cosmic structure.' },
        { char: '◊í', desc: 'Gimel (Camel)', meaning: 'Loving-kindness flowing. Movement of divine generosity.' },
        { char: '◊ì', desc: 'Dalet (Door)', meaning: 'Humility and receptivity. Opening to divine wisdom.' },
        { char: '◊î', desc: 'Heh (Window)', meaning: 'Revelation and breath. Divine presence revealed in world.' },
        { char: '◊ï', desc: 'Vav (Hook)', meaning: 'Connection unifying opposites. The pillar joining heaven and earth.' },
        { char: '◊ô', desc: 'Yod (Hand)', meaning: 'Divine point of creation. The spark of infinite potential.' },
        { char: '◊ó', desc: 'Chet (Fence)', meaning: 'Transcendent life force. Boundary containing sacred energy.' },
        { char: '◊ò', desc: 'Tet (Serpent)', meaning: 'Hidden goodness. Coiled potential awaiting manifestation.' },
        { char: '◊õ', desc: 'Kaf (Palm)', meaning: 'Receiving and giving. Divine crown of manifestation.' },
        { char: '◊©', desc: 'Shin (Tooth)', meaning: 'Divine fire consuming. Three flames of eternal truth.' }
      ]
    };

    // Maintain backward compatibility
    const RUNIC_SYMBOLS = SCRIPT_SYMBOLS.runic;

    const ARCHETYPES = [
      { name: 'Lotus Petals', index: 0, meaning: 'Layered petal forms radiating from center, inspired by lotus flower geometry.' },
      { name: 'Sri Yantra', index: 1, meaning: 'Interlocking upward and downward triangles from Hindu sacred geometry.' },
      { name: 'Icosahedron Grid', index: 2, meaning: 'Connected vertices of a projected icosahedron, one of the Platonic solids.' },
      { name: 'Fibonacci Spiral', index: 3, meaning: 'Logarithmic spiral based on the golden ratio, found throughout nature.' }
    ];

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }
    
    function interpolateColor(color1, color2, factor) {
      const rgb1 = hexToRgb(color1);
      const rgb2 = hexToRgb(color2);
      const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * factor);
      const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * factor);
      const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * factor);
      return `rgb(${r},${g},${b})`;
    }

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // ====================================================================
    // 2. MANDALA PARAMETERS CLASS
    // ====================================================================

    class MandalaParams {
      constructor(name, dateStr, scriptType = 'runic', colorMode = 'elemental') {
        this.name = name;
        this.dateStr = dateStr;
        this.scriptType = scriptType;
        this.colorMode = colorMode;
        this.scriptMapping = SCRIPT_MAPPINGS[scriptType];
        this.runic = this.convertToScript(name, scriptType);
        this.seed = this.getNumericSeed(this.runic);
        this.rand = mulberry32(this.seed);
        this.elementData = this.getElementsFromDate(dateStr);
        this.params = this.generateParams();
      }

      convertToScript(text, scriptType = 'runic') {
        if (!text) return "";
        const mapping = SCRIPT_MAPPINGS[scriptType];
        if (!mapping) return text;

        let lower = text.toLowerCase();
        let result = "";
        for (let i = 0; i < lower.length; i++) {
          let char = lower[i];
          // Check for digraphs (only for runic)
          if (scriptType === 'runic' && i < lower.length - 1) {
            const digraph = lower.slice(i, i+2);
            if (mapping[digraph]) {
              result += mapping[digraph];
              i++; continue;
            }
          }
          result += mapping[char] || "";
        }
        return result;
      }

      getNumericSeed(str) {
        let hash = 0;
        if (!str || str.length === 0) return 123456789;
        for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash |= 0; 
        }
        return Math.abs(hash);
      }

      getElementsFromDate(dateStr) {
        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const year = date.getFullYear();
        const month = date.getMonth(); 
        const day = date.getDay();

        const yearDigit = year % 10;
        let yearElement;
        if (yearDigit === 4 || yearDigit === 9) yearElement = ELEMENTS.WOOD;
        else if (yearDigit === 5 || yearDigit === 0) yearElement = ELEMENTS.FIRE;
        else if (yearDigit === 6 || yearDigit === 1) yearElement = ELEMENTS.EARTH;
        else if (yearDigit === 7 || yearDigit === 2) yearElement = ELEMENTS.METAL;
        else yearElement = ELEMENTS.WATER;

        const monthElement = MONTH_ELEMENTS[month];
        let dayElement;
        if (day === 0) dayElement = ELEMENTS.EARTH; 
        else if (day === 1) dayElement = ELEMENTS.WATER; 
        else if (day === 2) dayElement = ELEMENTS.FIRE; 
        else if (day === 3) dayElement = ELEMENTS.WOOD; 
        else if (day === 4) dayElement = ELEMENTS.WATER; 
        else if (day === 5) dayElement = ELEMENTS.METAL; 
        else dayElement = ELEMENTS.FIRE;

        return { year: yearElement, month: monthElement, day: dayElement };
      }

      generateParams() {
        const rand = this.rand;
        const seed = this.seed;
        const randomnessFactor = (rand() - 0.5) * 0.05;

        // 1. Color Palette Synthesis
        let colorStrings;
        let accentColor;

        const colorModeData = COLOR_MODES[this.colorMode];

        if (colorModeData) {
          // Use predefined color mode
          const modeColors = [...colorModeData.colors];
          // Shuffle based on seed for variety
          modeColors.sort(() => rand() - 0.5);
          accentColor = colorModeData.accent;
          colorStrings = [
            modeColors[0],
            modeColors[1 % modeColors.length],
            accentColor,
            modeColors[2 % modeColors.length],
            modeColors[3 % modeColors.length]
          ];
        } else {
          // Default elemental mode
          const p = [...this.elementData.year.colors];
          const m = [...this.elementData.month.colors];
          const d = [...this.elementData.day.colors];
          let colorPool = [...p, ...m, ...d].sort(() => rand() - 0.5);

          // We use the Polished Brass accent for the bright glow/detail
          accentColor = "#C8AA6E";

          colorStrings = [
            colorPool[0] || p[0], // Primary color (Ring Base)
            colorPool[1] || m[0], // Secondary color (Inner Geometry)
            accentColor,          // Tertiary color (Primary Accent/Detail)
            colorPool[3] || p[1], // Accent 1 (Text/Center Fill)
            colorPool[4] || m[1]  // Accent 2 (Center outline/core)
          ];
        }

        // 2. Geometry Parameters
        const archetypeIndex = seed % ARCHETYPES.length; // Max is now 3
        const archetype = ARCHETYPES[archetypeIndex];

        let complexity = ((seed % 900) / 900) + 0.1;
        complexity = parseFloat((complexity + randomnessFactor).toFixed(2));
        complexity = Math.max(0.1, Math.min(1.0, complexity));

        const ringCountBase = 7 + Math.floor(complexity * 12);
        const ringCount = Math.max(5, ringCountBase + Math.floor(randomnessFactor * 10));

        const rings = [];
        for(let i=0; i<ringCount; i++) {
          rings.push({
            r: 0.1 + (i/ringCount)*0.9,
            style: Math.floor(rand() * 6), // Max ring style is now 5 (0-5)
            width: (1 + rand() * 4 * complexity) * (1 + randomnessFactor * 0.5),
            colorIndex: i % 3 // Cycle through the first three (including the brass accent)
          });
        }
        
        // 3. Symbol Selection (Bias towards elemental syllable)
        const symbolSet = SCRIPT_SYMBOLS[this.scriptType] || SCRIPT_SYMBOLS.runic;
        let symbolIndex = seed % symbolSet.length;
        const elementalSyllables = { METAL: 6, WATER: 10, WOOD: 7, FIRE: 8, EARTH: 9 };
        const yearKey = this.elementData.year.key;

        if (elementalSyllables[yearKey] !== undefined && rand() < 0.35 && symbolIndex < symbolSet.length) {
            symbolIndex = elementalSyllables[yearKey] % symbolSet.length;
        }

        // 4. Random Sacred Geometry Shapes
        // Types: 0=Icosahedron, 1=Star, 2=Cube, 3=Tetrahedron, 4=Octahedron,
        //        5=Dodecahedron, 6=Star Tetrahedron(Merkaba), 7=Metatron's Cube,
        //        8=Seed of Life, 9=Flower of Life
        const polyCount = rand() < 0.50 ? Math.floor(rand() * 4) + 1 : 0;
        const polyhedrons = [];
        for(let i=0; i<polyCount; i++) {
            polyhedrons.push({
                type: Math.floor(rand() * 10),
                radiusFactor: 0.3 + rand() * 0.6,
                color: accentColor, // Use the accent color for wireframes
                thickness: 0.8 + rand() * 3,
                rotationSpeed: (rand() - 0.5) * 0.08,
            });
        }

        return {
          seed, palette: colorStrings, archetype, complexity: complexity.toFixed(2),
          rings, symbolIndex, polyhedrons, solidRotation: rand() * Math.PI * 2,
          scriptFont: this.scriptMapping.font,
          scriptType: this.scriptType,
        };
      }
    }

    // ====================================================================
    // 3. MANDALA RENDERER CLASS
    // ====================================================================

    class MandalaRenderer {
      constructor(canvasId, fullscreenCanvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.fsCanvas = document.getElementById(fullscreenCanvasId);
        this.fsCtx = this.fsCanvas.getContext('2d');

        this.params = null;
        this.isAnimating = false;
        this.animationId = null;
        this.phase = 0;

        this.width = W;
        this.height = H;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.speed = 1.0;
        this.isBloom = false;
        this.bloomIntensity = 0.6;

        // Morphing system - 5 phases cycling through archetypes
        this.morphEnabled = true;
        this.morphPhase = 0;
        this.morphDuration = 120; // frames per transition
        this.morphCycleDuration = this.morphDuration * 5; // full cycle through all 5 phases
        this.sriYantraMode = 0; // 0=traditional, 1=breathing, 2=concentric

        this.icosaVertices = this.generateIcosahedronVertices();
        this.icosaEdges = this.generateIcosahedronEdges();
      }

      setParams(params) {
        this.params = params;
        this.drawInitialFrame(); // Ensure a static frame is drawn immediately
      }
      
      drawInitialFrame() {
        if (!this.params) return;
        this.drawFrame(this.ctx, this.width, this.height, this.phase);
      }

      toggleAnimation(state) {
        this.isAnimating = state;
        if (state) this.loop();
        else cancelAnimationFrame(this.animationId);
      }

      loop() {
        if (!this.isAnimating) return;
        this.phase += 0.01 * this.speed;

        // Advance morph phase for fluid transitions
        if (this.morphEnabled) {
          this.morphPhase = (this.morphPhase + this.speed) % this.morphCycleDuration;
        }

        const size = Math.min(this.canvas.width, this.canvas.height);
        this.drawFrame(this.ctx, size, size, this.phase);

        if (document.getElementById('fullscreen-overlay').classList.contains('active')) {
          const w = window.innerWidth;
          const h = window.innerHeight;
          this.fsCanvas.width = w;
          this.fsCanvas.height = h;
          this.drawFrame(this.fsCtx, w, h, this.phase);
        }

        this.animationId = requestAnimationFrame(this.loop.bind(this));
      }

      // Easing functions for smooth morphing
      easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
      }

      easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      // Organic breathing multiplier
      breathe(phase, rate = 1, amplitude = 0.1) {
        return 1 + Math.sin(phase * rate) * amplitude;
      }

      drawFrame(ctx, w, h, phase) {
        ctx.save();
        /* The canvas itself must remain dark for the glowing effect to work */
        ctx.fillStyle = '#080706'; 
        ctx.fillRect(0, 0, w, h);

        // --- 1. GLOW LAYER (Faint, broad blur) ---
        if (this.isBloom) {
          const blurSize1 = 15 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize1}px)`;
          ctx.globalAlpha = 0.4;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 2. CORE LAYER (Tighter, brighter blur) ---
        if (this.isBloom) {
          const blurSize2 = 5 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize2}px)`;
          ctx.globalAlpha = 0.6;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 3. DETAIL LAYER (Sharp, full color) ---
        ctx.filter = 'none';
        ctx.globalAlpha = 1.0;
        this.drawMandalaElements(ctx, w, h, phase, false);

        ctx.restore();
      }

      drawMandalaElements(ctx, w, h, phase, isGlowPass) {
        const cx = w / 2, cy = h / 2;
        const radius = Math.min(w, h) / 2 * 0.95;

        this.params.rings.forEach((ring, i) => {
          this.drawRing(ctx, cx, cy, radius * ring.r, ring, this.params, phase, i, isGlowPass);
        });

        this.params.polyhedrons.forEach(poly => {
          this.drawPolyhedron(ctx, cx, cy, radius * poly.radiusFactor, poly, phase, isGlowPass);
        });

        // Fluid morphing between 5 phases (4 archetypes + return to start)
        if (this.morphEnabled && this.isAnimating) {
          this.drawMorphingArchetypes(ctx, cx, cy, radius, phase, isGlowPass);
        } else {
          // Static mode - use seed-based archetype
          switch(this.params.archetype.index) {
            case 0: this.drawLotusPetals(ctx, cx, cy, radius * 0.6, this.params, phase, isGlowPass); break;
            case 1: this.drawSriYantra(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
            case 2: this.drawIcosahedronGrid(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
            case 3: this.drawFibonacciSpiral(ctx, cx, cy, radius * 0.8, this.params, phase, isGlowPass); break;
          }
        }

        this.drawCenterSyllable(ctx, cx, cy, radius * 0.1, this.params, phase, isGlowPass);
      }

      // Morphing system - blends between archetypes with organic transitions
      drawMorphingArchetypes(ctx, cx, cy, radius, phase, isGlowPass) {
        // Determine current position in morph cycle
        const cycleProgress = this.morphPhase / this.morphCycleDuration;
        const phaseIndex = Math.floor(cycleProgress * 5); // 0-4
        const phaseProgress = (cycleProgress * 5) % 1; // 0-1 within current phase

        // Smooth easing for transitions
        const easedProgress = this.easeInOutCubic(phaseProgress);

        // Archetype order: Lotus ‚Üí SriYantra ‚Üí Icosahedron ‚Üí Fibonacci ‚Üí Lotus (cycle)
        const archetypes = [
          { draw: (alpha, scale) => this.drawLotusPetals(ctx, cx, cy, radius * 0.6 * scale, this.params, phase, isGlowPass, alpha) },
          { draw: (alpha, scale) => this.drawSriYantra(ctx, cx, cy, radius * 0.7 * scale, this.params, phase, isGlowPass, alpha) },
          { draw: (alpha, scale) => this.drawIcosahedronGrid(ctx, cx, cy, radius * 0.7 * scale, this.params, phase, isGlowPass, alpha) },
          { draw: (alpha, scale) => this.drawFibonacciSpiral(ctx, cx, cy, radius * 0.8 * scale, this.params, phase, isGlowPass, alpha) },
        ];

        const currentIndex = phaseIndex % 4;
        const nextIndex = (phaseIndex + 1) % 4;

        // Organic scale breathing during transitions
        const breatheScale = this.breathe(phase, 2, 0.05);
        const transitionScale = 1 - Math.sin(easedProgress * Math.PI) * 0.1; // Slight shrink at midpoint

        // Calculate blend alphas - crossfade with overlap
        const fadeOutAlpha = Math.cos(easedProgress * Math.PI / 2); // 1 ‚Üí 0
        const fadeInAlpha = Math.sin(easedProgress * Math.PI / 2);  // 0 ‚Üí 1

        // Draw outgoing archetype (fading out)
        ctx.save();
        ctx.globalAlpha = (isGlowPass ? 0.6 : 1) * fadeOutAlpha;
        const outScale = breatheScale * (1 + (1 - easedProgress) * 0.05);
        archetypes[currentIndex].draw(fadeOutAlpha, outScale);
        ctx.restore();

        // Draw incoming archetype (fading in)
        ctx.save();
        ctx.globalAlpha = (isGlowPass ? 0.6 : 1) * fadeInAlpha;
        const inScale = breatheScale * transitionScale * (0.9 + easedProgress * 0.1);
        archetypes[nextIndex].draw(fadeInAlpha, inScale);
        ctx.restore();
      }

      drawRing(ctx, cx, cy, r, ring, params, phase, idx, isGlowPass) {
        const color1 = params.palette[ring.colorIndex];
        const color2 = params.palette[(ring.colorIndex + 1) % 3];
        const factor = (r / (H / 2 * 0.95) + Math.sin(phase * 0.5) * 0.5 + 0.5) % 1;
        const interpolatedColor = interpolateColor(color1, color2, factor);
        
        ctx.strokeStyle = interpolatedColor;
        ctx.lineWidth = ring.width;
        ctx.beginPath();
        
        if (isGlowPass || ring.style === 0) { 
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
          return;
        }

        const complexityFactor = parseFloat(params.complexity) * 0.5;

        if (ring.style === 1) { 
          const dots = 36 + Math.floor(complexityFactor * 40);
          for(let i=0; i<dots; i++) {
            const a = (i/dots)*Math.PI*2 + phase*(idx%2?0.1:-0.1);
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.moveTo(x, y);
            ctx.arc(x, y, ring.width*1.5, 0, Math.PI*2);
          }
          ctx.fillStyle=interpolatedColor;
          ctx.fill();
        } else if (ring.style === 4) { 
            ctx.setLineDash([ring.width * 2, ring.width * 2]);
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]); 
        } else if (ring.style === 2) { 
          ctx.arc(cx, cy, r - ring.width/2, 0, Math.PI*2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx, cy, r + ring.width/2, 0, Math.PI*2);
          ctx.stroke();
        } else if (ring.style === 3) {
          const symbolSet = SCRIPT_SYMBOLS[params.scriptType] || SCRIPT_SYMBOLS.runic;
          const symbol = symbolSet[params.symbolIndex % symbolSet.length].char;
          const count = 15 + Math.floor(complexityFactor * 15);
          const scriptFont = params.scriptFont || "'Segoe UI Symbol', sans-serif";
          ctx.font = `${ring.width * 5}px ${scriptFont}`;
          ctx.fillStyle = interpolatedColor;
          for(let i=0; i<count; i++) {
            const a = (i/count)*Math.PI*2 + phase*0.1;
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(a + Math.PI/2);
            ctx.fillText(symbol, 0, 0);
            ctx.restore();
          }
        } else if (ring.style === 5) { // Undulating Wave
          const points = 360;
          // Frequency scales with complexity, offset by rotation phase
          const frequency = 8 + complexityFactor * 20; 
          const amplitude = ring.width * 2; 

          ctx.beginPath();
          for(let i=0; i<=points; i++) {
            const a = (i/points)*Math.PI*2;
            const displacement = Math.sin(a * frequency + phase * 4) * amplitude;
            const currentR = r + displacement;
            const x = cx + Math.cos(a)*currentR;
            const y = cy + Math.sin(a)*currentR;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        }
      }

      drawCenterSyllable(ctx, cx, cy, r, params, phase, isGlowPass) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fillStyle = params.palette[3];
        ctx.fill();
        ctx.strokeStyle = params.palette[4];
        ctx.lineWidth = 2;
        ctx.stroke();

        if (isGlowPass) return;

        const symbolSet = SCRIPT_SYMBOLS[params.scriptType] || SCRIPT_SYMBOLS.runic;
        const symbolData = symbolSet[params.symbolIndex % symbolSet.length];
        ctx.fillStyle = params.palette[2]; // Use Brass Accent
        const scriptFont = params.scriptFont || "'Segoe UI Symbol', sans-serif";
        ctx.font = `${r*0.8}px ${scriptFont}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbolData.char, cx, cy);
      }
      
      drawLotusPetals(ctx, cx, cy, r, params, phase, isGlowPass, alpha = 1) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(phase * 0.008);

        const complexity = parseFloat(params.complexity);
        const layers = 2 + Math.floor(complexity * 2);

        for (let layer = layers - 1; layer >= 0; layer--) {
          // Organic breathing per layer
          const breathe = 1 + Math.sin(phase * 0.3 + layer * 0.7) * 0.05;
          const layerRadius = r * (0.4 + layer * 0.3) * breathe;
          const petalCount = 6 + layer * 2 + Math.floor(complexity * 3);

          // Petals stretch and contract organically
          const petalBreathe = 1 + Math.sin(phase * 0.4 + layer) * 0.08;
          const petalLength = layerRadius * (0.5 + complexity * 0.2) * petalBreathe;
          const petalWidth = petalLength * (0.3 + layer * 0.05);

          // Layer rotation with organic drift
          const drift = Math.sin(phase * 0.15 + layer * 2) * 0.05;
          const layerRotation = (layer * Math.PI / petalCount) + phase * 0.003 * (layer % 2 ? 1 : -1) + drift;

          for (let i = 0; i < petalCount; i++) {
            // Individual petal breathing
            const petalPulse = 1 + Math.sin(phase * 0.5 + i * 0.3 + layer) * 0.03;
            const angle = (i / petalCount) * Math.PI * 2 + layerRotation;

            ctx.save();
            ctx.rotate(angle);
            ctx.translate(layerRadius * 0.3, 0);

            const colorIndex = (layer + i) % 3;
            const nextColorIndex = (colorIndex + 1) % 3;
            const colorFactor = (Math.sin(phase * 0.5 + i) + 1) / 2;

            ctx.fillStyle = interpolateColor(params.palette[colorIndex], params.palette[nextColorIndex], colorFactor);
            ctx.strokeStyle = params.palette[4];
            ctx.lineWidth = isGlowPass ? 4 : 1.5;

            const pLen = petalLength * petalPulse;
            const pWid = petalWidth * petalPulse;

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(
              pLen * 0.3, -pWid * 0.6,
              pLen * 0.7, -pWid * 0.8,
              pLen, 0
            );
            ctx.bezierCurveTo(
              pLen * 0.7, pWid * 0.8,
              pLen * 0.3, pWid * 0.6,
              0, 0
            );
            ctx.closePath();

            if (!isGlowPass) {
              ctx.globalAlpha = (0.6 + layer * 0.1) * alpha;
              ctx.fill();
              ctx.globalAlpha = alpha;
            }
            ctx.stroke();

            ctx.restore();
          }
        }
        ctx.restore();
      }

      // Enhanced Sri Yantra with multiple modes
      drawSriYantra(ctx, cx, cy, r, params, phase, isGlowPass, alpha = 1) {
        // Cycle through Sri Yantra modes based on phase
        const modePhase = (phase * 0.1) % 3;
        const mode = Math.floor(modePhase);
        const modeBlend = modePhase % 1;

        ctx.save();
        ctx.translate(cx, cy);

        // Draw current mode with blend to next
        if (modeBlend < 0.8) {
          this.drawSriYantraMode(ctx, r, params, phase, isGlowPass, mode, 1);
        } else {
          // Crossfade between modes
          const fadeProgress = (modeBlend - 0.8) / 0.2;
          this.drawSriYantraMode(ctx, r, params, phase, isGlowPass, mode, 1 - fadeProgress * 0.5);
          this.drawSriYantraMode(ctx, r, params, phase, isGlowPass, (mode + 1) % 3, fadeProgress * 0.5);
        }

        ctx.restore();
      }

      drawSriYantraMode(ctx, r, params, phase, isGlowPass, mode, alpha) {
        ctx.globalAlpha *= alpha;

        switch(mode) {
          case 0: this.drawSriYantraTraditional(ctx, r, params, phase, isGlowPass); break;
          case 1: this.drawSriYantraBreathing(ctx, r, params, phase, isGlowPass); break;
          case 2: this.drawSriYantraConcentric(ctx, r, params, phase, isGlowPass); break;
        }
      }

      // Mode 0: Traditional Sri Yantra - 9 interlocking triangles (4 up, 5 down)
      drawSriYantraTraditional(ctx, r, params, phase, isGlowPass) {
        const rotation = params.solidRotation + phase * 0.003;

        // Traditional Sri Yantra has specific triangle positions
        // 4 upward-pointing triangles (Shiva/masculine)
        // 5 downward-pointing triangles (Shakti/feminine)

        const upTriangles = [
          { scale: 0.95, offset: 0 },
          { scale: 0.75, offset: 0.02 },
          { scale: 0.55, offset: 0.04 },
          { scale: 0.35, offset: 0.06 },
        ];

        const downTriangles = [
          { scale: 0.90, offset: 0 },
          { scale: 0.70, offset: 0.015 },
          { scale: 0.50, offset: 0.03 },
          { scale: 0.32, offset: 0.045 },
          { scale: 0.18, offset: 0.06 },
        ];

        // Draw outer boundary circle
        ctx.strokeStyle = params.palette[4];
        ctx.lineWidth = isGlowPass ? 4 : 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();

        // Draw downward triangles (Shakti) - drawn first
        downTriangles.forEach((tri, i) => {
          const breathe = 1 + Math.sin(phase * 0.5 + i * 0.5) * 0.02;
          const size = r * tri.scale * breathe;
          ctx.strokeStyle = interpolateColor(params.palette[1], params.palette[3], i / downTriangles.length);
          ctx.lineWidth = isGlowPass ? 5 : (2.5 - i * 0.3);

          ctx.beginPath();
          // Downward triangle (apex at bottom)
          const angle = Math.PI / 2 + rotation + tri.offset; // Point down
          ctx.moveTo(Math.cos(angle) * size, Math.sin(angle) * size);
          ctx.lineTo(Math.cos(angle + 2 * Math.PI / 3) * size, Math.sin(angle + 2 * Math.PI / 3) * size);
          ctx.lineTo(Math.cos(angle + 4 * Math.PI / 3) * size, Math.sin(angle + 4 * Math.PI / 3) * size);
          ctx.closePath();
          ctx.stroke();
        });

        // Draw upward triangles (Shiva) - drawn on top
        upTriangles.forEach((tri, i) => {
          const breathe = 1 + Math.sin(phase * 0.5 + i * 0.5 + Math.PI) * 0.02;
          const size = r * tri.scale * breathe;
          ctx.strokeStyle = interpolateColor(params.palette[2], params.palette[4], i / upTriangles.length);
          ctx.lineWidth = isGlowPass ? 5 : (2.5 - i * 0.3);

          ctx.beginPath();
          // Upward triangle (apex at top)
          const angle = -Math.PI / 2 + rotation - tri.offset; // Point up
          ctx.moveTo(Math.cos(angle) * size, Math.sin(angle) * size);
          ctx.lineTo(Math.cos(angle + 2 * Math.PI / 3) * size, Math.sin(angle + 2 * Math.PI / 3) * size);
          ctx.lineTo(Math.cos(angle + 4 * Math.PI / 3) * size, Math.sin(angle + 4 * Math.PI / 3) * size);
          ctx.closePath();
          ctx.stroke();
        });

        // Central bindu (point of creation)
        if (!isGlowPass) {
          ctx.fillStyle = params.palette[2];
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.04, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Mode 1: Breathing Sri Yantra - pulsating with organic movement
      drawSriYantraBreathing(ctx, r, params, phase, isGlowPass) {
        const layers = 7;

        for (let i = 0; i < layers; i++) {
          // Each layer breathes at different rates
          const breatheRate = 0.3 + i * 0.1;
          const breatheAmount = 0.08 - i * 0.008;
          const breathe = 1 + Math.sin(phase * breatheRate + i * Math.PI / 4) * breatheAmount;

          const layerScale = 0.15 + (i / layers) * 0.8;
          const size = r * layerScale * breathe;

          // Rotation varies per layer with organic drift
          const drift = Math.sin(phase * 0.2 + i) * 0.1;
          const rotation = params.solidRotation + phase * 0.005 * (i % 2 ? 1 : -1) + drift;

          // Color morphing
          const colorPhase = (phase * 0.1 + i * 0.2) % 1;
          const color1 = params.palette[i % 3];
          const color2 = params.palette[(i + 1) % 3];
          ctx.strokeStyle = interpolateColor(color1, color2, colorPhase);
          ctx.lineWidth = isGlowPass ? 6 : (3 - i * 0.3);

          // Alternate up/down triangles with warping
          const isUp = i % 2 === 0;
          const baseAngle = isUp ? -Math.PI / 2 : Math.PI / 2;

          ctx.beginPath();
          for (let v = 0; v <= 3; v++) {
            const angle = baseAngle + rotation + (v * 2 * Math.PI / 3);
            // Add organic warping to vertices
            const warp = 1 + Math.sin(phase * 0.8 + v * 2 + i) * 0.03;
            const x = Math.cos(angle) * size * warp;
            const y = Math.sin(angle) * size * warp;
            if (v === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        }

        // Pulsating central bindu
        if (!isGlowPass) {
          const binduPulse = 1 + Math.sin(phase * 0.8) * 0.3;
          ctx.fillStyle = params.palette[2];
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.05 * binduPulse, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Mode 2: Concentric Sri Yantra - nested with continuous rotation
      drawSriYantraConcentric(ctx, r, params, phase, isGlowPass) {
        const depth = 5 + Math.floor(parseFloat(params.complexity) * 4);
        let currentSize = r * 0.9;
        let currentRotation = params.solidRotation + phase * 0.005;

        // Outer lotus petal hints
        ctx.strokeStyle = params.palette[4];
        ctx.lineWidth = isGlowPass ? 3 : 1;
        for (let p = 0; p < 16; p++) {
          const angle = (p / 16) * Math.PI * 2 + phase * 0.01;
          const innerR = r * 0.92;
          const outerR = r * 0.98;
          ctx.beginPath();
          ctx.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR);
          ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
          ctx.stroke();
        }

        for(let i = 0; i < depth; i++) {
          // Organic breathing per layer
          const breathe = 1 + Math.sin(phase * 0.4 + i * 0.8) * 0.03;
          const size = currentSize * breathe;

          const color = i % 2 === 0 ? params.palette[1] : params.palette[2];
          ctx.strokeStyle = color;
          ctx.lineWidth = isGlowPass ? 5 : (2 + (depth - i) * 0.5);

          this.drawTriangle(ctx, currentRotation, size);

          currentRotation += Math.PI / 3;
          ctx.strokeStyle = i % 2 === 0 ? params.palette[4] : params.palette[3];
          this.drawTriangle(ctx, currentRotation, size);

          currentRotation -= Math.PI / 3;
          currentSize *= 0.72;
          currentRotation += phase * 0.008;
        }

        // Central bindu with glow
        if (!isGlowPass) {
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 0.08);
          gradient.addColorStop(0, params.palette[2]);
          gradient.addColorStop(1, 'transparent');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.08, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      drawTriangle(ctx, angle, size) {
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * size, Math.sin(angle) * size);
        ctx.lineTo(Math.cos(angle + 2 * Math.PI / 3) * size, Math.sin(angle + 2 * Math.PI / 3) * size);
        ctx.lineTo(Math.cos(angle + 4 * Math.PI / 3) * size, Math.sin(angle + 4 * Math.PI / 3) * size);
        ctx.closePath();
        ctx.stroke();
      }

      drawIcosahedronGrid(ctx, cx, cy, r, params, phase, isGlowPass, alpha = 1) {
        if (isGlowPass) return;

        // Organic breathing
        const breathe = 1 + Math.sin(phase * 0.25) * 0.06;
        const radius = r * 0.9 * breathe;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.globalAlpha *= alpha;
        ctx.rotate(params.solidRotation + phase * 0.005);

        const goldenRatio = (1 + Math.sqrt(5)) / 2;
        const vertexPositions = [];
        const offsetAngle = phase * 0.05;

        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          // Add organic wobble to each vertex
          const wobble1 = 1 + Math.sin(phase * 0.3 + i) * 0.04;
          const wobble2 = 1 + Math.sin(phase * 0.3 + i + Math.PI) * 0.04;
          vertexPositions.push({
            x: radius * Math.cos(angle + offsetAngle) / goldenRatio * wobble1,
            y: radius * Math.sin(angle + offsetAngle) / goldenRatio * wobble1
          });
          vertexPositions.push({
            x: radius * Math.cos(angle - offsetAngle + Math.PI/6) / goldenRatio * wobble2,
            y: radius * Math.sin(angle - offsetAngle + Math.PI/6) / goldenRatio * wobble2
          });
        }

        // Draw edges with pulsing opacity
        for (let i = 0; i < 12; i++) {
          for (let j = i + 1; j < 12; j++) {
            const p1 = vertexPositions[i];
            const p2 = vertexPositions[j];
            const distSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
            if (distSq < (radius * 0.7) ** 2) {
              // Edge opacity pulses based on position
              const edgePulse = 0.5 + Math.sin(phase * 0.4 + i + j) * 0.5;
              ctx.strokeStyle = interpolateColor(params.palette[2], params.palette[1], edgePulse);
              ctx.lineWidth = 1 + edgePulse;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          }
        }

        // Draw vertices with pulsing size
        vertexPositions.forEach((p, i) => {
          const vertexPulse = 1 + Math.sin(phase * 0.6 + i * 0.5) * 0.4;
          ctx.fillStyle = params.palette[4];
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4 * vertexPulse, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.restore();
      }
      
      drawFibonacciSpiral(ctx, cx, cy, r, params, phase, isGlowPass, alpha = 1) {
          ctx.save();
          ctx.translate(cx, cy);
          ctx.globalAlpha *= alpha;

          // Organic breathing affects the whole spiral
          const breathe = 1 + Math.sin(phase * 0.2) * 0.08;
          const breatheR = r * breathe;

          ctx.rotate(params.solidRotation + phase * 0.05);

          const segments = 20 + Math.floor(parseFloat(params.complexity) * 20);
          const goldenRatio = (1 + Math.sqrt(5)) / 2;

          // Draw multiple interleaved spirals for organic effect
          const spiralCount = 3;
          for (let s = 0; s < spiralCount; s++) {
            const spiralOffset = (s / spiralCount) * Math.PI * 2;
            const spiralBreathe = 1 + Math.sin(phase * 0.3 + s * 2) * 0.05;

            // Color varies per spiral arm
            const colorFactor = (Math.sin(phase * 0.2 + s) + 1) / 2;
            ctx.strokeStyle = interpolateColor(params.palette[1], params.palette[2], colorFactor);
            ctx.lineWidth = isGlowPass ? 4 : (2 - s * 0.3);

            let a = 0.5 * spiralBreathe;
            let angle = spiralOffset;

            ctx.beginPath();
            for(let i = 0; i < segments; i++) {
                // Organic wobble in the spiral
                const wobble = 1 + Math.sin(phase * 0.5 + i * 0.2 + s) * 0.03;
                let currentR = a * Math.exp(0.12 * angle) * wobble;
                if (currentR > breatheR) break;

                const x = Math.cos(angle) * currentR;
                const y = Math.sin(angle) * currentR;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);

                angle += Math.PI * 2 / goldenRatio;

                // Draw pulsing markers
                if (!isGlowPass && i % 4 === 0 && s === 0) {
                    const markerPulse = 1 + Math.sin(phase * 0.8 + i) * 0.5;
                    ctx.fillStyle = params.palette[2];
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x, y, (2 + parseFloat(params.complexity) * 2) * markerPulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                }
            }
            ctx.stroke();
          }

          // Central pulsing core
          if (!isGlowPass) {
            const corePulse = 1 + Math.sin(phase * 0.6) * 0.3;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, breatheR * 0.1 * corePulse);
            gradient.addColorStop(0, params.palette[2]);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, breatheR * 0.1 * corePulse, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
      }

      generateIcosahedronVertices() {
        const phi = (1 + Math.sqrt(5)) / 2;
        const s = 1.0;
        return [
          [0, s, phi*s], [0, -s, phi*s], [0, s, -phi*s], [0, -s, -phi*s],
          [s, phi*s, 0], [-s, phi*s, 0], [s, -phi*s, 0], [-s, -phi*s, 0],
          [phi*s, 0, s], [-phi*s, 0, s], [phi*s, 0, -s], [-phi*s, 0, -s]
        ];
      }

      generateIcosahedronEdges() {
        const edges = [];
        const n = this.icosaVertices.length;
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const p1 = this.icosaVertices[i];
                const p2 = this.icosaVertices[j];
                const distSq = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
                if (distSq < 4.1) { 
                    edges.push([i, j]);
                }
            }
        }
        return edges;
      }

      drawPolyhedron(ctx, cx, cy, r, poly, phase, isGlowPass) {
        if (isGlowPass) return;

        ctx.save();
        ctx.translate(cx, cy);

        const angle = phase * poly.rotationSpeed * 5;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const rotateX = ([x, y, z]) => [x, y * cos - z * sin, y * sin + z * cos];
        const rotateY = ([x, y, z]) => [x * cos - z * sin, y, x * sin + z * cos];

        // 2D Sacred Geometry shapes (types 7-9)
        if (poly.type >= 7) {
          ctx.strokeStyle = poly.color;
          ctx.lineWidth = poly.thickness;
          ctx.rotate(angle * 0.2);

          if (poly.type === 7) {
            this.drawMetatronsCube(ctx, r);
          } else if (poly.type === 8) {
            this.drawSeedOfLife(ctx, r);
          } else if (poly.type === 9) {
            this.drawFlowerOfLife(ctx, r);
          }
          ctx.restore();
          return;
        }

        let vertices = this.icosaVertices;
        let edges = this.icosaEdges;
        let scaleFactor = r * 0.2;

        if (poly.type === 0) {}
        else if (poly.type === 1) {
            this.drawStar(ctx, r, 5, 0.4);
            ctx.strokeStyle = poly.color;
            ctx.lineWidth = poly.thickness;
            ctx.stroke();
            ctx.restore();
            return;
        } else if (poly.type === 2) {
            vertices = [
                [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
                [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1]
            ];
            edges = [
                [0,1],[1,2],[2,3],[3,0],
                [4,5],[5,6],[6,7],[7,4],
                [0,4],[1,5],[2,6],[3,7]
            ];
            scaleFactor = r * 0.4;
        } else if (poly.type === 3) {
            const h = 1 / Math.sqrt(3);
            vertices = [
                [0, 0, 1.5],
                [1, 0, -h],
                [-0.5, Math.sqrt(3)/2, -h],
                [-0.5, -Math.sqrt(3)/2, -h]
            ];
            edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
            scaleFactor = r * 0.4;
        } else if (poly.type === 4) {
            // Octahedron
            vertices = [
                [1, 0, 0], [-1, 0, 0],
                [0, 1, 0], [0, -1, 0],
                [0, 0, 1], [0, 0, -1]
            ];
            edges = [
                [0,2],[0,3],[0,4],[0,5],
                [1,2],[1,3],[1,4],[1,5],
                [2,4],[2,5],[3,4],[3,5]
            ];
            scaleFactor = r * 0.5;
        } else if (poly.type === 5) {
            // Dodecahedron
            const phi = (1 + Math.sqrt(5)) / 2;
            const invPhi = 1 / phi;
            vertices = [
                [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],
                [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],
                [0,phi,invPhi], [0,phi,-invPhi], [0,-phi,invPhi], [0,-phi,-invPhi],
                [invPhi,0,phi], [invPhi,0,-phi], [-invPhi,0,phi], [-invPhi,0,-phi],
                [phi,invPhi,0], [phi,-invPhi,0], [-phi,invPhi,0], [-phi,-invPhi,0]
            ];
            edges = [
                [0,8],[0,12],[0,16],[1,9],[1,13],[1,16],[2,10],[2,12],[2,17],
                [3,11],[3,13],[3,17],[4,8],[4,14],[4,18],[5,9],[5,15],[5,18],
                [6,10],[6,14],[6,19],[7,11],[7,15],[7,19],[8,9],[10,11],[12,14],
                [13,15],[16,17],[18,19]
            ];
            scaleFactor = r * 0.3;
        } else if (poly.type === 6) {
            // Star Tetrahedron (Merkaba) - two interlocking tetrahedra
            const h = 1 / Math.sqrt(3);
            const tetra1 = [
                [0, 0, 1.2], [1, 0, -h], [-0.5, Math.sqrt(3)/2, -h], [-0.5, -Math.sqrt(3)/2, -h]
            ];
            const tetra2 = [
                [0, 0, -1.2], [-1, 0, h], [0.5, -Math.sqrt(3)/2, h], [0.5, Math.sqrt(3)/2, h]
            ];
            vertices = [...tetra1, ...tetra2];
            edges = [
                [0,1],[0,2],[0,3],[1,2],[2,3],[3,1],
                [4,5],[4,6],[4,7],[5,6],[6,7],[7,5]
            ];
            scaleFactor = r * 0.45;
        }

        const projected = vertices.map(v => {
            let v_rotated = rotateY(rotateX(v));
            const z = v_rotated[2] * scaleFactor;
            const x = v_rotated[0] * scaleFactor;
            const y = v_rotated[1] * scaleFactor;
            return { x, y, z };
        });

        ctx.strokeStyle = poly.color;
        ctx.lineWidth = poly.thickness;

        edges.forEach(([i, j]) => {
            const v1 = projected[i];
            const v2 = projected[j];
            if (v1 && v2) {
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
            }
        });

        ctx.restore();
      }

      drawMetatronsCube(ctx, r) {
        // Draw 13 circles (1 center + 6 inner + 6 outer)
        const innerRadius = r * 0.3;
        const outerRadius = r * 0.6;
        const circleSize = r * 0.18;

        // Center circle
        ctx.beginPath();
        ctx.arc(0, 0, circleSize, 0, Math.PI * 2);
        ctx.stroke();

        // Inner 6 circles
        const innerCircles = [];
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const x = Math.cos(angle) * innerRadius;
          const y = Math.sin(angle) * innerRadius;
          innerCircles.push({x, y});
          ctx.beginPath();
          ctx.arc(x, y, circleSize, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Outer 6 circles
        const outerCircles = [];
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
          const x = Math.cos(angle) * outerRadius;
          const y = Math.sin(angle) * outerRadius;
          outerCircles.push({x, y});
          ctx.beginPath();
          ctx.arc(x, y, circleSize, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Connect all 13 points with lines
        const allPoints = [{x: 0, y: 0}, ...innerCircles, ...outerCircles];
        for (let i = 0; i < allPoints.length; i++) {
          for (let j = i + 1; j < allPoints.length; j++) {
            ctx.beginPath();
            ctx.moveTo(allPoints[i].x, allPoints[i].y);
            ctx.lineTo(allPoints[j].x, allPoints[j].y);
            ctx.stroke();
          }
        }
      }

      drawSeedOfLife(ctx, r) {
        const circleRadius = r * 0.35;

        // Center circle
        ctx.beginPath();
        ctx.arc(0, 0, circleRadius, 0, Math.PI * 2);
        ctx.stroke();

        // 6 surrounding circles
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const x = Math.cos(angle) * circleRadius;
          const y = Math.sin(angle) * circleRadius;
          ctx.beginPath();
          ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      drawFlowerOfLife(ctx, r) {
        const circleRadius = r * 0.2;
        const drawn = new Set();

        const drawCircleAt = (x, y) => {
          const key = `${Math.round(x*100)},${Math.round(y*100)}`;
          if (drawn.has(key)) return;
          if (Math.sqrt(x*x + y*y) > r * 0.95) return;
          drawn.add(key);
          ctx.beginPath();
          ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
          ctx.stroke();
        };

        // Center
        drawCircleAt(0, 0);

        // First ring (6 circles)
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          drawCircleAt(Math.cos(angle) * circleRadius, Math.sin(angle) * circleRadius);
        }

        // Second ring (12 circles)
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          drawCircleAt(Math.cos(angle) * circleRadius * 2, Math.sin(angle) * circleRadius * 2);
          const angle2 = angle + Math.PI / 6;
          drawCircleAt(Math.cos(angle2) * circleRadius * Math.sqrt(3), Math.sin(angle2) * circleRadius * Math.sqrt(3));
        }

        // Third ring
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          drawCircleAt(Math.cos(angle) * circleRadius * 3, Math.sin(angle) * circleRadius * 3);
          const angle2 = angle + Math.PI / 6;
          drawCircleAt(Math.cos(angle2) * circleRadius * Math.sqrt(3) * 2, Math.sin(angle2) * circleRadius * Math.sqrt(3) * 2);
          // Fill in gaps
          const angle3 = angle + Math.PI / 12;
          drawCircleAt(Math.cos(angle3) * circleRadius * 2.5, Math.sin(angle3) * circleRadius * 2.5);
          const angle4 = angle - Math.PI / 12;
          drawCircleAt(Math.cos(angle4) * circleRadius * 2.5, Math.sin(angle4) * circleRadius * 2.5);
        }
      }

      drawStar(ctx, r, points, innerRatio) {
          ctx.beginPath();
          for (let i = 0; i < points * 2; i++) {
              const radius = i % 2 === 0 ? r : r * innerRatio;
              const angle = (i / (points * 2)) * Math.PI * 2;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
          }
          ctx.closePath();
      }
    }


    // ====================================================================
    // 4. AUDIO ENGINE CLASS - Enhanced with Modulation Controls
    // ====================================================================

    class AudioEngine {
      constructor() {
        this.audioCtx = null;
        this.masterGain = null;
        this.leftOsc = null;
        this.rightOsc = null;
        this.leftPan = null;
        this.rightPan = null;
        this.isAudioPlaying = false;

        // Modulation nodes
        this.panLFO = null;
        this.panLFOGain = null;
        this.filter = null;

        // Harmonic oscillators (overtones)
        this.harmonicOscs = [];
        this.harmonicGain = null;

        // Interval oscillator
        this.intervalOsc = null;
        this.intervalGain = null;

        // Reverb
        this.reverbNode = null;
        this.reverbGain = null;
        this.dryGain = null;

        // Isochronic tones
        this.isochronicLFO = null;
        this.isochronicGain = null;
        this.isochronicDepth = 0;

        // Amplitude modulation
        this.amLFO = null;
        this.amGain = null;
        this.amDepth = 0;

        // Bass kick drum
        this.kickGain = null;
        this.kickPlaying = false;
        this.kickBPM = 60;
        this.kickPitch = 50;
        this.kickDecay = 0.15;
        this.kickPunch = 0.5;
        this.kickVolume = 0.5;
        this.kickIntervalId = null;

        this.computedCarrier = 0;
        this.computedBeat = 0;
        this.currentElementData = null;
        this.currentWaveform = 'sine';
        this.currentDetune = 0;
        this.manualWaveform = 'auto';
        this.currentInterval = 0;
      }

      initAudioIfNeeded(volume) {
        if (this.audioCtx) return;
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Create filter node (lowpass)
        this.filter = this.audioCtx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 4000;
        this.filter.Q.value = 0.7;

        // Dry/Wet mixing for reverb
        this.dryGain = this.audioCtx.createGain();
        this.dryGain.gain.value = 1.0;

        this.reverbGain = this.audioCtx.createGain();
        this.reverbGain.gain.value = 0.0;

        // Create simple reverb using multiple delays
        this.reverbNode = this.createSimpleReverb();

        // Master gain
        this.masterGain = this.audioCtx.createGain();
        this.masterGain.gain.value = volume || 0.06;

        // Main oscillators
        this.leftOsc = this.audioCtx.createOscillator();
        this.leftOsc.type = this.currentWaveform;
        this.leftPan = this.audioCtx.createStereoPanner();
        this.leftPan.pan.value = -1;

        this.rightOsc = this.audioCtx.createOscillator();
        this.rightOsc.type = this.currentWaveform;
        this.rightPan = this.audioCtx.createStereoPanner();
        this.rightPan.pan.value = 1;

        // Harmonic overtones gain
        this.harmonicGain = this.audioCtx.createGain();
        this.harmonicGain.gain.value = 0;

        // Create harmonic oscillators (2nd, 3rd, 5th partials)
        [2, 3, 5].forEach((mult, i) => {
          const osc = this.audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = 100 * mult;
          const gain = this.audioCtx.createGain();
          gain.gain.value = 1 / (mult * 1.5);
          osc.connect(gain);
          gain.connect(this.harmonicGain);
          osc.start();
          this.harmonicOscs.push({ osc, gain, multiplier: mult });
        });

        // Interval oscillator (musical intervals above base)
        this.intervalOsc = this.audioCtx.createOscillator();
        this.intervalOsc.type = this.currentWaveform;
        this.intervalOsc.frequency.value = 100;
        this.intervalGain = this.audioCtx.createGain();
        this.intervalGain.gain.value = 0;
        this.intervalOsc.connect(this.intervalGain);
        this.intervalGain.connect(this.filter);
        this.intervalOsc.start();

        // Signal chain: Oscillators -> Panners -> Filter -> Dry/Reverb -> Master -> Destination
        this.leftOsc.connect(this.leftPan);
        this.leftPan.connect(this.filter);
        this.rightOsc.connect(this.rightPan);
        this.rightPan.connect(this.filter);
        this.harmonicGain.connect(this.filter);

        // Split to dry and wet paths
        this.filter.connect(this.dryGain);
        this.filter.connect(this.reverbNode.input);
        this.reverbNode.connect(this.reverbGain);

        this.dryGain.connect(this.masterGain);
        this.reverbGain.connect(this.masterGain);
        this.masterGain.connect(this.audioCtx.destination);

        this.leftOsc.start();
        this.rightOsc.start();
        this.isAudioPlaying = false;

        // Panning LFO (spatial drift) - intensified
        this.panLFO = this.audioCtx.createOscillator();
        this.panLFO.type = 'sine';
        this.panLFO.frequency.setValueAtTime(0.1, this.audioCtx.currentTime);

        this.panLFOGain = this.audioCtx.createGain();
        this.panLFOGain.gain.setValueAtTime(0.8, this.audioCtx.currentTime);

        this.panLFO.connect(this.panLFOGain);
        this.panLFOGain.connect(this.leftPan.pan);
        this.panLFOGain.connect(this.rightPan.pan);

        this.panLFO.start(0);

        // Isochronic tone generator (sharp on/off pulsing)
        this.isochronicLFO = this.audioCtx.createOscillator();
        this.isochronicLFO.type = 'square';
        this.isochronicLFO.frequency.setValueAtTime(this.computedBeat || 6, this.audioCtx.currentTime);

        this.isochronicGain = this.audioCtx.createGain();
        this.isochronicGain.gain.setValueAtTime(0, this.audioCtx.currentTime);

        // Isochronic modulates the master gain
        this.isochronicLFO.connect(this.isochronicGain);
        this.isochronicGain.connect(this.masterGain.gain);

        this.isochronicLFO.start(0);

        // Amplitude modulation (smooth tremolo)
        this.amLFO = this.audioCtx.createOscillator();
        this.amLFO.type = 'sine';
        this.amLFO.frequency.setValueAtTime(this.computedBeat || 6, this.audioCtx.currentTime);

        this.amGain = this.audioCtx.createGain();
        this.amGain.gain.setValueAtTime(0, this.audioCtx.currentTime);

        // AM modulates the master gain
        this.amLFO.connect(this.amGain);
        this.amGain.connect(this.masterGain.gain);

        this.amLFO.start(0);

        // Bass kick drum output gain
        this.kickGain = this.audioCtx.createGain();
        this.kickGain.gain.value = this.kickVolume;
        this.kickGain.connect(this.audioCtx.destination);
      }

      createSimpleReverb() {
        // Create a simple reverb using multiple feedback delays
        const input = this.audioCtx.createGain();
        const output = this.audioCtx.createGain();

        const delayTimes = [0.037, 0.041, 0.043, 0.047, 0.053, 0.061];

        delayTimes.forEach(time => {
          const delay = this.audioCtx.createDelay();
          delay.delayTime.value = time;
          const feedback = this.audioCtx.createGain();
          feedback.gain.value = 0.4;

          input.connect(delay);
          delay.connect(feedback);
          feedback.connect(delay);
          delay.connect(output);
        });

        return { input, output, connect: (dest) => output.connect(dest) };
      }

      setVolume(volume) {
        if (!this.audioCtx) return;
        this.masterGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
      }

      setFilter(frequency) {
        if (!this.filter) return;
        this.filter.frequency.setTargetAtTime(frequency, this.audioCtx.currentTime, 0.05);
      }

      setDetune(cents) {
        if (!this.leftOsc || !this.rightOsc) return;
        this.currentDetune = cents;
        this.leftOsc.detune.setTargetAtTime(cents, this.audioCtx.currentTime, 0.02);
        this.rightOsc.detune.setTargetAtTime(-cents, this.audioCtx.currentTime, 0.02); // Opposite for width
      }

      setLFORate(rate) {
        if (!this.panLFO || !this.panLFOGain) return;
        // Intensified: rate controls frequency, and we scale the depth too
        this.panLFO.frequency.setTargetAtTime(rate, this.audioCtx.currentTime, 0.1);
        // More drift = more pan sweep depth (0.5 to 1.0)
        const depth = 0.5 + (rate / 2) * 0.5;
        this.panLFOGain.gain.setTargetAtTime(depth, this.audioCtx.currentTime, 0.1);
      }

      setHarmonics(amount) {
        if (!this.harmonicGain) return;
        // Intensified: was 0.15, now up to 0.6 for rich harmonic content
        this.harmonicGain.gain.setTargetAtTime(amount * 0.6, this.audioCtx.currentTime, 0.05);
      }

      setIsochronic(depth) {
        if (!this.isochronicGain) return;
        this.isochronicDepth = depth;
        // Isochronic creates sharp on/off pulsing at beat frequency
        // Depth controls how much the volume pulses (0 = none, 1 = full on/off)
        this.isochronicGain.gain.setTargetAtTime(depth * 0.5, this.audioCtx.currentTime, 0.05);
      }

      setAM(depth) {
        if (!this.amGain) return;
        this.amDepth = depth;
        // AM creates smooth tremolo at beat frequency
        this.amGain.gain.setTargetAtTime(depth * 0.4, this.audioCtx.currentTime, 0.05);
      }

      // Bass kick drum methods
      triggerKick() {
        if (!this.audioCtx || !this.kickGain) return;

        const now = this.audioCtx.currentTime;

        // Create oscillator for the kick body
        const kickOsc = this.audioCtx.createOscillator();
        kickOsc.type = 'sine';

        // Create gain envelope
        const kickEnv = this.audioCtx.createGain();

        // Pitch envelope: starts high and drops quickly for "punch"
        const startPitch = this.kickPitch + (this.kickPunch * 150);
        kickOsc.frequency.setValueAtTime(startPitch, now);
        kickOsc.frequency.exponentialRampToValueAtTime(this.kickPitch, now + 0.05);

        // Amplitude envelope: quick attack, variable decay
        kickEnv.gain.setValueAtTime(this.kickVolume, now);
        kickEnv.gain.exponentialRampToValueAtTime(0.001, now + this.kickDecay);

        // Connect and play
        kickOsc.connect(kickEnv);
        kickEnv.connect(this.kickGain);

        kickOsc.start(now);
        kickOsc.stop(now + this.kickDecay + 0.01);
      }

      startKick() {
        this.initAudioIfNeeded(0.06);
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();

        if (this.kickIntervalId) {
          clearInterval(this.kickIntervalId);
        }

        this.kickPlaying = true;
        const intervalMs = (60 / this.kickBPM) * 1000;

        // Trigger immediately, then on interval
        this.triggerKick();
        this.kickIntervalId = setInterval(() => {
          if (this.kickPlaying) {
            this.triggerKick();
          }
        }, intervalMs);

        return true;
      }

      stopKick() {
        this.kickPlaying = false;
        if (this.kickIntervalId) {
          clearInterval(this.kickIntervalId);
          this.kickIntervalId = null;
        }
        return false;
      }

      toggleKick() {
        if (this.kickPlaying) {
          return this.stopKick();
        } else {
          return this.startKick();
        }
      }

      setKickBPM(bpm) {
        this.kickBPM = bpm;
        // Restart interval if playing
        if (this.kickPlaying) {
          this.stopKick();
          this.startKick();
        }
      }

      setKickPitch(pitch) {
        this.kickPitch = pitch;
      }

      setKickDecay(decay) {
        this.kickDecay = decay;
      }

      setKickPunch(punch) {
        this.kickPunch = punch;
      }

      setKickVolume(volume) {
        this.kickVolume = volume;
        if (this.kickGain) {
          this.kickGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
        }
      }

      setReverb(amount) {
        if (!this.reverbGain || !this.dryGain) return;
        // Crossfade between dry and wet
        const wet = amount;
        const dry = 1 - (amount * 0.5); // Don't completely kill dry signal
        this.reverbGain.gain.setTargetAtTime(wet * 0.6, this.audioCtx.currentTime, 0.05);
        this.dryGain.gain.setTargetAtTime(dry, this.audioCtx.currentTime, 0.05);
      }

      setWaveform(waveType) {
        this.manualWaveform = waveType;
        if (!this.leftOsc || !this.rightOsc) return;

        // If auto, use the element-based waveform
        const actualWaveform = (waveType === 'auto') ? this.currentWaveform : waveType;

        this.leftOsc.type = actualWaveform;
        this.rightOsc.type = actualWaveform;
        if (this.intervalOsc) this.intervalOsc.type = actualWaveform;
      }

      setInterval(semitones) {
        if (!this.intervalGain || !this.intervalOsc) return;
        this.currentInterval = semitones;

        if (semitones === 0) {
          this.intervalGain.gain.setTargetAtTime(0, this.audioCtx.currentTime, 0.02);
        } else {
          // Calculate frequency ratio for equal temperament intervals
          const ratio = Math.pow(2, semitones / 12);
          const intervalFreq = this.computedCarrier * ratio;
          this.intervalOsc.frequency.setTargetAtTime(intervalFreq, this.audioCtx.currentTime, 0.03);
          // Intensified: was 0.15, now 0.5 for clearly audible harmonic intervals
          this.intervalGain.gain.setTargetAtTime(0.5, this.audioCtx.currentTime, 0.02);
        }
      }

      updateHarmonicFrequencies(baseFreq) {
        this.harmonicOscs.forEach(({ osc, multiplier }) => {
          osc.frequency.setTargetAtTime(baseFreq * multiplier, this.audioCtx.currentTime, 0.03);
        });
      }

      togglePlay(volume, beat, volSlider) {
        const wasFirstInit = !this.audioCtx;
        this.initAudioIfNeeded(volume);
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
        this.isAudioPlaying = !this.isAudioPlaying;

        if (this.isAudioPlaying) {
          // Start at 1/10th of slider value when first turning on
          const startVolume = volume * 0.1;
          this.masterGain.gain.setTargetAtTime(startVolume, this.audioCtx.currentTime, 0.02);
          // Update the slider to reflect the actual volume
          if (volSlider) {
            volSlider.value = startVolume;
          }
          this.updateFrequencies(beat);
        } else {
          this.masterGain.gain.setTargetAtTime(0.0001, this.audioCtx.currentTime, 0.02);
        }
        return this.isAudioPlaying;
      }

      computeAudioFromSeed(seed, dateStr, elementData) {
        const elements = [elementData.year, elementData.month, elementData.day];
        const primaryElement = elements.reduce((prev, current) => {
          const prevFreq = SOUND_ELEMENT_MAPPING[prev.key].freq;
          const currentFreq = SOUND_ELEMENT_MAPPING[current.key].freq;
          return (currentFreq > prevFreq) ? current : prev;
        });

        // Create a seeded random function for consistent but varied results
        const seededRandom = mulberry32(seed);

        // Select a random note from the full C2-C4 range (25 notes)
        // Use multiple seed factors for more variety
        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const dayOfMonth = date.getDate();
        const month = date.getMonth();
        const year = date.getFullYear();

        // Combine multiple factors for note selection randomness
        const noteIndex = Math.floor(
          (seed + dayOfMonth * 7 + month * 31 + (year % 100) * 13) % NOTE_FREQUENCIES_432.length
        );
        const selectedNote = NOTE_FREQUENCIES_432[noteIndex];
        let carrierFreq = selectedNote.freq;

        // Add slight random variation within a semitone for more organic sound
        const microtuneVariation = (seededRandom() - 0.5) * 0.03; // ¬±1.5% variation
        carrierFreq = carrierFreq * (1 + microtuneVariation);

        const elementalBaseFreq = SOUND_ELEMENT_MAPPING[primaryElement.key].freq;

        // Beat frequency also varies more based on seed
        const baseBeat = 2.0 + (dayOfMonth / 31) * 6.0;
        const beatVariation = seededRandom() * 4.0; // Add 0-4 Hz variation
        const beat = baseBeat + beatVariation;

        const waveformType = WAVEFORM_MAP[primaryElement.key] || 'sine';

        return {
          carrier: carrierFreq,
          beat: beat,
          element: primaryElement,
          elementalBaseFreq: elementalBaseFreq,
          waveform: waveformType,
          selectedNote: selectedNote.note, // Include note name for display
        };
      }

      updateFrequencies(beatOverride) {
        if (!this.currentElementData) return;

        const audioData = this.computeAudioFromSeed(
          this.currentElementData.seed,
          this.currentElementData.dateStr,
          this.currentElementData.elementData
        );

        this.computedCarrier = audioData.carrier;
        this.computedBeat = parseFloat(beatOverride) || audioData.beat;
        this.currentWaveform = audioData.waveform;

        const leftFreq = this.computedCarrier - (this.computedBeat / 2);
        const rightFreq = this.computedCarrier + (this.computedBeat / 2);

        if (this.leftOsc && this.rightOsc) {
          this.leftOsc.frequency.setTargetAtTime(Math.max(80, leftFreq), this.audioCtx.currentTime, 0.03);
          this.rightOsc.frequency.setTargetAtTime(Math.max(80, rightFreq), this.audioCtx.currentTime, 0.03);

          // Use manual waveform if set, otherwise use element-based waveform
          const actualWaveform = (this.manualWaveform === 'auto') ? this.currentWaveform : this.manualWaveform;
          this.leftOsc.type = actualWaveform;
          this.rightOsc.type = actualWaveform;
          if (this.intervalOsc) this.intervalOsc.type = actualWaveform;

          // Update harmonic oscillators based on carrier frequency
          this.updateHarmonicFrequencies(this.computedCarrier);

          // Update interval if active
          if (this.currentInterval > 0) {
            this.setInterval(this.currentInterval);
          }

          // Update isochronic and AM LFO frequencies to match beat
          if (this.isochronicLFO) {
            this.isochronicLFO.frequency.setTargetAtTime(this.computedBeat, this.audioCtx.currentTime, 0.05);
          }
          if (this.amLFO) {
            this.amLFO.frequency.setTargetAtTime(this.computedBeat, this.audioCtx.currentTime, 0.05);
          }
        }
      }

      resumeContext() {
        if (this.audioCtx && this.isAudioPlaying && this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }
      }
    }


    // ====================================================================
    // 5. MAIN APPLICATION LOGIC 
    // ====================================================================
    document.addEventListener('DOMContentLoaded', () => {
      const seedInput = document.getElementById('seed-input');
      const dateInput = document.getElementById('date-input');
      const scriptSelector = document.getElementById('script-selector');
      const colorModeSelector = document.getElementById('color-mode-selector');
      const audioToggle = document.getElementById('audio-toggle');
      const beatRange = document.getElementById('beat-range');
      const volRange = document.getElementById('vol-range');
      const fsOverlay = document.getElementById('fullscreen-overlay');
      const fsStat = document.getElementById('fs-stat');
      const speedDisplay = document.getElementById('speed-display');
      const bloomDisplay = document.getElementById('bloom-display');
      const volumeDisplay = document.getElementById('volume-display');
      const runeDisplay = document.getElementById('rune-display');

      const renderer = new MandalaRenderer('mandala-canvas', 'fullscreen-canvas');
      const audioEngine = new AudioEngine();

      let currentMandalaParams = null;
      let currentScriptType = 'runic';
      let currentColorMode = 'elemental';

      dateInput.valueAsDate = new Date();

      // Initial call to set up the UI and initial render
      updateUI();

      // --- Core Update Function ---
      function updateUI() {
        const name = seedInput.value || "Initial Config";
        const date = dateInput.value;

        const paramsGenerator = new MandalaParams(name, date, currentScriptType, currentColorMode);
        currentMandalaParams = paramsGenerator;
        renderer.setParams(currentMandalaParams.params);
        audioEngine.currentElementData = currentMandalaParams;

        // 2. Update Meta Displays
        runeDisplay.textContent = currentMandalaParams.runic || '‚ñµ';
        runeDisplay.style.fontFamily = currentMandalaParams.scriptMapping.font;
        document.getElementById('element-display').textContent = `${currentMandalaParams.elementData.year.name.split(' ')[0]} / ${currentMandalaParams.elementData.month.name.split(' ')[0]} / ${currentMandalaParams.elementData.day.name.split(' ')[0]}`;
        document.getElementById('archetype-display').textContent = `${currentMandalaParams.params.archetype.name.split(' ')[0]} / ${currentMandalaParams.params.complexity}`;

        // 3. Sync Audio Frequencies
        const audioData = syncAudioFrequencies(false);

        // 4. Update Explanation Panels
        updateExplanationPanels(currentMandalaParams.params, currentMandalaParams.elementData, audioData);
        
        // 5. Redraw static frame if not animating
        if (!renderer.isAnimating) {
            renderer.drawInitialFrame();
        }
      }

      function syncAudioFrequencies(isManualBeatChange) {
        if (!currentMandalaParams) return;
        
        const audioData = audioEngine.computeAudioFromSeed(
          currentMandalaParams.seed, 
          currentMandalaParams.dateStr, 
          currentMandalaParams.elementData
        );

        if (!isManualBeatChange && beatRange.dataset.touched === "0") {
          beatRange.value = audioData.beat.toFixed(1);
        }
        
        audioEngine.updateFrequencies(beatRange.value);
        
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
        
        return audioData; // Return the audioData for display
      }

      function updateExplanationPanels(params, elementData, audioData) {
        const leftPanel = document.getElementById('left-panel-content');
        const rightPanel = document.getElementById('right-panel-content');

        const primaryAudioElement = SOUND_ELEMENT_MAPPING[audioData.element.key];

        // LEFT PANEL: DATA AND COLOR SPECIFICATION
        let leftHTML = `
          <h3>INPUT SIGNATURE SPECIFICATION</h3>
          <p>The temporal and semantic inputs define three dominant elemental data types that drive the generative rendering process.</p>
          <h4>Input Source Mapping:</h4>
          <ul>
            <li><strong>Year Base:</strong> ${elementData.year.name}. ${elementData.year.meaning.split('. ')[0]}.</li>
            <li><strong>Month Vector:</strong> ${elementData.month.name}. ${elementData.month.meaning.split('. ')[0]}.</li>
            <li><strong>Day Modifier:</strong> ${elementData.day.name}. ${elementData.day.meaning.split('. ')[0]}.</li>
          </ul>
          <h4>Palette Specification: ${params.palette[0].replace('#', 'M-')}</h4>
          <p>Five blended color points are derived from your inputs, optimized for contrast and light spill:</p>
          <ul>
            <li><span class="color-block" style="background-color: ${params.palette[0]}"></span>Tone 1: Primary Structure (${params.palette[0]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[1]}"></span>Tone 2: Secondary Flow (${params.palette[1]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[2]}"></span>Tone 3: Accent / Glow (${params.palette[2]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[3]}"></span>Tone 4: Central Fill (${params.palette[3]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[4]}"></span>Tone 5: Frame Detail (${params.palette[4]})</li>
          </ul>
        `;
        leftPanel.innerHTML = leftHTML;

        // RIGHT PANEL: GEOMETRY AND ACOUSTIC CONFIGURATION
        const symbolSet = SCRIPT_SYMBOLS[params.scriptType] || SCRIPT_SYMBOLS.runic;
        const primarySymbol = symbolSet[params.symbolIndex % symbolSet.length];
        const scriptName = {
          runic: 'Elder Futhark',
          tibetan: 'Tibetan Script',
          devanagari: 'Sanskrit Devanagari',
          theban: 'Theban Alphabet',
          coptic: 'Coptic Script',
          hebrew: 'Hebrew Alphabet'
        }[params.scriptType] || 'Elder Futhark';

        let rightHTML = `
          <h3>GEOMETRY & ACOUSTIC CONFIGURATION</h3>
          <p>The input string determines the structural matrix and central glyph from the ${scriptName}.</p>
          <h4>Geometry Matrix: ${params.archetype.name}</h4>
          <p>${params.archetype.meaning}</p>

          <h4>Central Symbol: ${primarySymbol.char}</h4>
          <p><strong>${primarySymbol.desc}</strong> ‚Äî ${primarySymbol.meaning}</p>

          <h4>Acoustic Configuration</h4>
          <p>Binaural carrier from A=432Hz tuning (C2-C4 range):</p>
          <ul>
            <li><strong>Waveform:</strong> ${audioEngine.manualWaveform === 'auto' ? audioData.waveform.toUpperCase() + ' (Auto)' : audioEngine.manualWaveform.toUpperCase()}</li>
            <li><strong>Note:</strong> ${audioData.selectedNote || 'N/A'} (${audioData.carrier.toFixed(2)} Hz)</li>
            <li><strong>Beat:</strong> ${audioEngine.computedBeat.toFixed(2)} Hz</li>
          </ul>
          <h4>Modulation Controls</h4>
          <ul>
            <li><strong>Wave:</strong> Oscillator waveform selection</li>
            <li><strong>Filter:</strong> Lowpass cutoff frequency</li>
            <li><strong>Detune:</strong> Stereo width via pitch offset</li>
            <li><strong>Drift:</strong> Spatial panning LFO rate</li>
            <li><strong>Harmonics:</strong> Overtone blend (2nd, 3rd, 5th)</li>
            <li><strong>Interval:</strong> Musical interval above base (semitones)</li>
            <li><strong>Reverb:</strong> Spatial depth and echo</li>
          </ul>
        `;
        rightPanel.innerHTML = rightHTML;
      }
      
      // --- UI Event Listeners ---
      seedInput.addEventListener('input', updateUI);
      dateInput.addEventListener('change', updateUI);

      scriptSelector.addEventListener('change', () => {
        currentScriptType = scriptSelector.value;
        updateUI();
      });

      colorModeSelector.addEventListener('change', () => {
        currentColorMode = colorModeSelector.value;
        updateUI();
      });

      document.getElementById('random-btn').addEventListener('click', () => {
        seedInput.value = '';
        dateInput.valueAsDate = new Date(new Date().getTime() - Math.floor(Math.random()*365*24*60*60*1000));
        updateUI();
      });

      document.getElementById('animate-btn').addEventListener('click', () => {
        const newState = !renderer.isAnimating;
        renderer.toggleAnimation(newState);
        document.getElementById('animate-btn').textContent = newState ? "Stop Flow" : "Start Flow";
      });

      document.getElementById('bloom-btn').addEventListener('click', () => {
        renderer.isBloom = !renderer.isBloom;
        document.getElementById('bloom-btn').textContent = renderer.isBloom ? "Disable Light Spill" : "Toggle Light Spill";
        updateBloomDisplay();
        if(!renderer.isAnimating) renderer.drawInitialFrame();
      });

      document.getElementById('morph-btn').addEventListener('click', () => {
        renderer.morphEnabled = !renderer.morphEnabled;
        document.getElementById('morph-btn').textContent = renderer.morphEnabled ? "Morph: ON" : "Morph: OFF";
        if(!renderer.isAnimating) renderer.drawInitialFrame();
      });

      document.getElementById('save-btn').addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `SIG01-${seedInput.value.replace(/ /g, '-')||'config'}.png`;
        link.href = renderer.canvas.toDataURL();
        link.click();
      });

      // Audio Controls
      audioToggle.addEventListener('click', () => {
        const isPlaying = audioEngine.togglePlay(parseFloat(volRange.value), beatRange.value, volRange);
        audioToggle.textContent = isPlaying ? 'Tone ON' : 'Tone OFF';
        // Update volume display to reflect actual volume (1/10th on start)
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      });

      volRange.addEventListener('input', () => {
        audioEngine.setVolume(parseFloat(volRange.value));
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      });

      beatRange.addEventListener('input', () => {
        beatRange.dataset.touched = "1";
        syncAudioFrequencies(true);
      });

      // New modulation controls
      const filterRange = document.getElementById('filter-range');
      const detuneRange = document.getElementById('detune-range');
      const lfoRange = document.getElementById('lfo-range');
      const harmonicsRange = document.getElementById('harmonics-range');

      filterRange.addEventListener('input', () => {
        audioEngine.setFilter(parseFloat(filterRange.value));
      });

      detuneRange.addEventListener('input', () => {
        audioEngine.setDetune(parseFloat(detuneRange.value));
      });

      lfoRange.addEventListener('input', () => {
        audioEngine.setLFORate(parseFloat(lfoRange.value));
      });

      harmonicsRange.addEventListener('input', () => {
        audioEngine.setHarmonics(parseFloat(harmonicsRange.value));
      });

      const intervalRange = document.getElementById('interval-range');
      const reverbRange = document.getElementById('reverb-range');
      const waveformSelect = document.getElementById('waveform-select');

      intervalRange.addEventListener('input', () => {
        audioEngine.setInterval(parseFloat(intervalRange.value));
      });

      reverbRange.addEventListener('input', () => {
        audioEngine.setReverb(parseFloat(reverbRange.value));
      });

      const isoRange = document.getElementById('iso-range');
      const amRange = document.getElementById('am-range');

      isoRange.addEventListener('input', () => {
        audioEngine.setIsochronic(parseFloat(isoRange.value));
      });

      amRange.addEventListener('input', () => {
        audioEngine.setAM(parseFloat(amRange.value));
      });

      waveformSelect.addEventListener('change', () => {
        audioEngine.setWaveform(waveformSelect.value);
      });

      // Kick drum controls
      const kickToggle = document.getElementById('kick-toggle');
      const kickBpmRange = document.getElementById('kick-bpm');
      const kickPitchRange = document.getElementById('kick-pitch');
      const kickDecayRange = document.getElementById('kick-decay');
      const kickPunchRange = document.getElementById('kick-punch');
      const kickVolRange = document.getElementById('kick-vol');

      kickToggle.addEventListener('click', () => {
        const isPlaying = audioEngine.toggleKick();
        kickToggle.textContent = isPlaying ? 'Kick ON' : 'Kick OFF';
      });

      kickBpmRange.addEventListener('input', () => {
        audioEngine.setKickBPM(parseFloat(kickBpmRange.value));
      });

      kickPitchRange.addEventListener('input', () => {
        audioEngine.setKickPitch(parseFloat(kickPitchRange.value));
      });

      kickDecayRange.addEventListener('input', () => {
        audioEngine.setKickDecay(parseFloat(kickDecayRange.value));
      });

      kickPunchRange.addEventListener('input', () => {
        audioEngine.setKickPunch(parseFloat(kickPunchRange.value));
      });

      kickVolRange.addEventListener('input', () => {
        audioEngine.setKickVolume(parseFloat(kickVolRange.value));
      });

      // Fullscreen Logic
      document.getElementById('fullscreen-btn').addEventListener('click', enterFullscreen);
      document.getElementById('fs-exit').addEventListener('click', exitFullscreen);

      function enterFullscreen() {
        fsOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
        if (!renderer.isAnimating) renderer.toggleAnimation(true);
      }

      function exitFullscreen() {
        fsOverlay.classList.remove('active');
        document.body.style.overflow = '';
      }

      // Stat display (for user feedback)
      function showStat(message) {
        fsStat.textContent = message;
        fsStat.classList.add('visible');
        clearTimeout(fsStat.timer);
        fsStat.timer = setTimeout(() => fsStat.classList.remove('visible'), 1000);
      }
      
      function updateBloomDisplay() {
          bloomDisplay.textContent = renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "OFF";
      }

      // --- Global Keyboard Controls ---
      document.addEventListener('keydown', (e) => {
        const inFullscreen = fsOverlay.classList.contains('active');

        // F11 toggles fullscreen from anywhere
        if (e.code === 'F11') {
          e.preventDefault();
          if (inFullscreen) exitFullscreen();
          else enterFullscreen();
          return;
        }

        if (inFullscreen) {
          e.preventDefault();
        }

        switch(e.code) {
          case 'Escape':
            if (inFullscreen) exitFullscreen();
            break;
          case 'ArrowLeft': 
            renderer.speed = Math.max(0.1, renderer.speed - 0.25);
            showStat(`Motion Index: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowRight': 
            renderer.speed = Math.min(10, renderer.speed + 0.25);
            showStat(`Motion Index: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowUp': 
            if (!renderer.isBloom) {
                renderer.isBloom = true;
                document.getElementById('bloom-btn').textContent = "Disable Light Spill";
            }
            renderer.bloomIntensity = Math.min(2.0, renderer.bloomIntensity + 0.1);
            showStat(`Light Intensity: ${renderer.bloomIntensity.toFixed(2)}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawInitialFrame();
            break;
          case 'ArrowDown': 
            renderer.bloomIntensity = Math.max(0.1, renderer.bloomIntensity - 0.1);
            if (renderer.bloomIntensity < 0.15) {
                renderer.isBloom = false;
                document.getElementById('bloom-btn').textContent = "Toggle Light Spill";
            }
            showStat(`Light Intensity: ${renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "Light OFF"}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawInitialFrame();
            break;
          case 'NumpadAdd':
          case 'Equal': 
            volRange.value = (parseFloat(volRange.value) + 0.01).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Tone Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
          case 'NumpadSubtract':
          case 'Minus': 
            volRange.value = (parseFloat(volRange.value) - 0.01).toFixed(3);
            volRange.value = Math.max(0.005, parseFloat(volRange.value)).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Tone Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
        }
      });
      
      document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
              audioEngine.resumeContext();
          }
      });

      // Initial state setup
      updateBloomDisplay();
      speedDisplay.textContent = renderer.speed.toFixed(2);
      volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      document.getElementById('bloom-btn').textContent = renderer.isBloom ? "Disable Light Spill" : "Toggle Light Spill";
    });
  </script>
</body>
</html>
