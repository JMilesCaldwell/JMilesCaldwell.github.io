<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SIG: Generative Geometry Model</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Serif+Tibetan&display=swap" rel="stylesheet">
  <style>
    /* ---------------------------------------------------- */
    /* 1. MINIMALIST DESIGN AESTHETIC */
    /* ---------------------------------------------------- */
    :root {
      --color-primary-accent: #C8AA6E; /* Polished Brass / Metallic Accent */
      --color-primary-canvas: #C8AA6E; /* Canvas highlight color */
      --color-neutral-dark: #111111;   /* Primary Background */
      --color-neutral-medium: #888888; /* Secondary text */
      --color-bg-light: #EEEEEE;      /* White/Light Background for Contrast Elements */
      --color-bg-panel: #1A1A1A;      /* Dark Panel Background */
      --color-text-light: #EEEEEE;    /* Primary Text Color */
      --color-border: #333333;        /* Dark Border Color */
      --shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--color-neutral-dark);
      color: var(--color-text-light);
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }
    .navbar {
      display: flex; justify-content: center; align-items: center;
      background: var(--color-bg-panel); padding: 1.2rem 2rem;
      position: sticky; top: 0; width: 100%; z-index: 1000;
      border-bottom: 1px solid var(--color-border); box-shadow: var(--shadow-soft);
    }
    .navbar a { color: var(--color-neutral-medium); font-size: 0.8rem; font-weight: 500; text-decoration: none; margin: 0 2rem; transition: color 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
    .navbar a:hover { color: var(--color-primary-accent); }

    .container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5rem 2rem 3rem; gap: 3rem; width: 95%; max-width: 1500px; margin: 0 auto; }
    .main-content-grid { display: flex; gap: 4rem; width: 100%; align-items: flex-start; }
    .center-column { display: flex; flex-direction: column; align-items: center; gap: 2rem; flex: 0 0 650px; }

    /* Info Panels - Structured, Technical Look */
    .explanation-panel { flex: 1; max-width: 420px; padding: 2.2rem; background: var(--color-bg-panel); border-radius: 4px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); position: sticky; top: 7rem; min-height: 400px; }
    .explanation-panel h3 { color: var(--color-primary-accent); font-size: 1rem; font-weight: 500; border-bottom: 1px solid var(--color-border); padding-bottom: 0.75rem; margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px; }
    .explanation-panel h4 { color: var(--color-text-light); font-size: 0.9rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.6rem; }
    .explanation-panel p, .explanation-panel ul, .explanation-panel li { font-size: 0.85rem; color: var(--color-neutral-medium); margin-bottom: 0.8rem; line-height: 1.5; list-style-position: inside; padding-left: 0; }
    .explanation-panel strong { color: var(--color-text-light); font-weight: 600; }
    .color-block { display: inline-block; width: 14px; height: 14px; border-radius: 50%; margin-right: 8px; border: 1px solid var(--color-border); vertical-align: middle;}

    .header-group { text-align: center; max-width: 900px; padding: 0 1rem; margin-bottom: 0rem; }
    .title { font-size: 3rem; font-weight: 300; color: var(--color-text-light); letter-spacing: 5px; text-transform: uppercase; margin-bottom: 0.5rem; }
    .subtitle { font-size: 1rem; color: var(--color-neutral-medium); font-weight: 400; letter-spacing: 0.5px; }

    /* Input Card - Dark and clean */
    .input-group { display: flex; flex-direction: column; gap: 1.5rem; width: 100%; background: var(--color-bg-panel); padding: 1.5rem 2rem; border-radius: 4px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); }
    .input-row { display: flex; gap: 1rem; }
    
    .text-input, .date-input { 
      background: var(--color-neutral-dark); border: 1px solid var(--color-border); border-radius: 4px; 
      color: var(--color-text-light); padding: 0.9rem; font-family: inherit; outline: none; transition: border-color 0.3s, box-shadow 0.3s;
    }
    .text-input { flex: 2; font-size: 1rem; }
    .date-input { flex: 1; font-size: 0.9rem; text-align: center; cursor: pointer; }
    .text-input:focus, .date-input:focus { border-color: var(--color-primary-accent); box-shadow: 0 0 0 3px rgba(200, 170, 110, 0.2); background: #222; }

    /* Meta Info */
    .meta-display { display: flex; justify-content: space-between; align-items: flex-end; border-top: 1px solid var(--color-border); padding-top: 1.2rem; margin-top: 0.5rem; }
    .meta-box { display: flex; flex-direction: column; }
    .meta-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.5px; color: var(--color-neutral-medium); margin-bottom: 4px; font-weight: 500; }
    .meta-value { color: var(--color-primary-accent); font-size: 1rem; font-weight: 700; }
    .tibetan-font { font-family: 'Noto Serif Tibetan', serif; font-size: 1.6rem; line-height: 1; color: var(--color-primary-accent); }

    /* Canvas */
    .canvas-wrapper { position: relative; margin: 1rem 0; background: #080706; border-radius: 50%; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.8), inset 0 0 10px rgba(255, 255, 255, 0.1); }
    #mandala-canvas { border-radius: 50%; display: block; max-width: 90vw; height: auto; cursor: crosshair; }

    /* Controls - Clean, button-heavy */
    .controls { display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: center; max-width: 650px; }
    .btn { background: var(--color-bg-panel); border: 1px solid var(--color-border); color: var(--color-neutral-medium); padding: 0.8rem 1.4rem; border-radius: 4px; cursor: pointer; transition: all 0.3s; font-size: 0.8rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }
    .btn:hover { border-color: var(--color-primary-accent); color: var(--color-primary-accent); background: #222; }

    .audio-controls { display: flex; gap: 1rem; align-items: center; padding: 0.8rem 1.2rem; border-radius: 4px; background: var(--color-bg-panel); border: 1px solid var(--color-border); }
    .audio-controls label { font-size: 0.75rem; color: var(--color-neutral-medium); text-transform: uppercase; letter-spacing: 1px; }
    .audio-controls input[type="range"] { width: 80px; appearance: none; height: 3px; background: var(--color-border); border-radius: 2px; }
    .audio-controls input[type="range"]::-webkit-slider-thumb { appearance: none; width: 10px; height: 10px; border-radius: 50%; background: var(--color-primary-accent); cursor: pointer; }

    /* Fullscreen */
    .fullscreen-overlay { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 9999; justify-content: center; align-items: center; }
    .fullscreen-overlay.active { display: flex; cursor: none; }
    
    .fs-hover-zone { position: absolute; bottom: 0; left: 0; width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; z-index: 10000; transition: opacity 0.3s; pointer-events: none; }
    .fs-controls { background: rgba(30,30,30,0.95); border: 1px solid var(--color-border); padding: 15px 25px; border-radius: 4px; display: flex; gap: 15px; opacity: 0; transition: opacity 0.3s; pointer-events: auto; }
    .fs-controls .btn { background: var(--color-primary-accent); color: var(--color-neutral-dark); border-color: var(--color-primary-accent); font-weight: 600; }
    .fs-controls .btn:hover { background: #B99C5E; }
    .fullscreen-overlay.active:hover .fs-hover-zone { opacity: 1; pointer-events: auto; }
    .fs-hover-zone:hover .fs-controls { opacity: 1; }

    .fs-stat { background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 4px; position: fixed; top: 20px; right: 20px; color: var(--color-primary-canvas); font-size: 0.8rem; transition: opacity 0.3s; opacity: 0; pointer-events: none; }
    .fs-stat.visible { opacity: 1; }

    @media (max-width: 1200px) {
      .main-content-grid { flex-direction: column; align-items: center; }
      .explanation-panel { max-width: 650px; width: 100%; position: static; }
      .center-column { flex: 1; }
    }
    @media (max-width: 650px) {
      .input-row { flex-direction: column; }
      .controls { gap: 0.8rem; }
      .audio-controls { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>

<body>

  <div class="navbar">
    <a href="#signature">Signature Input</a>
    <a href="#structure">Geometry Structure</a>
    <a href="#acoustic">Acoustic Alignment</a>
  </div>

  <div class="container">
    <div class="header-group">
      <h1 class="title">SIG.01: Generative Geometry</h1>
      <p class="subtitle">
        **An engineered visualization of semantic and temporal input data.**<br>
        Rendering a unique structural diagram based on user-defined parameters.
      </p>
    </div>

    <div class="main-content-grid">
      <div class="explanation-panel left-panel">
        <div id="left-panel-content">
          </div>
      </div>

      <div class="center-column">
        <div class="input-group">
          <div class="input-row">
            <input type="text" class="text-input" id="seed-input" placeholder="Project Name or Data String..." autocomplete="off">
            <input type="date" class="date-input" id="date-input">
          </div>
          
          <div class="meta-display">
            <div class="meta-box">
              <span class="meta-label">Tibetan Seed String</span>
              <span class="meta-value tibetan-font" id="tibetan-display"></span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Input Signature</span>
              <span class="meta-value" id="element-display">VOID / VOID</span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Complexity Index</span>
              <span class="meta-value" id="archetype-display">Grid Type / 0.0</span>
            </div>
          </div>
        </div>

        <div class="canvas-wrapper">
          <canvas id="mandala-canvas" width="650" height="650"></canvas>
        </div>

        <div class="controls">
          <button class="btn" id="random-btn">Generate New Data</button>
          <button class="btn" id="animate-btn">Start Flow</button>
          <button class="btn" id="bloom-btn">Toggle Light Spill</button>
          <button class="btn" id="save-btn">Export Image (PNG)</button>

          <div class="audio-controls" id="audio-controls">
            <button class="btn" id="audio-toggle">Acoustic Tone OFF</button>
            <label for="beat-range">Beat Freq (Hz)</label>
            <input id="beat-range" type="range" min="1" max="12" step="0.1" value="6" data-touched="0">
            <label for="vol-range">Volume</label>
            <input id="vol-range" type="range" min="0" max="0.3" step="0.005" value="0.06">
          </div>
          
          <button class="btn" id="fullscreen-btn">Full Screen Mode (F11)</button>
        </div>
      </div>

      <div class="explanation-panel right-panel">
        <div id="right-panel-content">
          </div>
      </div>

    </div>
  </div>

  <div class="fullscreen-overlay" id="fullscreen-overlay">
    <canvas id="fullscreen-canvas"></canvas>
    
    <div class="fs-stat" id="fs-stat"></div>

    <div class="fs-hover-zone">
      <div class="fs-controls">
        <button class="btn" id="fs-exit">Exit (ESC)</button>
        <div style="display:flex;flex-direction:column;align-items:flex-start;color:#EEE;margin-left:8px;font-size:0.8rem;">
          <div>[‚Üë/‚Üì] Light Intensity: <span id="bloom-display">0.60</span></div>
          <div>[‚Üê/‚Üí] Motion Index: <span id="speed-display">1.00</span></div>
          <div>[+/-] Tone Volume: <span id="volume-display">0.06</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====================================================================
    // 1. CONSTANTS & UTILITIES (Refined for Minimalist/Technical Language)
    // ====================================================================
    const W = 650, H = 650; 

    const LATIN_TO_TIBETAN = {
      'a': '\u0F68', 'b': '\u0F56', 'c': '\u0F45', 'd': '\u0F51', 'e': '\u0F7A', 'f': '\u0F55', 'g': '\u0F42', 'h': '\u0F67',
      'i': '\u0F72', 'j': '\u0F47', 'k': '\u0F40', 'l': '\u0F63', 'm': '\u0F58', 'n': '\u0F53', 'o': '\u0F7C', 'p': '\u0F54',
      'q': '\u0F41', 'r': '\u0F62', 's': '\u0F66', 't': '\u0F4F', 'u': '\u0F74', 'v': '\u0F5D', 'w': '\u0F5D', 'x': '\u0F6A',
      'y': '\u0F61', 'z': '\u0F5F', ' ': ' ',
      'sh': '\u0F64', 'th': '\u0F50', 'ph': '\u0F55', 'ts': '\u0F59'
    };

    // Updated Element Names for Technical Look (Material/System)
    const ELEMENTS = {
      METAL: { name: 'Alloy (Metal)', colors: ['#D0D0D0', '#A0A0A0', '#707070', '#555555', '#FFFFFF'], meaning: 'Represents Structural Integrity and Data Clarity.' },
      WATER: { name: 'Fluidic (Water)', colors: ['#30404C', '#576775', '#7A8C98', '#9DB0C0', '#B0B0B0'], meaning: 'Represents System Flow and Dynamic Input.' },
      // Updated WOOD Element for Green
      WOOD: { name: 'Composite (Wood)', colors: ['#2D5743', '#4E8A6E', '#7DB49A', '#BCC8BF', '#A0A0A0'], meaning: 'Represents Growth Vectors and Expansion.' },
      FIRE: { name: 'Thermal (Fire)', colors: ['#D24B4F', '#A04A4E', '#E98E92', '#F9C2C4', '#FEE6E7'], meaning: 'Represents Energy State and Transformation Rate.' },
      EARTH: { name: 'Foundation (Earth)', colors: ['#8A735E', '#A6927C', '#C2B19F', '#DDD0C3', '#909090'], meaning: 'Represents Core Stability and Base Coordinates.' }
    };
    const MONTH_ELEMENTS = [
      ELEMENTS.EARTH, ELEMENTS.EARTH, ELEMENTS.WOOD, ELEMENTS.WOOD, ELEMENTS.FIRE, ELEMENTS.FIRE,
      ELEMENTS.METAL, ELEMENTS.METAL, ELEMENTS.WATER, ELEMENTS.WATER, ELEMENTS.EARTH, ELEMENTS.EARTH
    ];
    // Solfeggio / Planetary Frequencies
    const SOUND_ELEMENT_MAPPING = {
      METAL: { freq: 432, note: "432 Hz", explanation: "Target for Cognitive Clarity." },
      WATER: { freq: 194.18, note: "194 Hz", explanation: "Target for System Dynamics." },
      WOOD: { freq: 285, note: "285 Hz", explanation: "Target for Vector Optimization." },
      FIRE: { freq: 396, note: "396 Hz", explanation: "Target for State Transition." },
      EARTH: { freq: 172.8, note: "172 Hz", explanation: "Target for Base Stability." }
    };

    // NEW: Waveform selection based on Element
    const WAVEFORM_MAP = {
      'METAL': 'triangle', // Sharp, clear, structural
      'WATER': 'sine',     // Smooth, fluid
      'WOOD': 'sawtooth',  // Growing, forward
      'FIRE': 'square',    // Intense, energetic
      'EARTH': 'sine'      // Stable, fundamental
    };

    const TIBETAN_SYMBOLS = [
      { char: '\u0F42', desc: 'GA (Module Command)', meaning: 'Focus on System Output and Efficiency.' }, { char: '\u0F40', desc: 'KA (Structural Integrity)', meaning: 'The union of Input, Process, and Result.' },
      { char: '\u0F68', desc: 'A (Void State)', meaning: 'Symbolizing the unconditioned space for new data.' }, { char: '\u0F4F', desc: 'TA (Interconnect)', meaning: 'The understanding of non-linear system links.' },
      { char: '‚öî', desc: 'Cutter (Clarity)', meaning: 'Cutting through data noise for immediate clarity.' }, { char: 'üîî', desc: 'Anchor (Fixed Point)', meaning: 'Representing a rigid, diamond-like structural focus.' },
      { char: '\u0F68\u0F7A', desc: 'EH (Data Space)', meaning: 'The elemental seed for ultimate open system space.' }, 
      { char: '\u0F5D\u0F66', desc: 'YAM (Airflow)', meaning: 'The elemental seed for processing speed and circulation.' }, 
      { char: '\u0F62\u0F7A\u0F58', desc: 'RAM (Thermal Sink)', meaning: 'The elemental seed for internal transformation and focused energy.' },
      { char: '\u0F63\u0F7A\u0F58', desc: 'LAM (Ground Plane)', meaning: 'The elemental seed for deep rooting and coordinate stability.' }, 
      { char: '\u0F56\u0F7A\u0F58', desc: 'BAM (Liquid Vector)', meaning: 'The elemental seed for dynamic data fluidity and potential.' } 
    ];

    // UPDATED: Added Archetype 3
    const ARCHETYPES = [
      { name: 'Four-Gate Structure', index: 0, meaning: 'A traditional four-quadrant grid, representing a protected and symmetrical data processing environment.' },
      { name: 'Triad Intersection Matrix', index: 1, meaning: 'A pattern of intersecting triangles, symbolizing the convergence of three primary data streams.' },
      { name: 'Crystalline Flow Net', index: 2, meaning: 'A complex, high-density projection, focusing on distributed data flow and structural complexity.' },
      { name: 'Spiral Recursion Field', index: 3, meaning: 'A logarithmic spiral pattern, reflecting iterative data generation and exponential growth vectors.' } // NEW
    ];

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }
    
    function interpolateColor(color1, color2, factor) {
      const rgb1 = hexToRgb(color1);
      const rgb2 = hexToRgb(color2);
      const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * factor);
      const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * factor);
      const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * factor);
      return `rgb(${r},${g},${b})`;
    }

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // ====================================================================
    // 2. MANDALA PARAMETERS CLASS
    // ====================================================================

    class MandalaParams {
      constructor(name, dateStr) {
        this.name = name;
        this.dateStr = dateStr;
        this.tibetan = this.convertToTibetan(name);
        this.seed = this.getNumericSeed(this.tibetan);
        this.rand = mulberry32(this.seed);
        this.elementData = this.getElementsFromDate(dateStr);
        this.params = this.generateParams();
      }

      convertToTibetan(text) {
        if (!text) return "";
        let lower = text.toLowerCase();
        let result = "";
        for (let i = 0; i < lower.length; i++) {
          let char = lower[i];
          if (i < lower.length - 1) {
            const digraph = lower.slice(i, i+2);
            if (LATIN_TO_TIBETAN[digraph]) {
              result += LATIN_TO_TIBETAN[digraph];
              i++; continue;
            }
          }
          result += LATIN_TO_TIBETAN[char] || "";
        }
        return result;
      }

      getNumericSeed(str) {
        let hash = 0;
        if (!str || str.length === 0) return 123456789;
        for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash |= 0; 
        }
        return Math.abs(hash);
      }

      getElementsFromDate(dateStr) {
        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const year = date.getFullYear();
        const month = date.getMonth(); 
        const day = date.getDay();

        const yearDigit = year % 10;
        let yearElement;
        if (yearDigit === 4 || yearDigit === 9) yearElement = ELEMENTS.WOOD;
        else if (yearDigit === 5 || yearDigit === 0) yearElement = ELEMENTS.FIRE;
        else if (yearDigit === 6 || yearDigit === 1) yearElement = ELEMENTS.EARTH;
        else if (yearDigit === 7 || yearDigit === 2) yearElement = ELEMENTS.METAL;
        else yearElement = ELEMENTS.WATER;

        const monthElement = MONTH_ELEMENTS[month];
        let dayElement;
        if (day === 0) dayElement = ELEMENTS.EARTH; 
        else if (day === 1) dayElement = ELEMENTS.WATER; 
        else if (day === 2) dayElement = ELEMENTS.FIRE; 
        else if (day === 3) dayElement = ELEMENTS.WOOD; 
        else if (day === 4) dayElement = ELEMENTS.WATER; 
        else if (day === 5) dayElement = ELEMENTS.METAL; 
        else dayElement = ELEMENTS.FIRE;

        return { year: yearElement, month: monthElement, day: dayElement };
      }

      generateParams() {
        const rand = this.rand;
        const seed = this.seed;
        const randomnessFactor = (rand() - 0.5) * 0.05;

        // 1. Color Palette Synthesis
        const p = [...this.elementData.year.colors];
        const m = [...this.elementData.month.colors];
        const d = [...this.elementData.day.colors];
        let colorPool = [...p, ...m, ...d].sort(() => rand() - 0.5);

        // We use the Polished Brass accent for the bright glow/detail
        const ACCENT_BRASS = "#C8AA6E";

        const colorStrings = [ 
          colorPool[0] || p[0], // Primary color (Ring Base)
          colorPool[1] || m[0], // Secondary color (Inner Geometry)
          ACCENT_BRASS,         // Tertiary color (Primary Accent/Detail)
          colorPool[3] || p[1], // Accent 1 (Text/Center Fill)
          colorPool[4] || m[1]  // Accent 2 (Center outline/core)
        ];

        // 2. Geometry Parameters
        const archetypeIndex = seed % ARCHETYPES.length; // Max is now 3
        const archetype = ARCHETYPES[archetypeIndex];

        let complexity = ((seed % 900) / 900) + 0.1;
        complexity = parseFloat((complexity + randomnessFactor).toFixed(2));
        complexity = Math.max(0.1, Math.min(1.0, complexity));

        const ringCountBase = 7 + Math.floor(complexity * 12);
        const ringCount = Math.max(5, ringCountBase + Math.floor(randomnessFactor * 10));

        const rings = [];
        for(let i=0; i<ringCount; i++) {
          rings.push({
            r: 0.1 + (i/ringCount)*0.9,
            style: Math.floor(rand() * 6), // Max ring style is now 5 (0-5)
            width: (1 + rand() * 4 * complexity) * (1 + randomnessFactor * 0.5),
            colorIndex: i % 3 // Cycle through the first three (including the brass accent)
          });
        }
        
        // 3. Symbol Selection (Bias towards elemental syllable)
        let symbolIndex = seed % TIBETAN_SYMBOLS.length;
        const elementalSyllables = { 'Alloy (Metal)': 7, 'Fluidic (Water)': 11, 'Composite (Wood)': 8, 'Thermal (Fire)': 9, 'Foundation (Earth)': 10 };
        const yearElementKey = this.elementData.year.name;

        if (elementalSyllables[yearElementKey] && rand() < 0.35) {
            symbolIndex = elementalSyllables[yearElementKey];
        }

        // 4. Random Polyhedrons (Complex 3D-like wireframes)
        const polyCount = rand() < 0.40 ? Math.floor(rand() * 4) + 1 : 0; 
        const polyhedrons = [];
        for(let i=0; i<polyCount; i++) {
            polyhedrons.push({
                type: Math.floor(rand() * 4), 
                radiusFactor: 0.3 + rand() * 0.6,
                color: ACCENT_BRASS, // Always use the brass accent for these wireframes
                thickness: 0.8 + rand() * 3,
                rotationSpeed: (rand() - 0.5) * 0.08,
            });
        }

        return {
          seed, palette: colorStrings, archetype, complexity: complexity.toFixed(2),
          rings, symbolIndex, polyhedrons, solidRotation: rand() * Math.PI * 2,
        };
      }
    }

    // ====================================================================
    // 3. MANDALA RENDERER CLASS
    // ====================================================================

    class MandalaRenderer {
      constructor(canvasId, fullscreenCanvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.fsCanvas = document.getElementById(fullscreenCanvasId);
        this.fsCtx = this.fsCanvas.getContext('2d');

        this.params = null;
        this.isAnimating = false;
        this.animationId = null;
        this.phase = 0;

        this.width = W;
        this.height = H;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.speed = 1.0;
        this.isBloom = true; 
        this.bloomIntensity = 0.6; 

        this.icosaVertices = this.generateIcosahedronVertices();
        this.icosaEdges = this.generateIcosahedronEdges();
      }

      setParams(params) {
        this.params = params;
        this.drawInitialFrame(); // Ensure a static frame is drawn immediately
      }
      
      drawInitialFrame() {
        if (!this.params) return;
        this.drawFrame(this.ctx, this.width, this.height, this.phase);
      }

      toggleAnimation(state) {
        this.isAnimating = state;
        if (state) this.loop();
        else cancelAnimationFrame(this.animationId);
      }

      loop() {
        if (!this.isAnimating) return;
        this.phase += 0.01 * this.speed;

        const size = Math.min(this.canvas.width, this.canvas.height);
        this.drawFrame(this.ctx, size, size, this.phase);

        if (document.getElementById('fullscreen-overlay').classList.contains('active')) {
          const w = window.innerWidth;
          const h = window.innerHeight;
          this.fsCanvas.width = w;
          this.fsCanvas.height = h;
          this.drawFrame(this.fsCtx, w, h, this.phase);
        }

        this.animationId = requestAnimationFrame(this.loop.bind(this));
      }

      drawFrame(ctx, w, h, phase) {
        ctx.save();
        /* The canvas itself must remain dark for the glowing effect to work */
        ctx.fillStyle = '#080706'; 
        ctx.fillRect(0, 0, w, h);

        // --- 1. GLOW LAYER (Faint, broad blur) ---
        if (this.isBloom) {
          const blurSize1 = 15 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize1}px)`;
          ctx.globalAlpha = 0.4;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 2. CORE LAYER (Tighter, brighter blur) ---
        if (this.isBloom) {
          const blurSize2 = 5 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize2}px)`;
          ctx.globalAlpha = 0.6;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 3. DETAIL LAYER (Sharp, full color) ---
        ctx.filter = 'none';
        ctx.globalAlpha = 1.0;
        this.drawMandalaElements(ctx, w, h, phase, false);

        ctx.restore();
      }

      drawMandalaElements(ctx, w, h, phase, isGlowPass) {
        const cx = w / 2, cy = h / 2;
        const radius = Math.min(w, h) / 2 * 0.95;

        this.params.rings.forEach((ring, i) => {
          this.drawRing(ctx, cx, cy, radius * ring.r, ring, this.params, phase, i, isGlowPass);
        });

        this.params.polyhedrons.forEach(poly => {
          this.drawPolyhedron(ctx, cx, cy, radius * poly.radiusFactor, poly, phase, isGlowPass);
        });

        // UPDATED: Added new archetype (index 3)
        switch(this.params.archetype.index) {
          case 0: this.drawVajraPalace(ctx, cx, cy, radius * 0.4, this.params, phase, isGlowPass); break;
          case 1: this.drawSriYantra(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
          case 2: this.drawIcosahedronGrid(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
          case 3: this.drawFibonacciSpiral(ctx, cx, cy, radius * 0.8, this.params, phase, isGlowPass); break; // NEW SPIRAL
        }

        this.drawCenterSyllable(ctx, cx, cy, radius * 0.1, this.params, phase, isGlowPass);
      }

      drawRing(ctx, cx, cy, r, ring, params, phase, idx, isGlowPass) {
        const color1 = params.palette[ring.colorIndex];
        const color2 = params.palette[(ring.colorIndex + 1) % 3];
        const factor = (r / (H / 2 * 0.95) + Math.sin(phase * 0.5) * 0.5 + 0.5) % 1;
        const interpolatedColor = interpolateColor(color1, color2, factor);
        
        ctx.strokeStyle = interpolatedColor;
        ctx.lineWidth = ring.width;
        ctx.beginPath();
        
        if (isGlowPass || ring.style === 0) { 
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
          return;
        }

        const complexityFactor = parseFloat(params.complexity) * 0.5;

        if (ring.style === 1) { 
          const dots = 36 + Math.floor(complexityFactor * 40);
          for(let i=0; i<dots; i++) {
            const a = (i/dots)*Math.PI*2 + phase*(idx%2?0.1:-0.1);
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.moveTo(x, y);
            ctx.arc(x, y, ring.width*1.5, 0, Math.PI*2);
          }
          ctx.fillStyle=interpolatedColor;
          ctx.fill();
        } else if (ring.style === 4) { 
            ctx.setLineDash([ring.width * 2, ring.width * 2]);
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]); 
        } else if (ring.style === 2) { 
          ctx.arc(cx, cy, r - ring.width/2, 0, Math.PI*2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx, cy, r + ring.width/2, 0, Math.PI*2);
          ctx.stroke();
        } else if (ring.style === 3) { 
          const symbol = TIBETAN_SYMBOLS[params.symbolIndex].char;
          const count = 15 + Math.floor(complexityFactor * 15);
          ctx.font = `${ring.width * 5}px 'Noto Serif Tibetan', sans-serif`;
          ctx.fillStyle = interpolatedColor;
          for(let i=0; i<count; i++) {
            const a = (i/count)*Math.PI*2 + phase*0.1;
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(a + Math.PI/2);
            ctx.fillText(symbol, 0, 0);
            ctx.restore();
          }
        } else if (ring.style === 5) { // NEW: Undulating Wave
          const points = 360;
          // Frequency scales with complexity, offset by rotation phase
          const frequency = 8 + complexityFactor * 20; 
          const amplitude = ring.width * 2; 

          ctx.beginPath();
          for(let i=0; i<=points; i++) {
            const a = (i/points)*Math.PI*2;
            const displacement = Math.sin(a * frequency + phase * 4) * amplitude;
            const currentR = r + displacement;
            const x = cx + Math.cos(a)*currentR;
            const y = cy + Math.sin(a)*currentR;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        }
      }

      drawCenterSyllable(ctx, cx, cy, r, params, phase, isGlowPass) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fillStyle = params.palette[3];
        ctx.fill();
        ctx.strokeStyle = params.palette[4];
        ctx.lineWidth = 2;
        ctx.stroke();

        if (isGlowPass) return;

        const symbolData = TIBETAN_SYMBOLS[params.symbolIndex];
        ctx.fillStyle = params.palette[2]; // Use Brass Accent
        ctx.font = `${r*0.8}px 'Noto Serif Tibetan', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbolData.char, cx, cy);
      }
      
      drawVajraPalace(ctx, cx, cy, r, params, phase, isGlowPass) {
        ctx.fillStyle = params.palette[1];
        if (isGlowPass) return; 

        ctx.fillRect(cx - r * 0.9, cy - r * 0.9, r * 1.8, r * 1.8);
        
        const lineCount = 12 + Math.floor(parseFloat(params.complexity) * 10);
        ctx.strokeStyle = params.palette[2];
        ctx.lineWidth = 1;
        ctx.save(); ctx.translate(cx, cy); ctx.rotate(phase * 0.005);
        for (let i = 0; i < lineCount; i++) {
          const a = (i / lineCount) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(a) * r * 2, Math.sin(a) * r * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      drawSriYantra(ctx, cx, cy, r, params, phase, isGlowPass) {
        const depth = 5 + Math.floor(parseFloat(params.complexity) * 4);
        let currentSize = r * 0.9;
        ctx.save();
        ctx.translate(cx, cy);
        let currentRotation = params.solidRotation + phase * 0.005;

        for(let i=0; i<depth; i++) {
          const color = i % 2 === 0 ? params.palette[1] : params.palette[2];
          ctx.strokeStyle = color;
          ctx.lineWidth = isGlowPass ? 5 : (2 + (depth - i) * 0.5);

          this.drawTriangle(ctx, currentRotation, currentSize);
          
          currentRotation += Math.PI / 3;
          ctx.strokeStyle = i % 2 === 0 ? params.palette[4] : params.palette[3];
          this.drawTriangle(ctx, currentRotation, currentSize);

          currentRotation -= Math.PI / 3;
          currentSize *= 0.7;
          currentRotation += phase * 0.01;
        }
        ctx.restore();
      }
      
      drawTriangle(ctx, angle, size) {
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * size, Math.sin(angle) * size);
        ctx.lineTo(Math.cos(angle + 2 * Math.PI / 3) * size, Math.sin(angle + 2 * Math.PI / 3) * size);
        ctx.lineTo(Math.cos(angle + 4 * Math.PI / 3) * size, Math.sin(angle + 4 * Math.PI / 3) * size);
        ctx.closePath();
        ctx.stroke();
      }

      drawIcosahedronGrid(ctx, cx, cy, r, params, phase, isGlowPass) {
        if (isGlowPass) return;
        
        const radius = r * 0.9;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(params.solidRotation + phase * 0.005);
        
        const goldenRatio = (1 + Math.sqrt(5)) / 2;
        const vertexPositions = [];
        const offsetAngle = phase * 0.05;

        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          vertexPositions.push({ x: radius * Math.cos(angle + offsetAngle) / goldenRatio, y: radius * Math.sin(angle + offsetAngle) / goldenRatio });
          vertexPositions.push({ x: radius * Math.cos(angle - offsetAngle + Math.PI/6) / goldenRatio, y: radius * Math.sin(angle - offsetAngle + Math.PI/6) / goldenRatio });
        }
        
        ctx.strokeStyle = params.palette[2];
        ctx.lineWidth = 1;
        for (let i = 0; i < 12; i++) {
          for (let j = i + 1; j < 12; j++) {
            const p1 = vertexPositions[i];
            const p2 = vertexPositions[j];
            const distSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
            if (distSq < (radius * 0.7) ** 2) {
              ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }
          }
        }
        
        ctx.fillStyle = params.palette[4];
        vertexPositions.forEach(p => {
          ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
        });

        ctx.restore();
      }
      
      // NEW: Fibonacci Spiral Archetype
      drawFibonacciSpiral(ctx, cx, cy, r, params, phase, isGlowPass) {
          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(params.solidRotation + phase * 0.05);

          const segments = 20 + Math.floor(parseFloat(params.complexity) * 20);
          const goldenRatio = (1 + Math.sqrt(5)) / 2;
          const color = params.palette[1];
          const accent = params.palette[2];
          
          ctx.strokeStyle = color;
          ctx.lineWidth = isGlowPass ? 4 : 2;
          
          let a = 0.5; // Controls tightness
          let angle = 0;
          
          ctx.beginPath();
          for(let i=0; i<segments; i++) {
              let currentR = a * Math.exp(0.12 * angle); // Logarithmic spiral, tightness controlled by 0.12
              if (currentR > r) break;
              
              const x = Math.cos(angle) * currentR;
              const y = Math.sin(angle) * currentR;
              
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
              
              angle += Math.PI * 2 / goldenRatio; // Golden Angle step
              
              if (!isGlowPass && i % 4 === 0) {
                  // Draw small markers
                  ctx.fillStyle = accent;
                  ctx.beginPath();
                  ctx.arc(x, y, 2 + params.complexity * 2, 0, Math.PI * 2);
                  ctx.fill();
              }
          }
          ctx.stroke();

          ctx.restore();
      }

      generateIcosahedronVertices() {
        const phi = (1 + Math.sqrt(5)) / 2;
        const s = 1.0;
        return [
          [0, s, phi*s], [0, -s, phi*s], [0, s, -phi*s], [0, -s, -phi*s],
          [s, phi*s, 0], [-s, phi*s, 0], [s, -phi*s, 0], [-s, -phi*s, 0],
          [phi*s, 0, s], [-phi*s, 0, s], [phi*s, 0, -s], [-phi*s, 0, -s]
        ];
      }

      generateIcosahedronEdges() {
        const edges = [];
        const n = this.icosaVertices.length;
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const p1 = this.icosaVertices[i];
                const p2 = this.icosaVertices[j];
                const distSq = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
                if (distSq < 4.1) { 
                    edges.push([i, j]);
                }
            }
        }
        return edges;
      }

      drawPolyhedron(ctx, cx, cy, r, poly, phase, isGlowPass) {
        if (isGlowPass) return; 

        ctx.save();
        ctx.translate(cx, cy);
        
        const angle = phase * poly.rotationSpeed * 5; 
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const rotateX = ([x, y, z]) => [x, y * cos - z * sin, y * sin + z * cos];
        const rotateY = ([x, y, z]) => [x * cos - z * sin, y, x * sin + z * cos];

        let vertices = this.icosaVertices; 
        let edges = this.icosaEdges;
        let scaleFactor = r * 0.2;

        if (poly.type === 0) {} 
        else if (poly.type === 1) {
            this.drawStar(ctx, r, 5, 0.4); 
            ctx.strokeStyle = poly.color;
            ctx.lineWidth = poly.thickness;
            ctx.stroke();
            ctx.restore();
            return;
        } else if (poly.type === 2) { 
            vertices = [
                [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
                [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1]
            ];
            edges = [
                [0,1],[1,2],[2,3],[3,0], 
                [4,5],[5,6],[6,7],[7,4], 
                [0,4],[1,5],[2,6],[3,7]  
            ];
            scaleFactor = r * 0.4;
        } else if (poly.type === 3) { 
            const h = 1 / Math.sqrt(3);
            vertices = [
                [0, 0, 1.5],
                [1, 0, -h],
                [-0.5, Math.sqrt(3)/2, -h],
                [-0.5, -Math.sqrt(3)/2, -h]
            ];
            edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
            scaleFactor = r * 0.4;
        }

        const projected = vertices.map(v => {
            let v_rotated = rotateY(rotateX(v));
            const z = v_rotated[2] * scaleFactor; 
            const x = v_rotated[0] * scaleFactor;
            const y = v_rotated[1] * scaleFactor;
            return { x, y, z };
        });

        ctx.strokeStyle = poly.color;
        ctx.lineWidth = poly.thickness;

        edges.forEach(([i, j]) => {
            const v1 = projected[i];
            const v2 = projected[j];
            if (v1 && v2) {
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
            }
        });

        ctx.restore();
      }

      drawStar(ctx, r, points, innerRatio) {
          ctx.beginPath();
          for (let i = 0; i < points * 2; i++) {
              const radius = i % 2 === 0 ? r : r * innerRatio;
              const angle = (i / (points * 2)) * Math.PI * 2;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
          }
          ctx.closePath();
      }
    }


    // ====================================================================
    // 4. AUDIO ENGINE CLASS (FIXED: Re-introduced carrierFreq / 2 + New Variety)
    // ====================================================================

    class AudioEngine {
      constructor() {
        this.audioCtx = null;
        this.masterGain = null;
        this.leftOsc = null;
        this.rightOsc = null;
        this.leftPan = null;
        this.rightPan = null;
        this.isAudioPlaying = false;
        
        // NEW: LFO for Panning Modulation
        this.panLFO = null;
        this.panLFOGain = null;


        this.computedCarrier = 0;
        this.computedBeat = 0;
        this.currentElementData = null;
        this.currentWaveform = 'sine';
      }

      initAudioIfNeeded(volume) {
        if (this.audioCtx) return;
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.audioCtx.createGain();
        this.masterGain.gain.value = volume || 0.06;

        this.leftOsc = this.audioCtx.createOscillator();
        this.leftOsc.type = this.currentWaveform;
        this.leftPan = this.audioCtx.createStereoPanner();
        this.leftPan.pan.value = -1; 
        this.rightOsc = this.audioCtx.createOscillator();
        this.rightOsc.type = this.currentWaveform;
        this.rightPan = this.audioCtx.createStereoPanner();
        this.rightPan.pan.value = 1; 

        this.leftOsc.connect(this.leftPan);
        this.leftPan.connect(this.masterGain);
        this.rightOsc.connect(this.rightPan);
        this.rightPan.connect(this.masterGain);
        this.masterGain.connect(this.audioCtx.destination);

        this.leftOsc.start();
        this.rightOsc.start();
        this.isAudioPlaying = false;
        
        // --- NEW: Panning LFO Setup (Spatial Breathing) ---
        // Creates a gentle, slow, spatial shift in the binaural tones
        this.panLFO = this.audioCtx.createOscillator();
        this.panLFO.type = 'sine';
        this.panLFO.frequency.setValueAtTime(0.05, this.audioCtx.currentTime); // ~20-second cycle
        
        this.panLFOGain = this.audioCtx.createGain();
        this.panLFOGain.gain.setValueAtTime(0.3, this.audioCtx.currentTime); // Pan depth (-0.3 to +0.3)

        this.panLFO.connect(this.panLFOGain);
        // LFO shifts the pan value, causing the left/right panners to move slightly
        // We connect the LFO to the *parameter* of the panners, not the panner node itself
        this.panLFOGain.connect(this.leftPan.pan);
        this.panLFOGain.connect(this.rightPan.pan);
        
        this.panLFO.start(0);
      }

      setVolume(volume) {
        if (!this.audioCtx) return;
        this.masterGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
      }

      togglePlay(volume, beat) {
        this.initAudioIfNeeded(volume);
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
        this.isAudioPlaying = !this.isAudioPlaying;

        if (this.isAudioPlaying) {
          this.masterGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
          this.updateFrequencies(beat);
        } else {
          this.masterGain.gain.setTargetAtTime(0.0001, this.audioCtx.currentTime, 0.02);
        }
        return this.isAudioPlaying;
      }

      computeAudioFromSeed(seed, dateStr, elementData) {
        const elements = [elementData.year, elementData.month, elementData.day];
        const primaryElement = elements.reduce((prev, current) => {
          const prevFreq = SOUND_ELEMENT_MAPPING[prev.name.split(' ')[0].toUpperCase()].freq;
          const currentFreq = SOUND_ELEMENT_MAPPING[current.name.split(' ')[0].toUpperCase()].freq;
          return (currentFreq > prevFreq) ? current : prev;
        });

        let carrierFreq = SOUND_ELEMENT_MAPPING[primaryElement.name.split(' ')[0].toUpperCase()].freq;
        const elementalBaseFreq = carrierFreq; // Store the original for display

        // Halve the carrier frequency to drop it an octave
        carrierFreq = carrierFreq / 2;

        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const dayOfMonth = date.getDate();
        const beat = 2.0 + (dayOfMonth / 31) * 8.0;
        
        // NEW: Select waveform
        const primaryElementKey = primaryElement.name.split(' ')[0].toUpperCase();
        const waveformType = WAVEFORM_MAP[primaryElementKey] || 'sine';

        return {
          carrier: carrierFreq,
          beat: beat,
          element: primaryElement,
          elementalBaseFreq: elementalBaseFreq, 
          waveform: waveformType, // NEW
        };
      }

      updateFrequencies(beatOverride) {
        if (!this.currentElementData) return;
        
        const audioData = this.computeAudioFromSeed(
          this.currentElementData.seed, 
          this.currentElementData.dateStr, 
          this.currentElementData.elementData
        );

        this.computedCarrier = audioData.carrier;
        this.computedBeat = parseFloat(beatOverride) || audioData.beat;
        this.currentWaveform = audioData.waveform;

        const leftFreq = this.computedCarrier - (this.computedBeat / 2);
        const rightFreq = this.computedCarrier + (this.computedBeat / 2);

        if (this.leftOsc && this.rightOsc) {
          this.leftOsc.frequency.setTargetAtTime(Math.max(80, leftFreq), this.audioCtx.currentTime, 0.03);
          this.rightOsc.frequency.setTargetAtTime(Math.max(80, rightFreq), this.audioCtx.currentTime, 0.03);
          
          // NEW: Update Waveform
          this.leftOsc.type = this.currentWaveform;
          this.rightOsc.type = this.currentWaveform;
        }
      }

      resumeContext() {
        if (this.audioCtx && this.isAudioPlaying && this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }
      }
    }


    // ====================================================================
    // 5. MAIN APPLICATION LOGIC 
    // ====================================================================
    document.addEventListener('DOMContentLoaded', () => {
      const seedInput = document.getElementById('seed-input');
      const dateInput = document.getElementById('date-input');
      const audioToggle = document.getElementById('audio-toggle');
      const beatRange = document.getElementById('beat-range');
      const volRange = document.getElementById('vol-range');
      const fsOverlay = document.getElementById('fullscreen-overlay');
      const fsStat = document.getElementById('fs-stat');
      const speedDisplay = document.getElementById('speed-display');
      const bloomDisplay = document.getElementById('bloom-display');
      const volumeDisplay = document.getElementById('volume-display');

      const renderer = new MandalaRenderer('mandala-canvas', 'fullscreen-canvas');
      const audioEngine = new AudioEngine();
      
      let currentMandalaParams = null;

      dateInput.valueAsDate = new Date();
      
      // Initial call to set up the UI and initial render
      updateUI();
      
      // --- Core Update Function ---
      function updateUI() {
        const name = seedInput.value || "Initial Config";
        const date = dateInput.value;
        
        const paramsGenerator = new MandalaParams(name, date);
        currentMandalaParams = paramsGenerator;
        renderer.setParams(currentMandalaParams.params);
        audioEngine.currentElementData = currentMandalaParams;

        // 2. Update Meta Displays
        document.getElementById('tibetan-display').textContent = currentMandalaParams.tibetan || '\u0F0B';
        document.getElementById('element-display').textContent = `${currentMandalaParams.elementData.year.name.split(' ')[0]} / ${currentMandalaParams.elementData.month.name.split(' ')[0]} / ${currentMandalaParams.elementData.day.name.split(' ')[0]}`;
        document.getElementById('archetype-display').textContent = `${currentMandalaParams.params.archetype.name.split(' ')[0]} / ${currentMandalaParams.params.complexity}`;

        // 3. Sync Audio Frequencies
        const audioData = syncAudioFrequencies(false);

        // 4. Update Explanation Panels
        updateExplanationPanels(currentMandalaParams.params, currentMandalaParams.elementData, audioData);
        
        // 5. Redraw static frame if not animating
        if (!renderer.isAnimating) {
            renderer.drawInitialFrame();
        }
      }

      function syncAudioFrequencies(isManualBeatChange) {
        if (!currentMandalaParams) return;
        
        const audioData = audioEngine.computeAudioFromSeed(
          currentMandalaParams.seed, 
          currentMandalaParams.dateStr, 
          currentMandalaParams.elementData
        );

        if (!isManualBeatChange && beatRange.dataset.touched === "0") {
          beatRange.value = audioData.beat.toFixed(1);
        }
        
        audioEngine.updateFrequencies(beatRange.value);
        
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
        
        return audioData; // Return the audioData for display
      }

      /* --- Copy Overhaul for Minimalist/Technical Look --- */
      function updateExplanationPanels(params, elementData, audioData) {
        const leftPanel = document.getElementById('left-panel-content');
        const rightPanel = document.getElementById('right-panel-content');
        
        const primaryElementKey = audioData.element.name.split(' ')[0].toUpperCase();
        const primaryAudioElement = SOUND_ELEMENT_MAPPING[primaryElementKey];

        // LEFT PANEL: DATA AND COLOR SPECIFICATION
        let leftHTML = `
          <h3>INPUT SIGNATURE SPECIFICATION</h3>
          <p>The temporal and semantic inputs define three dominant elemental data types that drive the generative rendering process.</p>
          <h4>Input Source Mapping:</h4>
          <ul>
            <li><strong>Year Base:</strong> ${elementData.year.name}. ${elementData.year.meaning.split('. ')[0]}.</li>
            <li><strong>Month Vector:</strong> ${elementData.month.name}. ${elementData.month.meaning.split('. ')[0]}.</li>
            <li><strong>Day Modifier:</strong> ${elementData.day.name}. ${elementData.day.meaning.split('. ')[0]}.</li>
          </ul>
          <h4>Palette Specification: ${params.palette[0].replace('#', 'M-')}</h4>
          <p>Five blended color points are derived from your inputs, optimized for contrast and light spill:</p>
          <ul>
            <li><span class="color-block" style="background-color: ${params.palette[0]}"></span>Tone 1: Primary Structure (${params.palette[0]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[1]}"></span>Tone 2: Secondary Flow (${params.palette[1]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[2]}"></span>Tone 3: Accent / Glow (${params.palette[2]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[3]}"></span>Tone 4: Central Fill (${params.palette[3]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[4]}"></span>Tone 5: Frame Detail (${params.palette[4]})</li>
          </ul>
        `;
        leftPanel.innerHTML = leftHTML;

        // RIGHT PANEL: GEOMETRY AND ACOUSTIC CONFIGURATION
        const primarySymbol = TIBETAN_SYMBOLS[params.symbolIndex];
        let rightHTML = `
          <h3>GEOMETRY & ACOUSTIC CONFIGURATION</h3>
          <p>The core data string dictates the high-level structural matrix and the central operational symbol.</p>
          <h4>Geometry Matrix: ${params.archetype.name} (Complexity Index: ${params.complexity})</h4>
          <p>${params.archetype.meaning}</p>
          
          <h4>Central Operational Symbol</h4>
          <p>The core element holds a specific command or structural mandate:</p>
          <ul>
            <li><strong>${primarySymbol.desc}:</strong> ${primarySymbol.meaning}</li>
          </ul>

          <h4>Acoustic Tone Configuration (Binaural)</h4>
          <p>The dominant input element provides a carrier frequency for a differential stereo tone, promoting focused listening.</p>
          <ul>
            <li><strong>Carrier Waveform:</strong> ${audioData.waveform.toUpperCase()}</li>
            <li><strong>Carrier Frequency:</strong> ${audioData.carrier.toFixed(2)} Hz (Halved from ${primaryAudioElement.note})</li>
            <li><strong>Beat Frequency:</strong> ${audioEngine.computedBeat.toFixed(2)} Hz (The binaural difference)</li>
            <li><strong>Spatial Panning:</strong> ACTIVE (LFO-modulated)</li>
          </ul>
        `;
        rightPanel.innerHTML = rightHTML;
      }
      
      // --- UI Event Listeners ---
      seedInput.addEventListener('input', updateUI);
      dateInput.addEventListener('change', updateUI);

      document.getElementById('random-btn').addEventListener('click', () => {
        seedInput.value = '';
        dateInput.valueAsDate = new Date(new Date().getTime() - Math.floor(Math.random()*365*24*60*60*1000));
        updateUI();
      });

      document.getElementById('animate-btn').addEventListener('click', () => {
        const newState = !renderer.isAnimating;
        renderer.toggleAnimation(newState);
        document.getElementById('animate-btn').textContent = newState ? "Stop Flow" : "Start Flow";
      });

      document.getElementById('bloom-btn').addEventListener('click', () => {
        renderer.isBloom = !renderer.isBloom;
        document.getElementById('bloom-btn').textContent = renderer.isBloom ? "Disable Light Spill" : "Toggle Light Spill";
        updateBloomDisplay();
        if(!renderer.isAnimating) renderer.drawInitialFrame();
      });

      document.getElementById('save-btn').addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `SIG01-${seedInput.value.replace(/ /g, '-')||'config'}.png`;
        link.href = renderer.canvas.toDataURL();
        link.click();
      });

      // Audio Controls
      audioToggle.addEventListener('click', () => {
        const isPlaying = audioEngine.togglePlay(parseFloat(volRange.value), beatRange.value);
        audioToggle.textContent = isPlaying ? 'Acoustic Tone ON' : 'Acoustic Tone OFF';
      });

      volRange.addEventListener('input', () => {
        audioEngine.setVolume(parseFloat(volRange.value));
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      });

      beatRange.addEventListener('input', () => {
        beatRange.dataset.touched = "1";
        syncAudioFrequencies(true); 
      });

      // Fullscreen Logic
      document.getElementById('fullscreen-btn').addEventListener('click', enterFullscreen);
      document.getElementById('fs-exit').addEventListener('click', exitFullscreen);

      function enterFullscreen() {
        fsOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
        if (!renderer.isAnimating) renderer.toggleAnimation(true);
      }

      function exitFullscreen() {
        fsOverlay.classList.remove('active');
        document.body.style.overflow = '';
      }

      // Stat display (for user feedback)
      function showStat(message) {
        fsStat.textContent = message;
        fsStat.classList.add('visible');
        clearTimeout(fsStat.timer);
        fsStat.timer = setTimeout(() => fsStat.classList.remove('visible'), 1000);
      }
      
      function updateBloomDisplay() {
          bloomDisplay.textContent = renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "OFF";
      }

      // --- Global Keyboard Controls (in Fullscreen) ---
      document.addEventListener('keydown', (e) => {
        const inFullscreen = fsOverlay.classList.contains('active');
        
        if (inFullscreen) {
            e.preventDefault(); 
        }

        switch(e.code) {
          case 'Escape':
            if (inFullscreen) exitFullscreen();
            break;
          case 'ArrowLeft': 
            renderer.speed = Math.max(0.1, renderer.speed - 0.25);
            showStat(`Motion Index: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowRight': 
            renderer.speed = Math.min(10, renderer.speed + 0.25);
            showStat(`Motion Index: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowUp': 
            if (!renderer.isBloom) {
                renderer.isBloom = true;
                document.getElementById('bloom-btn').textContent = "Disable Light Spill";
            }
            renderer.bloomIntensity = Math.min(2.0, renderer.bloomIntensity + 0.1);
            showStat(`Light Intensity: ${renderer.bloomIntensity.toFixed(2)}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawInitialFrame();
            break;
          case 'ArrowDown': 
            renderer.bloomIntensity = Math.max(0.1, renderer.bloomIntensity - 0.1);
            if (renderer.bloomIntensity < 0.15) {
                renderer.isBloom = false;
                document.getElementById('bloom-btn').textContent = "Toggle Light Spill";
            }
            showStat(`Light Intensity: ${renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "Light OFF"}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawInitialFrame();
            break;
          case 'NumpadAdd':
          case 'Equal': 
            volRange.value = (parseFloat(volRange.value) + 0.01).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Tone Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
          case 'NumpadSubtract':
          case 'Minus': 
            volRange.value = (parseFloat(volRange.value) - 0.01).toFixed(3);
            volRange.value = Math.max(0.005, parseFloat(volRange.value)).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Tone Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
        }
      });
      
      document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
              audioEngine.resumeContext();
          }
      });

      // Initial state setup
      updateBloomDisplay();
      speedDisplay.textContent = renderer.speed.toFixed(2);
      volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      document.getElementById('bloom-btn').textContent = renderer.isBloom ? "Disable Light Spill" : "Toggle Light Spill";
    });
  </script>
</body>
</html>
