<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tibetan Mandala 路 Lab 3 路 Imogen</title>
  <link rel="icon" href="resources/Imogen.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a1410 0%, #2d1f1a 50%, #1a1410 100%);
      color: #e0d5c5;
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Navigation Bar */
    .navbar {
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(26, 20, 16, 0.95);
      padding: 1rem 2rem;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
      box-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid rgba(255, 215, 0, 0.2);
      backdrop-filter: blur(10px);
    }

    .navbar a {
      color: #c9a227;
      font-size: 0.95rem;
      font-weight: 500;
      text-decoration: none;
      margin: 0 1.5rem;
      padding: 0.5rem 0;
      border-bottom: 2px solid transparent;
      transition: all 0.3s ease;
      letter-spacing: 0.3px;
    }

    .navbar a:hover {
      color: #ffd700;
      border-bottom-color: #ffd700;
    }

    /* Main Container */
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 6rem 2rem 2rem;
      gap: 2rem;
    }

    /* Title */
    .title {
      font-size: 1.8rem;
      font-weight: 300;
      color: #c9a227;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
      text-shadow: 0 0 30px rgba(201, 162, 39, 0.3);
    }

    .subtitle {
      font-size: 0.9rem;
      color: #806040;
      text-align: center;
      max-width: 400px;
    }

    /* Input Section */
    .input-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      width: 100%;
      max-width: 500px;
    }

    .seed-input {
      width: 100%;
      padding: 1rem 1.5rem;
      font-size: 1.2rem;
      font-family: inherit;
      background: rgba(201, 162, 39, 0.05);
      border: 1px solid rgba(201, 162, 39, 0.2);
      border-radius: 12px;
      color: #ffd700;
      text-align: center;
      transition: all 0.3s ease;
      outline: none;
    }

    .seed-input::placeholder {
      color: #605040;
    }

    .seed-input:focus {
      border-color: #c9a227;
      box-shadow: 0 0 20px rgba(201, 162, 39, 0.2);
      background: rgba(201, 162, 39, 0.08);
    }

    .seed-display {
      font-size: 0.8rem;
      color: #605040;
      font-family: monospace;
      letter-spacing: 1px;
    }

    /* Canvas Container */
    .canvas-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #mandala-canvas {
      border-radius: 8px;
      box-shadow:
        0 0 60px rgba(201, 162, 39, 0.15),
        0 0 120px rgba(201, 162, 39, 0.08),
        inset 0 0 60px rgba(0, 0, 0, 0.5);
      transition: box-shadow 0.5s ease;
    }

    #mandala-canvas:hover {
      box-shadow:
        0 0 80px rgba(201, 162, 39, 0.2),
        0 0 160px rgba(201, 162, 39, 0.1),
        inset 0 0 60px rgba(0, 0, 0, 0.5);
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 0.7rem 1.5rem;
      font-size: 0.85rem;
      font-family: inherit;
      font-weight: 500;
      background: rgba(201, 162, 39, 0.15);
      border: 1px solid rgba(201, 162, 39, 0.3);
      border-radius: 8px;
      color: #c9a227;
      cursor: pointer;
      transition: all 0.3s ease;
      letter-spacing: 0.5px;
    }

    .btn:hover {
      background: rgba(201, 162, 39, 0.25);
      border-color: rgba(201, 162, 39, 0.5);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(201, 162, 39, 0.2);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.small {
      padding: 0.5rem 0.8rem;
      font-size: 0.75rem;
      min-width: 2.5rem;
    }

    .speed-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .speed-display {
      font-size: 0.75rem;
      color: #706050;
      min-width: 3rem;
      text-align: center;
    }

    /* Fullscreen Mode */
    .fullscreen-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #0a0806;
      z-index: 9999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .fullscreen-overlay.active {
      display: flex;
    }

    .fullscreen-overlay canvas {
      max-width: 95vmin;
      max-height: 95vmin;
      border-radius: 8px;
    }

    .fullscreen-controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      align-items: center;
      padding: 1rem 2rem;
      background: rgba(10, 8, 6, 0.9);
      border-radius: 12px;
      border: 1px solid rgba(201, 162, 39, 0.2);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-overlay:hover .fullscreen-controls,
    .fullscreen-controls:focus-within {
      opacity: 1;
    }

    .fullscreen-hint {
      position: fixed;
      top: 2rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: #504030;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-overlay:hover .fullscreen-hint {
      opacity: 1;
    }

    /* Info Panel */
    .info-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      max-width: 500px;
      width: 100%;
      padding: 1rem;
      background: rgba(201, 162, 39, 0.02);
      border-radius: 12px;
      border: 1px solid rgba(201, 162, 39, 0.1);
    }

    .info-item {
      text-align: center;
    }

    .info-label {
      font-size: 0.7rem;
      color: #605040;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 0.3rem;
    }

    .info-value {
      font-size: 1rem;
      color: #c9a227;
      font-weight: 500;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .navbar {
        flex-wrap: wrap;
        padding: 1rem;
      }

      .navbar a {
        margin: 0.5rem 1rem;
        font-size: 0.85rem;
      }

      .title {
        font-size: 1.4rem;
      }

      .container {
        padding: 5rem 1rem 1rem;
        gap: 1.5rem;
      }

      #mandala-canvas {
        max-width: 90vw;
        max-height: 90vw;
      }

      .info-panel {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>

<body>

  <!-- Navigation Bar -->
  <div class="navbar">
    <a href="../index.html">Caldwell's Repository</a>
    <a href="../apocrypha.html">Apocrypha</a>
    <a href="../imogen.html">Imogen</a>
  </div>

  <!-- Main Container -->
  <div class="container">
    <h1 class="title">Tibetan Mandala</h1>
    <p class="subtitle">Sacred geometry from seed. Each character manifests a unique cosmic diagram.</p>

    <div class="input-section">
      <input
        type="text"
        class="seed-input"
        id="seed-input"
        placeholder="Enter your mantra..."
        autocomplete="off"
        spellcheck="false"
      >
      <div class="seed-display" id="seed-display">seed: 0</div>
    </div>

    <div class="canvas-container">
      <canvas id="mandala-canvas" width="500" height="500"></canvas>
    </div>

    <div class="controls">
      <button class="btn" id="random-btn">Random Mantra</button>
      <button class="btn" id="animate-btn">Animate</button>
      <div class="speed-controls">
        <button class="btn small" id="slower-btn">-</button>
        <span class="speed-display" id="speed-display">1.0x</span>
        <button class="btn small" id="faster-btn">+</button>
      </div>
      <button class="btn" id="bloom-btn">Bloom</button>
      <div class="speed-controls" id="bloom-controls" style="display: none;">
        <button class="btn small" id="bloom-down-btn">-</button>
        <span class="speed-display" id="bloom-display">60%</span>
        <button class="btn small" id="bloom-up-btn">+</button>
      </div>
      <button class="btn" id="fullscreen-btn">Fullscreen</button>
      <button class="btn" id="save-btn">Save Image</button>
    </div>

    <div class="info-panel">
      <div class="info-item">
        <div class="info-label">Gates</div>
        <div class="info-value" id="info-gates">-</div>
      </div>
      <div class="info-item">
        <div class="info-label">Rings</div>
        <div class="info-value" id="info-rings">-</div>
      </div>
      <div class="info-item">
        <div class="info-label">Petals</div>
        <div class="info-value" id="info-petals">-</div>
      </div>
      <div class="info-item">
        <div class="info-label">Style</div>
        <div class="info-value" id="info-style">-</div>
      </div>
    </div>
  </div>

  <!-- Fullscreen Overlay -->
  <div class="fullscreen-overlay" id="fullscreen-overlay">
    <canvas id="fullscreen-canvas" width="800" height="800"></canvas>
    <div class="fullscreen-hint">ESC to exit 路 arrows adjust speed/bloom 路 B toggle bloom</div>
    <div class="fullscreen-controls">
      <button class="btn small" id="fs-slower-btn">-</button>
      <span class="speed-display" id="fs-speed-display">1.0x</span>
      <button class="btn small" id="fs-faster-btn">+</button>
      <button class="btn" id="fs-bloom-btn">Bloom</button>
      <div class="speed-controls" id="fs-bloom-controls" style="display: none;">
        <button class="btn small" id="fs-bloom-down-btn">-</button>
        <span class="speed-display" id="fs-bloom-display">60%</span>
        <button class="btn small" id="fs-bloom-up-btn">+</button>
      </div>
      <button class="btn" id="fs-exit-btn">Exit</button>
    </div>
  </div>

  <script>
    // ============================================
    // SEEDED PSEUDO-RANDOM NUMBER GENERATOR
    // ============================================

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function stringToSeed(str) {
      if (!str || str.length === 0) return 0;
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.codePointAt(i);
        hash = ((hash << 5) - hash + char) | 0;
        if (char > 0xFFFF) i++;
      }
      return Math.abs(hash);
    }

    // ============================================
    // TIBETAN COLOR PALETTE
    // Five sacred colors: white, blue, yellow, red, green
    // ============================================

    const TIBETAN_COLORS = {
      white: '#F5F5F0',
      blue: '#1E4D8C',
      yellow: '#D4A012',
      red: '#B22222',
      green: '#228B22',
      gold: '#C9A227'
    };

    function getTibetanPalette(rand) {
      const palettes = [
        // Traditional five colors
        [TIBETAN_COLORS.white, TIBETAN_COLORS.blue, TIBETAN_COLORS.yellow, TIBETAN_COLORS.red, TIBETAN_COLORS.green],
        // Fire/wrathful
        [TIBETAN_COLORS.red, TIBETAN_COLORS.yellow, TIBETAN_COLORS.gold, TIBETAN_COLORS.white, TIBETAN_COLORS.red],
        // Peaceful
        [TIBETAN_COLORS.white, TIBETAN_COLORS.blue, TIBETAN_COLORS.gold, TIBETAN_COLORS.green, TIBETAN_COLORS.yellow],
        // Earth
        [TIBETAN_COLORS.yellow, TIBETAN_COLORS.red, TIBETAN_COLORS.green, TIBETAN_COLORS.gold, TIBETAN_COLORS.blue]
      ];

      const names = ['Five Wisdoms', 'Wrathful', 'Peaceful', 'Earth'];
      const idx = Math.floor(rand() * palettes.length);

      return {
        colors: palettes[idx],
        name: names[idx]
      };
    }

    // ============================================
    // TIBETAN MANDALA DRAWING
    // ============================================

    const canvas = document.getElementById('mandala-canvas');
    const ctx = canvas.getContext('2d');
    const fsCanvas = document.getElementById('fullscreen-canvas');
    const fsCtx = fsCanvas.getContext('2d');

    let bloomCanvas = document.createElement('canvas');
    let bloomCtx = bloomCanvas.getContext('2d');

    let currentParams = null;
    let animationId = null;
    let isAnimating = false;
    let isFullscreen = false;
    let animationSpeed = 1.0;
    let isBloomEnabled = false;
    let bloomIntensity = 0.6;

    function getCanvasProps(targetCanvas) {
      const centerX = targetCanvas.width / 2;
      const centerY = targetCanvas.height / 2;
      const maxRadius = Math.min(centerX, centerY) - 10;
      return { centerX, centerY, maxRadius };
    }

    function generateMandalaParams(seed) {
      const rand = mulberry32(seed);

      const palette = getTibetanPalette(rand);
      const gateCount = 4; // Traditional Tibetan mandalas have 4 gates
      const ringCount = 3 + Math.floor(rand() * 4);
      const petalCounts = [8, 16, 32][Math.floor(rand() * 3)];
      const hasFireBorder = rand() > 0.5;
      const hasVajraBorder = rand() > 0.4;
      const squareLayers = 1 + Math.floor(rand() * 3);
      const style = Math.floor(rand() * 3);
      const styleNames = ['Kalachakra', 'Medicine Buddha', 'Wheel of Life'];

      // Generate ring configurations
      const rings = [];
      for (let i = 0; i < ringCount; i++) {
        rings.push({
          radiusRatio: 0.25 + (i / ringCount) * 0.5,
          colorIdx: Math.floor(rand() * palette.colors.length),
          pattern: Math.floor(rand() * 4),
          width: 1 + rand() * 2
        });
      }

      return {
        seed,
        palette,
        gateCount,
        ringCount,
        petalCounts,
        hasFireBorder,
        hasVajraBorder,
        squareLayers,
        rings,
        style,
        styleName: styleNames[style]
      };
    }

    function applyBloom(targetCtx, targetCanvas) {
      if (!isBloomEnabled) return;

      if (bloomCanvas.width !== targetCanvas.width || bloomCanvas.height !== targetCanvas.height) {
        bloomCanvas.width = targetCanvas.width;
        bloomCanvas.height = targetCanvas.height;
      }

      bloomCtx.clearRect(0, 0, bloomCanvas.width, bloomCanvas.height);
      bloomCtx.drawImage(targetCanvas, 0, 0);

      bloomCtx.filter = 'blur(15px) brightness(1.5)';
      bloomCtx.globalCompositeOperation = 'source-over';
      bloomCtx.drawImage(targetCanvas, 0, 0);
      bloomCtx.filter = 'none';

      targetCtx.globalCompositeOperation = 'lighter';
      targetCtx.globalAlpha = bloomIntensity;
      targetCtx.drawImage(bloomCanvas, 0, 0);

      bloomCtx.filter = 'blur(30px) brightness(1.2)';
      bloomCtx.clearRect(0, 0, bloomCanvas.width, bloomCanvas.height);
      bloomCtx.drawImage(targetCanvas, 0, 0);
      bloomCtx.filter = 'none';

      targetCtx.globalAlpha = bloomIntensity * 0.5;
      targetCtx.drawImage(bloomCanvas, 0, 0);

      targetCtx.globalCompositeOperation = 'source-over';
      targetCtx.globalAlpha = 1;
    }

    function drawMandala(params, rotationPhase = 0, targetCtx = ctx, targetCanvas = canvas) {
      const { centerX, centerY, maxRadius } = getCanvasProps(targetCanvas);

      // Dark background
      targetCtx.fillStyle = '#0a0806';
      targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);

      // Fire border (outermost)
      if (params.hasFireBorder) {
        drawFireBorder(targetCtx, centerX, centerY, maxRadius, params, rotationPhase);
      }

      // Vajra border
      if (params.hasVajraBorder) {
        drawVajraBorder(targetCtx, centerX, centerY, maxRadius * 0.92, params, rotationPhase);
      }

      // Outer square palace with gates
      drawSquarePalace(targetCtx, centerX, centerY, maxRadius * 0.85, params, rotationPhase);

      // Concentric rings
      params.rings.forEach((ring, idx) => {
        drawRing(targetCtx, centerX, centerY, maxRadius * ring.radiusRatio * 0.85, ring, params, rotationPhase, idx);
      });

      // Lotus petals
      drawLotusPetals(targetCtx, centerX, centerY, maxRadius * 0.35, params, rotationPhase);

      // Inner lotus petals
      drawLotusPetals(targetCtx, centerX, centerY, maxRadius * 0.2, params, rotationPhase, true);

      // Central deity space
      drawCenter(targetCtx, centerX, centerY, maxRadius * 0.12, params);

      applyBloom(targetCtx, targetCanvas);
    }

    function drawFireBorder(ctx, cx, cy, radius, params, phase) {
      const flameCount = 32;

      for (let i = 0; i < flameCount; i++) {
        const angle = (i / flameCount) * Math.PI * 2 + phase * 0.2;
        const flameHeight = radius * (0.08 + Math.sin(i * 3 + phase * 2) * 0.03);

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);

        // Draw flame
        ctx.beginPath();
        ctx.moveTo(radius - flameHeight, 0);
        ctx.quadraticCurveTo(radius - flameHeight/2, -flameHeight/3, radius, 0);
        ctx.quadraticCurveTo(radius - flameHeight/2, flameHeight/3, radius - flameHeight, 0);

        const gradient = ctx.createLinearGradient(radius - flameHeight, 0, radius, 0);
        gradient.addColorStop(0, TIBETAN_COLORS.yellow);
        gradient.addColorStop(0.5, TIBETAN_COLORS.gold);
        gradient.addColorStop(1, TIBETAN_COLORS.red);
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.restore();
      }
    }

    function drawVajraBorder(ctx, cx, cy, radius, params, phase) {
      const count = 16;
      ctx.strokeStyle = TIBETAN_COLORS.gold;
      ctx.lineWidth = 2;

      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2 + phase * 0.1;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);

        // Vajra symbol (simplified)
        const size = radius * 0.08;
        ctx.beginPath();
        // Center bulb
        ctx.arc(radius, 0, size * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = TIBETAN_COLORS.gold;
        ctx.fill();

        // Prongs
        ctx.beginPath();
        ctx.moveTo(radius - size, 0);
        ctx.lineTo(radius + size, 0);
        ctx.moveTo(radius, -size * 0.5);
        ctx.lineTo(radius, size * 0.5);
        ctx.stroke();

        ctx.restore();
      }

      // Circle border
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawSquarePalace(ctx, cx, cy, size, params, phase) {
      const colors = params.palette.colors;

      for (let layer = 0; layer < params.squareLayers; layer++) {
        const layerSize = size * (1 - layer * 0.15);
        const color = colors[layer % colors.length];

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(phase * 0.05);

        // Draw square
        ctx.strokeStyle = color;
        ctx.lineWidth = 3 - layer;

        // Main square
        ctx.beginPath();
        ctx.rect(-layerSize/2, -layerSize/2, layerSize, layerSize);
        ctx.stroke();

        // T-shaped gates at cardinal points
        const gateWidth = layerSize * 0.15;
        const gateDepth = layerSize * 0.1;

        for (let g = 0; g < params.gateCount; g++) {
          const gateAngle = (g / params.gateCount) * Math.PI * 2;

          ctx.save();
          ctx.rotate(gateAngle);

          // Draw T-gate
          ctx.fillStyle = colors[(layer + g) % colors.length];
          ctx.beginPath();
          ctx.rect(-gateWidth/2, layerSize/2 - gateDepth, gateWidth, gateDepth * 2);
          ctx.fill();
          ctx.stroke();

          // Gate steps
          for (let s = 0; s < 3; s++) {
            const stepWidth = gateWidth * (1 - s * 0.2);
            const stepY = layerSize/2 + gateDepth + s * gateDepth * 0.3;
            ctx.beginPath();
            ctx.rect(-stepWidth/2, stepY, stepWidth, gateDepth * 0.25);
            ctx.fillStyle = colors[(layer + s) % colors.length];
            ctx.fill();
            ctx.stroke();
          }

          ctx.restore();
        }

        ctx.restore();
      }
    }

    function drawRing(ctx, cx, cy, radius, ring, params, phase, ringIndex) {
      const color = params.palette.colors[ring.colorIdx];

      ctx.strokeStyle = color;
      ctx.lineWidth = ring.width;

      switch(ring.pattern) {
        case 0: // Solid ring
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.stroke();
          break;

        case 1: // Dotted/beaded ring
          const dotCount = 32;
          ctx.fillStyle = color;
          for (let i = 0; i < dotCount; i++) {
            const angle = (i / dotCount) * Math.PI * 2 + phase * (ringIndex % 2 ? 0.1 : -0.1);
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            ctx.beginPath();
            ctx.arc(x, y, ring.width, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 2: // Vajra pattern ring
          const vajraCount = 8;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.stroke();

          for (let i = 0; i < vajraCount; i++) {
            const angle = (i / vajraCount) * Math.PI * 2 + phase * 0.05;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(angle);

            // Small vajra
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(radius, 0, ring.width * 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
          }
          break;

        case 3: // Double ring
          ctx.beginPath();
          ctx.arc(cx, cy, radius - ring.width, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx, cy, radius + ring.width, 0, Math.PI * 2);
          ctx.stroke();
          break;
      }
    }

    function drawLotusPetals(ctx, cx, cy, radius, params, phase, inner = false) {
      const petalCount = inner ? 8 : params.petalCounts;
      const color = inner ? params.palette.colors[0] : params.palette.colors[3];
      const altColor = inner ? params.palette.colors[4] : params.palette.colors[1];

      for (let i = 0; i < petalCount; i++) {
        const angle = (i / petalCount) * Math.PI * 2 + phase * (inner ? -0.1 : 0.1);

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);

        // Petal shape
        const petalLength = radius * 0.8;
        const petalWidth = radius * 0.3;

        ctx.beginPath();
        ctx.moveTo(radius * 0.3, 0);
        ctx.quadraticCurveTo(radius * 0.5, -petalWidth, radius * 0.3 + petalLength, 0);
        ctx.quadraticCurveTo(radius * 0.5, petalWidth, radius * 0.3, 0);

        // Gradient fill
        const gradient = ctx.createLinearGradient(radius * 0.3, 0, radius * 0.3 + petalLength, 0);
        gradient.addColorStop(0, i % 2 ? color : altColor);
        gradient.addColorStop(1, i % 2 ? altColor : color);
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.strokeStyle = TIBETAN_COLORS.gold;
        ctx.lineWidth = 0.5;
        ctx.stroke();

        ctx.restore();
      }

      // Central ring
      ctx.beginPath();
      ctx.arc(cx, cy, radius * 0.35, 0, Math.PI * 2);
      ctx.strokeStyle = TIBETAN_COLORS.gold;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function drawCenter(ctx, cx, cy, radius, params) {
      // Central bindu (sacred point)
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      gradient.addColorStop(0, TIBETAN_COLORS.white);
      gradient.addColorStop(0.5, params.palette.colors[0]);
      gradient.addColorStop(1, params.palette.colors[1]);

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      // Inner circles
      ctx.beginPath();
      ctx.arc(cx, cy, radius * 0.6, 0, Math.PI * 2);
      ctx.strokeStyle = TIBETAN_COLORS.gold;
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(cx, cy, radius * 0.3, 0, Math.PI * 2);
      ctx.fillStyle = TIBETAN_COLORS.gold;
      ctx.fill();
    }

    // ============================================
    // UI & INTERACTION
    // ============================================

    const seedInput = document.getElementById('seed-input');
    const seedDisplay = document.getElementById('seed-display');
    const randomBtn = document.getElementById('random-btn');
    const animateBtn = document.getElementById('animate-btn');
    const saveBtn = document.getElementById('save-btn');
    const slowerBtn = document.getElementById('slower-btn');
    const fasterBtn = document.getElementById('faster-btn');
    const speedDisplay = document.getElementById('speed-display');
    const bloomBtn = document.getElementById('bloom-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const fullscreenOverlay = document.getElementById('fullscreen-overlay');
    const fsSlowerBtn = document.getElementById('fs-slower-btn');
    const fsFasterBtn = document.getElementById('fs-faster-btn');
    const fsSpeedDisplay = document.getElementById('fs-speed-display');
    const fsBloomBtn = document.getElementById('fs-bloom-btn');
    const fsExitBtn = document.getElementById('fs-exit-btn');
    const bloomControls = document.getElementById('bloom-controls');
    const bloomDisplay = document.getElementById('bloom-display');
    const bloomDownBtn = document.getElementById('bloom-down-btn');
    const bloomUpBtn = document.getElementById('bloom-up-btn');
    const fsBloomControls = document.getElementById('fs-bloom-controls');
    const fsBloomDisplay = document.getElementById('fs-bloom-display');
    const fsBloomDownBtn = document.getElementById('fs-bloom-down-btn');
    const fsBloomUpBtn = document.getElementById('fs-bloom-up-btn');

    function updateMandala(text) {
      const seed = stringToSeed(text);
      seedDisplay.textContent = `seed: ${seed}`;

      currentParams = generateMandalaParams(seed);
      drawMandala(currentParams);

      document.getElementById('info-gates').textContent = currentParams.gateCount;
      document.getElementById('info-rings').textContent = currentParams.ringCount;
      document.getElementById('info-petals').textContent = currentParams.petalCounts;
      document.getElementById('info-style').textContent = currentParams.styleName;
    }

    let debounceTimer;
    seedInput.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        updateMandala(e.target.value);
      }, 100);
    });

    const mantras = [
      'om mani padme hum',
      'om tare tuttare ture soha',
      'gate gate paragate',
      'om ah hum vajra guru',
      'tayata om bekandze',
      'om ami dewa hrih',
      'om muni muni maha muni',
      'namo amitabha',
      'om vajrapani hum',
      'om shanti shanti shanti'
    ];

    randomBtn.addEventListener('click', () => {
      const mantra = mantras[Math.floor(Math.random() * mantras.length)];
      const suffix = Math.floor(Math.random() * 108);
      seedInput.value = `${mantra} ${suffix}`;
      updateMandala(seedInput.value);
    });

    let rotationPhase = 0;

    function animate() {
      if (!isAnimating) return;

      rotationPhase += 0.003 * animationSpeed;

      if (isFullscreen) {
        drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
      } else {
        drawMandala(currentParams, rotationPhase);
      }

      animationId = requestAnimationFrame(animate);
    }

    animateBtn.addEventListener('click', () => {
      isAnimating = !isAnimating;
      animateBtn.textContent = isAnimating ? 'Stop' : 'Animate';

      if (isAnimating) {
        animate();
      } else {
        cancelAnimationFrame(animationId);
        drawMandala(currentParams, 0);
      }
    });

    const speedSteps = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 3.0, 4.0];

    function updateSpeedDisplay() {
      const text = animationSpeed.toFixed(animationSpeed < 1 ? 2 : 1) + 'x';
      speedDisplay.textContent = text;
      fsSpeedDisplay.textContent = text;
    }

    function adjustSpeed(delta) {
      const currentIdx = speedSteps.findIndex(s => s >= animationSpeed);
      const newIdx = Math.max(0, Math.min(speedSteps.length - 1, currentIdx + delta));
      animationSpeed = speedSteps[newIdx];
      updateSpeedDisplay();
    }

    slowerBtn.addEventListener('click', () => adjustSpeed(-1));
    fasterBtn.addEventListener('click', () => adjustSpeed(1));
    fsSlowerBtn.addEventListener('click', () => adjustSpeed(-1));
    fsFasterBtn.addEventListener('click', () => adjustSpeed(1));

    function toggleBloom() {
      isBloomEnabled = !isBloomEnabled;
      const text = isBloomEnabled ? 'Bloom On' : 'Bloom';
      bloomBtn.textContent = text;
      fsBloomBtn.textContent = text;

      bloomControls.style.display = isBloomEnabled ? 'flex' : 'none';
      fsBloomControls.style.display = isBloomEnabled ? 'flex' : 'none';

      if (isFullscreen) {
        drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
      } else {
        drawMandala(currentParams, rotationPhase);
      }
    }

    bloomBtn.addEventListener('click', toggleBloom);
    fsBloomBtn.addEventListener('click', toggleBloom);

    function updateBloomDisplay() {
      const text = Math.round(bloomIntensity * 100) + '%';
      bloomDisplay.textContent = text;
      fsBloomDisplay.textContent = text;
    }

    function adjustBloom(delta) {
      bloomIntensity = Math.max(0.1, Math.min(1.5, bloomIntensity + delta));
      updateBloomDisplay();

      if (isFullscreen) {
        drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
      } else {
        drawMandala(currentParams, rotationPhase);
      }
    }

    bloomDownBtn.addEventListener('click', () => adjustBloom(-0.1));
    bloomUpBtn.addEventListener('click', () => adjustBloom(0.1));
    fsBloomDownBtn.addEventListener('click', () => adjustBloom(-0.1));
    fsBloomUpBtn.addEventListener('click', () => adjustBloom(0.1));

    function enterFullscreen() {
      isFullscreen = true;
      fullscreenOverlay.classList.add('active');

      const size = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      fsCanvas.width = size;
      fsCanvas.height = size;

      if (!isAnimating) {
        isAnimating = true;
        animateBtn.textContent = 'Stop';
        animate();
      }

      drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
    }

    function exitFullscreen() {
      isFullscreen = false;
      fullscreenOverlay.classList.remove('active');

      if (isAnimating) {
        drawMandala(currentParams, rotationPhase);
      }
    }

    fullscreenBtn.addEventListener('click', enterFullscreen);
    fsExitBtn.addEventListener('click', exitFullscreen);

    document.addEventListener('keydown', (e) => {
      if (isFullscreen) {
        switch(e.key) {
          case 'Escape':
            exitFullscreen();
            break;
          case 'ArrowLeft':
            adjustSpeed(-1);
            e.preventDefault();
            break;
          case 'ArrowRight':
            adjustSpeed(1);
            e.preventDefault();
            break;
          case 'ArrowUp':
            if (isBloomEnabled) {
              adjustBloom(0.1);
              e.preventDefault();
            }
            break;
          case 'ArrowDown':
            if (isBloomEnabled) {
              adjustBloom(-0.1);
              e.preventDefault();
            }
            break;
          case 'b':
          case 'B':
            toggleBloom();
            break;
          case ' ':
            isAnimating = !isAnimating;
            animateBtn.textContent = isAnimating ? 'Stop' : 'Animate';
            if (isAnimating) {
              animate();
            } else {
              cancelAnimationFrame(animationId);
            }
            e.preventDefault();
            break;
        }
      }
    });

    window.addEventListener('resize', () => {
      if (isFullscreen) {
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.9;
        fsCanvas.width = size;
        fsCanvas.height = size;
        drawMandala(currentParams, rotationPhase, fsCtx, fsCanvas);
      }
    });

    saveBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      const seedText = seedInput.value || 'tibetan-mandala';
      link.download = `mandala-${seedText.replace(/[^a-z0-9]/gi, '_')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    updateMandala('');
  </script>

</body>
</html>
