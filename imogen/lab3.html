<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mandala Generator ¬∑ Lab 3 ¬∑ Imogen</title>
  <link rel="icon" href="resources/Imogen.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    /* ---------------------------------------------------- */
    /* 1. MINIMALIST DESIGN AESTHETIC */
    /* ---------------------------------------------------- */
    :root {
      --color-primary-accent: #C8AA6E; /* Polished Brass / Metallic Accent */
      --color-primary-canvas: #C8AA6E; /* Canvas highlight color */
      --color-neutral-dark: #111111;   /* Primary Background */
      --color-neutral-medium: #888888; /* Secondary text */
      --color-bg-light: #EEEEEE;      /* White/Light Background for Contrast Elements */
      --color-bg-panel: #1A1A1A;      /* Dark Panel Background */
      --color-text-light: #EEEEEE;    /* Primary Text Color */
      --color-border: #333333;        /* Dark Border Color */
      --shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--color-neutral-dark);
      color: var(--color-text-light);
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }
    .navbar {
      display: flex; justify-content: center; align-items: center;
      background: var(--color-bg-panel); padding: 1.2rem 2rem;
      position: sticky; top: 0; width: 100%; z-index: 1000;
      border-bottom: 1px solid var(--color-border); box-shadow: var(--shadow-soft);
    }
    .navbar a { color: var(--color-neutral-medium); font-size: 0.8rem; font-weight: 500; text-decoration: none; margin: 0 2rem; transition: color 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
    .navbar a:hover { color: var(--color-primary-accent); }

    .container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5rem 2rem 3rem; gap: 3rem; width: 95%; max-width: 1500px; margin: 0 auto; }
    .main-content-grid { display: flex; gap: 4rem; width: 100%; align-items: flex-start; }
    .center-column { display: flex; flex-direction: column; align-items: center; gap: 2rem; flex: 0 0 650px; }

    /* Info Panels - Structured, Technical Look */
    .explanation-panel { flex: 1; max-width: 420px; padding: 2.2rem; background: var(--color-bg-panel); border-radius: 4px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); position: sticky; top: 7rem; min-height: 400px; }
    .explanation-panel h3 { color: var(--color-primary-accent); font-size: 1rem; font-weight: 500; border-bottom: 1px solid var(--color-border); padding-bottom: 0.75rem; margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px; }
    .explanation-panel h4 { color: var(--color-text-light); font-size: 0.9rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.6rem; }
    .explanation-panel p, .explanation-panel ul, .explanation-panel li { font-size: 0.85rem; color: var(--color-neutral-medium); margin-bottom: 0.8rem; line-height: 1.5; list-style-position: inside; padding-left: 0; }
    .explanation-panel strong { color: var(--color-text-light); font-weight: 600; }
    .color-block { display: inline-block; width: 14px; height: 14px; border-radius: 50%; margin-right: 8px; border: 1px solid var(--color-border); vertical-align: middle;}

    .header-group { text-align: center; max-width: 900px; padding: 0 1rem; margin-bottom: 0rem; }
    .title { font-size: 3rem; font-weight: 300; color: var(--color-text-light); letter-spacing: 5px; text-transform: uppercase; margin-bottom: 0.5rem; }
    .subtitle { font-size: 1rem; color: var(--color-neutral-medium); font-weight: 400; letter-spacing: 0.5px; }

    /* Input Card - Dark and clean */
    .input-group { display: flex; flex-direction: column; gap: 1.5rem; width: 100%; background: var(--color-bg-panel); padding: 1.5rem 2rem; border-radius: 4px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); }
    .input-row { display: flex; gap: 1rem; }
    
    .text-input, .date-input { 
      background: var(--color-neutral-dark); border: 1px solid var(--color-border); border-radius: 4px; 
      color: var(--color-text-light); padding: 0.9rem; font-family: inherit; outline: none; transition: border-color 0.3s, box-shadow 0.3s;
    }
    .text-input { flex: 2; font-size: 1rem; }
    .date-input { flex: 1; font-size: 0.9rem; text-align: center; cursor: pointer; }
    .text-input:focus, .date-input:focus { border-color: var(--color-primary-accent); box-shadow: 0 0 0 3px rgba(200, 170, 110, 0.2); background: #222; }

    /* Meta Info */
    .meta-display { display: flex; justify-content: space-between; align-items: flex-end; border-top: 1px solid var(--color-border); padding-top: 1.2rem; margin-top: 0.5rem; }
    .meta-box { display: flex; flex-direction: column; }
    .meta-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.5px; color: var(--color-neutral-medium); margin-bottom: 4px; font-weight: 500; }
    .meta-value { color: var(--color-primary-accent); font-size: 1rem; font-weight: 700; }
    .rune-font { font-size: 1.6rem; line-height: 1; color: var(--color-primary-accent); letter-spacing: 2px; }

    /* Canvas */
    .canvas-wrapper { position: relative; margin: 1rem 0; background: #080706; border-radius: 50%; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.8), inset 0 0 10px rgba(255, 255, 255, 0.1); }
    #mandala-canvas { border-radius: 50%; display: block; max-width: 90vw; height: auto; cursor: crosshair; }

    /* Controls - Clean, button-heavy */
    .controls { display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: center; max-width: 650px; }
    .btn { background: var(--color-bg-panel); border: 1px solid var(--color-border); color: var(--color-neutral-medium); padding: 0.8rem 1.4rem; border-radius: 4px; cursor: pointer; transition: all 0.3s; font-size: 0.8rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }
    .btn:hover { border-color: var(--color-primary-accent); color: var(--color-primary-accent); background: #222; }

    .audio-controls { display: flex; gap: 0.5rem; align-items: center; padding: 0.6rem 1rem; border-radius: 4px; background: var(--color-bg-panel); border: 1px solid var(--color-border); flex-wrap: wrap; max-width: 650px; }
    .audio-controls label { font-size: 0.65rem; color: var(--color-neutral-medium); text-transform: uppercase; letter-spacing: 0.5px; }
    .audio-controls input[type="range"] { width: 50px; appearance: none; height: 3px; background: var(--color-border); border-radius: 2px; }
    .audio-controls input[type="range"]::-webkit-slider-thumb { appearance: none; width: 10px; height: 10px; border-radius: 50%; background: var(--color-primary-accent); cursor: pointer; }

    /* Fullscreen */
    .fullscreen-overlay { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 9999; justify-content: center; align-items: center; }
    .fullscreen-overlay.active { display: flex; cursor: none; }
    
    .fs-hover-zone { position: absolute; bottom: 0; left: 0; width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; z-index: 10000; transition: opacity 0.3s; pointer-events: none; }
    .fs-controls { background: rgba(30,30,30,0.95); border: 1px solid var(--color-border); padding: 15px 25px; border-radius: 4px; display: flex; gap: 15px; opacity: 0; transition: opacity 0.3s; pointer-events: auto; }
    .fs-controls .btn { background: var(--color-primary-accent); color: var(--color-neutral-dark); border-color: var(--color-primary-accent); font-weight: 600; }
    .fs-controls .btn:hover { background: #B99C5E; }
    .fullscreen-overlay.active:hover .fs-hover-zone { opacity: 1; pointer-events: auto; }
    .fs-hover-zone:hover .fs-controls { opacity: 1; }

    .fs-stat { background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 4px; position: fixed; top: 20px; right: 20px; color: var(--color-primary-canvas); font-size: 0.8rem; transition: opacity 0.3s; opacity: 0; pointer-events: none; }
    .fs-stat.visible { opacity: 1; }

    @media (max-width: 1200px) {
      .main-content-grid { flex-direction: column; align-items: center; }
      .explanation-panel { max-width: 650px; width: 100%; position: static; }
      .center-column { flex: 1; }
    }
    @media (max-width: 650px) {
      .input-row { flex-direction: column; }
      .controls { gap: 0.8rem; }
      .audio-controls { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>

<body>

  <div class="navbar">
    <a href="../index.html">Caldwell's Repository</a>
    <a href="../apocrypha.html">Apocrypha</a>
    <a href="../imogen.html">Imogen</a>
  </div>

  <div class="container">
    <div class="header-group">
      <h1 class="title">SIG.01: Generative Geometry</h1>
      <p class="subtitle">
        An engineered visualization of semantic and temporal input data.<br>
        Rendering a unique structural diagram based on user-defined parameters.
      </p>
    </div>

    <div class="main-content-grid">
      <div class="explanation-panel left-panel">
        <div id="left-panel-content">
          </div>
      </div>

      <div class="center-column">
        <div class="input-group">
          <div class="input-row">
            <input type="text" class="text-input" id="seed-input" placeholder="Project Name or Data String..." autocomplete="off">
            <input type="date" class="date-input" id="date-input">
          </div>
          
          <div class="meta-display">
            <div class="meta-box">
              <span class="meta-label">Runic Signature</span>
              <span class="meta-value rune-font" id="rune-display"></span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Input Signature</span>
              <span class="meta-value" id="element-display">VOID / VOID</span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Complexity Index</span>
              <span class="meta-value" id="archetype-display">Grid Type / 0.0</span>
            </div>
          </div>
        </div>

        <div class="canvas-wrapper">
          <canvas id="mandala-canvas" width="650" height="650"></canvas>
        </div>

        <div class="controls">
          <button class="btn" id="random-btn">Generate New Data</button>
          <button class="btn" id="animate-btn">Start Flow</button>
          <button class="btn" id="bloom-btn">Toggle Light Spill</button>
          <button class="btn" id="save-btn">Export Image (PNG)</button>

          <select class="btn" id="script-selector" style="cursor: pointer;">
            <option value="runic">Runic (Elder Futhark)</option>
            <option value="tibetan">Tibetan</option>
            <option value="devanagari">Sanskrit (Devanagari)</option>
            <option value="theban">Theban (Witches' Alphabet)</option>
            <option value="coptic">Coptic</option>
            <option value="hebrew">Hebrew</option>
          </select>

          <div class="audio-controls" id="audio-controls">
            <button class="btn" id="audio-toggle">Tone OFF</button>

            <label for="waveform-select">Wave</label>
            <select id="waveform-select" style="padding: 4px; background: var(--color-neutral-dark); color: var(--color-text-light); border: 1px solid var(--color-border); border-radius: 3px; font-size: 0.7rem;">
              <option value="auto">Auto</option>
              <option value="sine">Sine</option>
              <option value="triangle">Triangle</option>
              <option value="sawtooth">Sawtooth</option>
              <option value="square">Square</option>
            </select>

            <label for="beat-range">Beat</label>
            <input id="beat-range" type="range" min="1" max="12" step="0.1" value="6" data-touched="0">
            <label for="vol-range">Vol</label>
            <input id="vol-range" type="range" min="0" max="0.3" step="0.005" value="0.06">
            <label for="filter-range">Filter</label>
            <input id="filter-range" type="range" min="200" max="8000" step="50" value="4000">
            <label for="detune-range">Detune</label>
            <input id="detune-range" type="range" min="-50" max="50" step="1" value="0">
            <label for="lfo-range">Drift</label>
            <input id="lfo-range" type="range" min="0.01" max="0.5" step="0.01" value="0.05">
            <label for="harmonics-range">Harmonics</label>
            <input id="harmonics-range" type="range" min="0" max="1" step="0.05" value="0">
            <label for="interval-range">Interval</label>
            <input id="interval-range" type="range" min="0" max="12" step="1" value="0">
            <label for="reverb-range">Reverb</label>
            <input id="reverb-range" type="range" min="0" max="1" step="0.05" value="0">
          </div>
          
          <button class="btn" id="fullscreen-btn">Full Screen Mode (F11)</button>
        </div>
      </div>

      <div class="explanation-panel right-panel">
        <div id="right-panel-content">
          </div>
      </div>

    </div>
  </div>

  <div class="fullscreen-overlay" id="fullscreen-overlay">
    <canvas id="fullscreen-canvas"></canvas>
    
    <div class="fs-stat" id="fs-stat"></div>

    <div class="fs-hover-zone">
      <div class="fs-controls">
        <button class="btn" id="fs-exit">Exit (ESC)</button>
        <div style="display:flex;flex-direction:column;align-items:flex-start;color:#EEE;margin-left:8px;font-size:0.8rem;">
          <div>[‚Üë/‚Üì] Light Intensity: <span id="bloom-display">0.60</span></div>
          <div>[‚Üê/‚Üí] Motion Index: <span id="speed-display">1.00</span></div>
          <div>[+/-] Tone Volume: <span id="volume-display">0.06</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====================================================================
    // 1. CONSTANTS & UTILITIES (Refined for Minimalist/Technical Language)
    // ====================================================================
    const W = 650, H = 650; 

    // Multi-Script Mapping Systems
    const SCRIPT_MAPPINGS = {
      // Elder Futhark Runes (U+16A0-U+16FF)
      runic: {
        'a': '·ö®', 'b': '·õí', 'c': '·ö≤', 'd': '·õû', 'e': '·õñ', 'f': '·ö†', 'g': '·ö∑', 'h': '·ö∫',
        'i': '·õÅ', 'j': '·õÉ', 'k': '·ö≤', 'l': '·õö', 'm': '·õó', 'n': '·öæ', 'o': '·õü', 'p': '·õà',
        'q': '·ö≤', 'r': '·ö±', 's': '·õä', 't': '·õè', 'u': '·ö¢', 'v': '·öπ', 'w': '·öπ', 'x': '·ö≤·õä',
        'y': '·õÉ', 'z': '·õâ', ' ': '‚ñµ',
        'th': '·ö¶', 'ng': '·õú', 'ei': '·õá', 'ae': '·ö®·õñ',
        font: "'Segoe UI Symbol', 'Noto Sans Runic', sans-serif"
      },

      // Tibetan (U+0F00-U+0FFF)
      tibetan: {
        'a': '‡Ω®', 'b': '‡Ωñ', 'c': '‡Ωô', 'd': '‡Ωë', 'e': '‡Ω∫', 'f': '‡Ωï', 'g': '‡ΩÇ', 'h': '‡Ωß',
        'i': '‡Ω≤', 'j': '‡Ωá', 'k': '‡ΩÄ', 'l': '‡Ω£', 'm': '‡Ωò', 'n': '‡Ωì', 'o': '‡Ωº', 'p': '‡Ωî',
        'q': '‡ΩÄ', 'r': '‡Ω¢', 's': '‡Ω¶', 't': '‡Ωè', 'u': '‡Ω¥', 'v': '‡Ωù', 'w': '‡Ωù', 'x': '‡ΩÄ‡Ω¶',
        'y': '‡Ω°', 'z': '‡Ωü', ' ': '‚ñµ',
        font: "'Noto Sans Tibetan', 'Microsoft Himalaya', sans-serif"
      },

      // Devanagari/Sanskrit (U+0900-U+097F)
      devanagari: {
        'a': '‡§Ö', 'b': '‡§¨', 'c': '‡§ö', 'd': '‡§¶', 'e': '‡§è', 'f': '‡§´', 'g': '‡§ó', 'h': '‡§π',
        'i': '‡§á', 'j': '‡§ú', 'k': '‡§ï', 'l': '‡§≤', 'm': '‡§Æ', 'n': '‡§®', 'o': '‡§ì', 'p': '‡§™',
        'q': '‡§ï', 'r': '‡§∞', 's': '‡§∏', 't': '‡§§', 'u': '‡§â', 'v': '‡§µ', 'w': '‡§µ', 'x': '‡§ï‡•ç‡§∑',
        'y': '‡§Ø', 'z': '‡§ú', ' ': '‚ñµ',
        font: "'Noto Sans Devanagari', 'Mangal', sans-serif"
      },

      // Theban/Witches' Alphabet - using close Unicode approximations
      theban: {
        'a': 'êåÄ', 'b': 'êåÅ', 'c': 'êåÇ', 'd': 'êåÉ', 'e': 'êåÑ', 'f': 'êåÖ', 'g': 'êåÜ', 'h': 'êåá',
        'i': 'êåâ', 'j': 'êåâ', 'k': 'êåä', 'l': 'êåã', 'm': 'êåå', 'n': 'êåç', 'o': 'êåè', 'p': 'êåê',
        'q': 'êåí', 'r': 'êåì', 's': 'êåî', 't': 'êåï', 'u': 'êåñ', 'v': 'êåñ', 'w': 'êåÖ', 'x': 'êåó',
        'y': 'êåô', 'z': 'êåÜ', ' ': '‚ñµ',
        font: "'Noto Sans Old Italic', 'Segoe UI Historic', sans-serif"
      },

      // Coptic (U+2C80-U+2CFF)
      coptic: {
        'a': '‚≤Ä', 'b': '‚≤Ç', 'c': '‚≤§', 'd': '‚≤Ü', 'e': '‚≤à', 'f': '‚≤™', 'g': '‚≤Ñ', 'h': 'œ®',
        'i': '‚≤í', 'j': '‚≥í', 'k': '‚≤î', 'l': '‚≤ñ', 'm': '‚≤ò', 'n': '‚≤ö', 'o': '‚≤û', 'p': '‚≤†',
        'q': '‚≤î', 'r': '‚≤¢', 's': '‚≤§', 't': '‚≤¶', 'u': '‚≤®', 'v': '‚≤Ç', 'w': '‚≤∞', 'x': '‚≤ú',
        'y': '‚≤®', 'z': '‚≤å', ' ': '‚ñµ',
        font: "'Noto Sans Coptic', 'Antinoou', sans-serif"
      },

      // Hebrew (U+0590-U+05FF)
      hebrew: {
        'a': '◊ê', 'b': '◊ë', 'c': '◊õ', 'd': '◊ì', 'e': '◊î', 'f': '◊§', 'g': '◊í', 'h': '◊ó',
        'i': '◊ô', 'j': '◊ô', 'k': '◊õ', 'l': '◊ú', 'm': '◊û', 'n': '◊†', 'o': '◊¢', 'p': '◊§',
        'q': '◊ß', 'r': '◊®', 's': '◊°', 't': '◊™', 'u': '◊ï', 'v': '◊ï', 'w': '◊ï', 'x': '◊õ◊°',
        'y': '◊ô', 'z': '◊ñ', ' ': '‚ñµ',
        font: "'Noto Sans Hebrew', 'David', 'Arial Hebrew', sans-serif"
      }
    };

    // Maintain backward compatibility
    const LATIN_TO_RUNE = SCRIPT_MAPPINGS.runic;

    // Element definitions with lookup keys
    const ELEMENTS = {
      METAL: { key: 'METAL', name: 'Alloy (Metal)', colors: ['#D0D0D0', '#A0A0A0', '#707070', '#555555', '#FFFFFF'], meaning: 'Represents Structural Integrity and Data Clarity.' },
      WATER: { key: 'WATER', name: 'Fluidic (Water)', colors: ['#30404C', '#576775', '#7A8C98', '#9DB0C0', '#B0B0B0'], meaning: 'Represents System Flow and Dynamic Input.' },
      WOOD: { key: 'WOOD', name: 'Composite (Wood)', colors: ['#2D5743', '#4E8A6E', '#7DB49A', '#BCC8BF', '#A0A0A0'], meaning: 'Represents Growth Vectors and Expansion.' },
      FIRE: { key: 'FIRE', name: 'Thermal (Fire)', colors: ['#D24B4F', '#A04A4E', '#E98E92', '#F9C2C4', '#FEE6E7'], meaning: 'Represents Energy State and Transformation Rate.' },
      EARTH: { key: 'EARTH', name: 'Foundation (Earth)', colors: ['#8A735E', '#A6927C', '#C2B19F', '#DDD0C3', '#909090'], meaning: 'Represents Core Stability and Base Coordinates.' }
    };
    const MONTH_ELEMENTS = [
      ELEMENTS.EARTH, ELEMENTS.EARTH, ELEMENTS.WOOD, ELEMENTS.WOOD, ELEMENTS.FIRE, ELEMENTS.FIRE,
      ELEMENTS.METAL, ELEMENTS.METAL, ELEMENTS.WATER, ELEMENTS.WATER, ELEMENTS.EARTH, ELEMENTS.EARTH
    ];
    // Solfeggio / Planetary Frequencies
    const SOUND_ELEMENT_MAPPING = {
      METAL: { freq: 432, note: "432 Hz", explanation: "Target for Cognitive Clarity." },
      WATER: { freq: 194.18, note: "194 Hz", explanation: "Target for System Dynamics." },
      WOOD: { freq: 285, note: "285 Hz", explanation: "Target for Vector Optimization." },
      FIRE: { freq: 396, note: "396 Hz", explanation: "Target for State Transition." },
      EARTH: { freq: 172.8, note: "172 Hz", explanation: "Target for Base Stability." }
    };

    // Waveform selection based on Element
    const WAVEFORM_MAP = {
      'METAL': 'triangle', // Sharp, clear, structural
      'WATER': 'sine',     // Smooth, fluid
      'WOOD': 'sawtooth',  // Growing, forward
      'FIRE': 'square',    // Intense, energetic
      'EARTH': 'sine'      // Stable, fundamental
    };

    // Symbol systems for each script with traditional meanings
    const SCRIPT_SYMBOLS = {
      runic: [
        { char: '·ö†', desc: 'Fehu (Wealth)', meaning: 'Abundance, prosperity, and mobile power. The primal fire of creation.' },
        { char: '·ö¢', desc: 'Uruz (Aurochs)', meaning: 'Strength, vitality, and raw untamed potential. The life force.' },
        { char: '·ö¶', desc: 'Thurisaz (Thor)', meaning: 'Protection, defense, and directed force. The hammer of change.' },
        { char: '·ö®', desc: 'Ansuz (Odin)', meaning: 'Wisdom, communication, and divine breath. The voice of insight.' },
        { char: '·ö±', desc: 'Raido (Journey)', meaning: 'Movement, rhythm, and right action. The path forward.' },
        { char: '·ö≤', desc: 'Kenaz (Torch)', meaning: 'Knowledge, illumination, and creative fire. The inner light.' },
        { char: '·õä', desc: 'Sowilo (Sun)', meaning: 'Success, victory, and vital energy. Solar power and clarity.' },
        { char: '·öπ', desc: 'Wunjo (Joy)', meaning: 'Harmony, fellowship, and aligned will. The binding force.' },
        { char: '·õû', desc: 'Dagaz (Dawn)', meaning: 'Transformation, breakthrough, and awakening. The turning point.' },
        { char: '·õü', desc: 'Othala (Heritage)', meaning: 'Ancestral power, foundation, and sacred enclosure. The roots.' },
        { char: '·õö', desc: 'Laguz (Water)', meaning: 'Flow, intuition, and the unconscious depths. The primal waters.' }
      ],
      tibetan: [
        { char: '‡Ω®', desc: 'A (Primordial)', meaning: 'The source of all sound. Beginning of manifestation and pure awareness.' },
        { char: '‡Ω®‡Ωº‡Ωæ', desc: 'Om (Sacred)', meaning: 'Universal consciousness. The sound of creation and divine presence.' },
        { char: '‡Ωî‡Ωë‡æ®', desc: 'Padma (Lotus)', meaning: 'Purity rising from mud. Spiritual awakening and enlightenment.' },
        { char: '‡Ωò', desc: 'Ma (Mother)', meaning: 'Compassion and nurturing. The feminine principle of wisdom.' },
        { char: '‡Ωß‡Ω±‡Ω¥‡æÉ', desc: 'Hum (Wisdom)', meaning: 'Indestructible reality. Diamond mind and transformative power.' },
        { char: '‡Ω¶‡æ≠‡Ω±', desc: 'Soha (Offering)', meaning: 'Dedication and completion. Sealing of intention and practice.' },
        { char: '‡Ωñ‡Ωõ‡æ≤', desc: 'Vajra (Diamond)', meaning: 'Indestructible truth. Clarity cutting through illusion.' },
        { char: '‡Ωë‡æ∑‡Ω¢‡æ®', desc: 'Dharma (Truth)', meaning: 'Universal law. The path of righteousness and cosmic order.' },
        { char: '‡Ω¶‡ΩÑ‡æí', desc: 'Sangha (Community)', meaning: 'Sacred fellowship. Unity in spiritual practice and purpose.' },
        { char: '‡Ωñ‡Ωº‡Ωë‡æ∑‡Ω≤', desc: 'Bodhi (Awakening)', meaning: 'Perfect enlightenment. Realization of ultimate truth.' },
        { char: '‡Ω§‡Ω±‡Ωì‡æü‡Ω≤', desc: 'Shanti (Peace)', meaning: 'Supreme tranquility. Cessation of suffering and inner calm.' }
      ],
      devanagari: [
        { char: '‡•ê', desc: 'Om (Pranava)', meaning: 'The primordial sound. Creation, preservation, and dissolution unified.' },
        { char: '‡§∂‡•ç‡§∞‡•Ä', desc: 'Shri (Sacred)', meaning: 'Auspiciousness and prosperity. Divine grace and abundance.' },
        { char: '‡§ó‡§Ç', desc: 'Gam (Ganesha)', meaning: 'Removing obstacles. Wisdom and new beginnings blessed.' },
        { char: '‡§π‡•ç‡§∞‡•Ä‡§Ç', desc: 'Hreem (Shakti)', meaning: 'Divine feminine energy. Creative power and transformation.' },
        { char: '‡§ï‡•ç‡§≤‡•Ä‡§Ç', desc: 'Kleem (Attraction)', meaning: 'Magnetic force. Drawing desires into manifestation.' },
        { char: '‡§ê‡§Ç', desc: 'Aim (Saraswati)', meaning: 'Knowledge and arts. Flow of creative wisdom and speech.' },
        { char: '‡§∏‡§§‡•ç', desc: 'Sat (Truth)', meaning: 'Pure existence. Eternal unchanging reality beyond form.' },
        { char: '‡§ö‡§ø‡§§‡•ç', desc: 'Chit (Consciousness)', meaning: 'Awareness itself. The light of pure knowing.' },
        { char: '‡§Ü‡§®‡§®‡•ç‡§¶', desc: 'Ananda (Bliss)', meaning: 'Supreme joy. The nature of realized consciousness.' },
        { char: '‡§¨‡•ç‡§∞‡§π‡•ç‡§Æ', desc: 'Brahman (Absolute)', meaning: 'Ultimate reality. The infinite source beyond conception.' },
        { char: '‡§∂‡§æ‡§®‡•ç‡§§‡§ø', desc: 'Shanti (Peace)', meaning: 'Threefold peace. Body, mind, spirit in harmony.' }
      ],
      theban: [
        { char: 'êåÄ', desc: 'A (Beginning)', meaning: 'First breath of magic. Initiation into hidden knowledge.' },
        { char: 'êåÅ', desc: 'B (Protection)', meaning: 'Shield against harm. Warding and defensive mysteries.' },
        { char: 'êåÇ', desc: 'C (Circle)', meaning: 'Sacred boundary. The witch\'s circle of power cast.' },
        { char: 'êåÉ', desc: 'D (Door)', meaning: 'Threshold between worlds. Gateway to otherworldly realms.' },
        { char: 'êåÑ', desc: 'E (Elements)', meaning: 'Command of natural forces. Mastery over earth and sky.' },
        { char: 'êåÖ', desc: 'F (Fire)', meaning: 'Transformative flame. Purification and magical will ignited.' },
        { char: 'êåÜ', desc: 'G (Growth)', meaning: 'Green witchcraft. Herbs, healing, and natural magic.' },
        { char: 'êåá', desc: 'H (Hex)', meaning: 'Binding and cursing. Shadow work and karmic balance.' },
        { char: 'êåâ', desc: 'I (Intuition)', meaning: 'Psychic sight. Third eye opened to hidden truths.' },
        { char: 'êåå', desc: 'M (Moon)', meaning: 'Lunar mysteries. Tides of magic waxing and waning.' },
        { char: 'êåî', desc: 'S (Spell)', meaning: 'Woven enchantment. Words of power spoken into being.' }
      ],
      coptic: [
        { char: '‚≤Ä', desc: 'Alpha (Source)', meaning: 'Divine beginning. The eternal word spoken into creation.' },
        { char: '‚≤∞', desc: 'Omega (End)', meaning: 'Divine completion. All returns to the source of being.' },
        { char: '‚≤¨', desc: 'Chi (Christ)', meaning: 'Anointed light. Spiritual awakening and divine presence.' },
        { char: '‚≤†', desc: 'Pi (Spirit)', meaning: 'Holy pneuma. Breath of life and sacred inspiration.' },
        { char: '‚≤§', desc: 'Sophia (Wisdom)', meaning: 'Divine knowledge. Feminine aspect of cosmic intelligence.' },
        { char: '‚≤ò', desc: 'Maria (Mother)', meaning: 'Sacred femininity. Compassion and divine nurturing.' },
        { char: '‚≤ö', desc: 'Nous (Mind)', meaning: 'Divine intellect. Pure consciousness transcending thought.' },
        { char: '‚≤ñ', desc: 'Logos (Word)', meaning: 'Creative principle. Divine reason structuring reality.' },
        { char: '‚≤™', desc: 'Phos (Light)', meaning: 'Uncreated radiance. Illumination of spiritual truth.' },
        { char: '‚≤Ä‚≤Ö‚≤Å', desc: 'Agape (Love)', meaning: 'Divine love. Unconditional embrace of all existence.' },
        { char: '‚≤å', desc: 'Zoe (Life)', meaning: 'Eternal vitality. The animating force of creation.' }
      ],
      hebrew: [
        { char: '◊ê', desc: 'Aleph (Ox)', meaning: 'Primal strength and divine unity. Silent breath of creation.' },
        { char: '◊ë', desc: 'Bet (House)', meaning: 'Container of blessing. Divine dwelling and cosmic structure.' },
        { char: '◊í', desc: 'Gimel (Camel)', meaning: 'Loving-kindness flowing. Movement of divine generosity.' },
        { char: '◊ì', desc: 'Dalet (Door)', meaning: 'Humility and receptivity. Opening to divine wisdom.' },
        { char: '◊î', desc: 'Heh (Window)', meaning: 'Revelation and breath. Divine presence revealed in world.' },
        { char: '◊ï', desc: 'Vav (Hook)', meaning: 'Connection unifying opposites. The pillar joining heaven and earth.' },
        { char: '◊ô', desc: 'Yod (Hand)', meaning: 'Divine point of creation. The spark of infinite potential.' },
        { char: '◊ó', desc: 'Chet (Fence)', meaning: 'Transcendent life force. Boundary containing sacred energy.' },
        { char: '◊ò', desc: 'Tet (Serpent)', meaning: 'Hidden goodness. Coiled potential awaiting manifestation.' },
        { char: '◊õ', desc: 'Kaf (Palm)', meaning: 'Receiving and giving. Divine crown of manifestation.' },
        { char: '◊©', desc: 'Shin (Tooth)', meaning: 'Divine fire consuming. Three flames of eternal truth.' }
      ]
    };

    // Maintain backward compatibility
    const RUNIC_SYMBOLS = SCRIPT_SYMBOLS.runic;

    const ARCHETYPES = [
      { name: 'Four-Gate Structure', index: 0, meaning: 'A traditional four-quadrant grid, representing a protected and symmetrical data processing environment.' },
      { name: 'Triad Intersection Matrix', index: 1, meaning: 'A pattern of intersecting triangles, symbolizing the convergence of three primary data streams.' },
      { name: 'Crystalline Flow Net', index: 2, meaning: 'A complex, high-density projection, focusing on distributed data flow and structural complexity.' },
      { name: 'Spiral Recursion Field', index: 3, meaning: 'A logarithmic spiral pattern, reflecting iterative data generation and exponential growth vectors.' }
    ];

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }
    
    function interpolateColor(color1, color2, factor) {
      const rgb1 = hexToRgb(color1);
      const rgb2 = hexToRgb(color2);
      const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * factor);
      const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * factor);
      const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * factor);
      return `rgb(${r},${g},${b})`;
    }

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // ====================================================================
    // 2. MANDALA PARAMETERS CLASS
    // ====================================================================

    class MandalaParams {
      constructor(name, dateStr, scriptType = 'runic') {
        this.name = name;
        this.dateStr = dateStr;
        this.scriptType = scriptType;
        this.scriptMapping = SCRIPT_MAPPINGS[scriptType];
        this.runic = this.convertToScript(name, scriptType);
        this.seed = this.getNumericSeed(this.runic);
        this.rand = mulberry32(this.seed);
        this.elementData = this.getElementsFromDate(dateStr);
        this.params = this.generateParams();
      }

      convertToScript(text, scriptType = 'runic') {
        if (!text) return "";
        const mapping = SCRIPT_MAPPINGS[scriptType];
        if (!mapping) return text;

        let lower = text.toLowerCase();
        let result = "";
        for (let i = 0; i < lower.length; i++) {
          let char = lower[i];
          // Check for digraphs (only for runic)
          if (scriptType === 'runic' && i < lower.length - 1) {
            const digraph = lower.slice(i, i+2);
            if (mapping[digraph]) {
              result += mapping[digraph];
              i++; continue;
            }
          }
          result += mapping[char] || "";
        }
        return result;
      }

      getNumericSeed(str) {
        let hash = 0;
        if (!str || str.length === 0) return 123456789;
        for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash |= 0; 
        }
        return Math.abs(hash);
      }

      getElementsFromDate(dateStr) {
        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const year = date.getFullYear();
        const month = date.getMonth(); 
        const day = date.getDay();

        const yearDigit = year % 10;
        let yearElement;
        if (yearDigit === 4 || yearDigit === 9) yearElement = ELEMENTS.WOOD;
        else if (yearDigit === 5 || yearDigit === 0) yearElement = ELEMENTS.FIRE;
        else if (yearDigit === 6 || yearDigit === 1) yearElement = ELEMENTS.EARTH;
        else if (yearDigit === 7 || yearDigit === 2) yearElement = ELEMENTS.METAL;
        else yearElement = ELEMENTS.WATER;

        const monthElement = MONTH_ELEMENTS[month];
        let dayElement;
        if (day === 0) dayElement = ELEMENTS.EARTH; 
        else if (day === 1) dayElement = ELEMENTS.WATER; 
        else if (day === 2) dayElement = ELEMENTS.FIRE; 
        else if (day === 3) dayElement = ELEMENTS.WOOD; 
        else if (day === 4) dayElement = ELEMENTS.WATER; 
        else if (day === 5) dayElement = ELEMENTS.METAL; 
        else dayElement = ELEMENTS.FIRE;

        return { year: yearElement, month: monthElement, day: dayElement };
      }

      generateParams() {
        const rand = this.rand;
        const seed = this.seed;
        const randomnessFactor = (rand() - 0.5) * 0.05;

        // 1. Color Palette Synthesis
        const p = [...this.elementData.year.colors];
        const m = [...this.elementData.month.colors];
        const d = [...this.elementData.day.colors];
        let colorPool = [...p, ...m, ...d].sort(() => rand() - 0.5);

        // We use the Polished Brass accent for the bright glow/detail
        const ACCENT_BRASS = "#C8AA6E";

        const colorStrings = [ 
          colorPool[0] || p[0], // Primary color (Ring Base)
          colorPool[1] || m[0], // Secondary color (Inner Geometry)
          ACCENT_BRASS,         // Tertiary color (Primary Accent/Detail)
          colorPool[3] || p[1], // Accent 1 (Text/Center Fill)
          colorPool[4] || m[1]  // Accent 2 (Center outline/core)
        ];

        // 2. Geometry Parameters
        const archetypeIndex = seed % ARCHETYPES.length; // Max is now 3
        const archetype = ARCHETYPES[archetypeIndex];

        let complexity = ((seed % 900) / 900) + 0.1;
        complexity = parseFloat((complexity + randomnessFactor).toFixed(2));
        complexity = Math.max(0.1, Math.min(1.0, complexity));

        const ringCountBase = 7 + Math.floor(complexity * 12);
        const ringCount = Math.max(5, ringCountBase + Math.floor(randomnessFactor * 10));

        const rings = [];
        for(let i=0; i<ringCount; i++) {
          rings.push({
            r: 0.1 + (i/ringCount)*0.9,
            style: Math.floor(rand() * 6), // Max ring style is now 5 (0-5)
            width: (1 + rand() * 4 * complexity) * (1 + randomnessFactor * 0.5),
            colorIndex: i % 3 // Cycle through the first three (including the brass accent)
          });
        }
        
        // 3. Symbol Selection (Bias towards elemental syllable)
        const symbolSet = SCRIPT_SYMBOLS[this.scriptType] || SCRIPT_SYMBOLS.runic;
        let symbolIndex = seed % symbolSet.length;
        const elementalSyllables = { METAL: 6, WATER: 10, WOOD: 7, FIRE: 8, EARTH: 9 };
        const yearKey = this.elementData.year.key;

        if (elementalSyllables[yearKey] !== undefined && rand() < 0.35 && symbolIndex < symbolSet.length) {
            symbolIndex = elementalSyllables[yearKey] % symbolSet.length;
        }

        // 4. Random Polyhedrons (Complex 3D-like wireframes)
        const polyCount = rand() < 0.40 ? Math.floor(rand() * 4) + 1 : 0; 
        const polyhedrons = [];
        for(let i=0; i<polyCount; i++) {
            polyhedrons.push({
                type: Math.floor(rand() * 4), 
                radiusFactor: 0.3 + rand() * 0.6,
                color: ACCENT_BRASS, // Always use the brass accent for these wireframes
                thickness: 0.8 + rand() * 3,
                rotationSpeed: (rand() - 0.5) * 0.08,
            });
        }

        return {
          seed, palette: colorStrings, archetype, complexity: complexity.toFixed(2),
          rings, symbolIndex, polyhedrons, solidRotation: rand() * Math.PI * 2,
          scriptFont: this.scriptMapping.font,
          scriptType: this.scriptType,
        };
      }
    }

    // ====================================================================
    // 3. MANDALA RENDERER CLASS
    // ====================================================================

    class MandalaRenderer {
      constructor(canvasId, fullscreenCanvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.fsCanvas = document.getElementById(fullscreenCanvasId);
        this.fsCtx = this.fsCanvas.getContext('2d');

        this.params = null;
        this.isAnimating = false;
        this.animationId = null;
        this.phase = 0;

        this.width = W;
        this.height = H;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.speed = 1.0;
        this.isBloom = true; 
        this.bloomIntensity = 0.6; 

        this.icosaVertices = this.generateIcosahedronVertices();
        this.icosaEdges = this.generateIcosahedronEdges();
      }

      setParams(params) {
        this.params = params;
        this.drawInitialFrame(); // Ensure a static frame is drawn immediately
      }
      
      drawInitialFrame() {
        if (!this.params) return;
        this.drawFrame(this.ctx, this.width, this.height, this.phase);
      }

      toggleAnimation(state) {
        this.isAnimating = state;
        if (state) this.loop();
        else cancelAnimationFrame(this.animationId);
      }

      loop() {
        if (!this.isAnimating) return;
        this.phase += 0.01 * this.speed;

        const size = Math.min(this.canvas.width, this.canvas.height);
        this.drawFrame(this.ctx, size, size, this.phase);

        if (document.getElementById('fullscreen-overlay').classList.contains('active')) {
          const w = window.innerWidth;
          const h = window.innerHeight;
          this.fsCanvas.width = w;
          this.fsCanvas.height = h;
          this.drawFrame(this.fsCtx, w, h, this.phase);
        }

        this.animationId = requestAnimationFrame(this.loop.bind(this));
      }

      drawFrame(ctx, w, h, phase) {
        ctx.save();
        /* The canvas itself must remain dark for the glowing effect to work */
        ctx.fillStyle = '#080706'; 
        ctx.fillRect(0, 0, w, h);

        // --- 1. GLOW LAYER (Faint, broad blur) ---
        if (this.isBloom) {
          const blurSize1 = 15 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize1}px)`;
          ctx.globalAlpha = 0.4;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 2. CORE LAYER (Tighter, brighter blur) ---
        if (this.isBloom) {
          const blurSize2 = 5 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize2}px)`;
          ctx.globalAlpha = 0.6;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 3. DETAIL LAYER (Sharp, full color) ---
        ctx.filter = 'none';
        ctx.globalAlpha = 1.0;
        this.drawMandalaElements(ctx, w, h, phase, false);

        ctx.restore();
      }

      drawMandalaElements(ctx, w, h, phase, isGlowPass) {
        const cx = w / 2, cy = h / 2;
        const radius = Math.min(w, h) / 2 * 0.95;

        this.params.rings.forEach((ring, i) => {
          this.drawRing(ctx, cx, cy, radius * ring.r, ring, this.params, phase, i, isGlowPass);
        });

        this.params.polyhedrons.forEach(poly => {
          this.drawPolyhedron(ctx, cx, cy, radius * poly.radiusFactor, poly, phase, isGlowPass);
        });

        switch(this.params.archetype.index) {
          case 0: this.drawVajraPalace(ctx, cx, cy, radius * 0.4, this.params, phase, isGlowPass); break;
          case 1: this.drawSriYantra(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
          case 2: this.drawIcosahedronGrid(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
          case 3: this.drawFibonacciSpiral(ctx, cx, cy, radius * 0.8, this.params, phase, isGlowPass); break;
        }

        this.drawCenterSyllable(ctx, cx, cy, radius * 0.1, this.params, phase, isGlowPass);
      }

      drawRing(ctx, cx, cy, r, ring, params, phase, idx, isGlowPass) {
        const color1 = params.palette[ring.colorIndex];
        const color2 = params.palette[(ring.colorIndex + 1) % 3];
        const factor = (r / (H / 2 * 0.95) + Math.sin(phase * 0.5) * 0.5 + 0.5) % 1;
        const interpolatedColor = interpolateColor(color1, color2, factor);
        
        ctx.strokeStyle = interpolatedColor;
        ctx.lineWidth = ring.width;
        ctx.beginPath();
        
        if (isGlowPass || ring.style === 0) { 
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
          return;
        }

        const complexityFactor = parseFloat(params.complexity) * 0.5;

        if (ring.style === 1) { 
          const dots = 36 + Math.floor(complexityFactor * 40);
          for(let i=0; i<dots; i++) {
            const a = (i/dots)*Math.PI*2 + phase*(idx%2?0.1:-0.1);
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.moveTo(x, y);
            ctx.arc(x, y, ring.width*1.5, 0, Math.PI*2);
          }
          ctx.fillStyle=interpolatedColor;
          ctx.fill();
        } else if (ring.style === 4) { 
            ctx.setLineDash([ring.width * 2, ring.width * 2]);
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]); 
        } else if (ring.style === 2) { 
          ctx.arc(cx, cy, r - ring.width/2, 0, Math.PI*2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx, cy, r + ring.width/2, 0, Math.PI*2);
          ctx.stroke();
        } else if (ring.style === 3) {
          const symbolSet = SCRIPT_SYMBOLS[params.scriptType] || SCRIPT_SYMBOLS.runic;
          const symbol = symbolSet[params.symbolIndex % symbolSet.length].char;
          const count = 15 + Math.floor(complexityFactor * 15);
          const scriptFont = params.scriptFont || "'Segoe UI Symbol', sans-serif";
          ctx.font = `${ring.width * 5}px ${scriptFont}`;
          ctx.fillStyle = interpolatedColor;
          for(let i=0; i<count; i++) {
            const a = (i/count)*Math.PI*2 + phase*0.1;
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(a + Math.PI/2);
            ctx.fillText(symbol, 0, 0);
            ctx.restore();
          }
        } else if (ring.style === 5) { // Undulating Wave
          const points = 360;
          // Frequency scales with complexity, offset by rotation phase
          const frequency = 8 + complexityFactor * 20; 
          const amplitude = ring.width * 2; 

          ctx.beginPath();
          for(let i=0; i<=points; i++) {
            const a = (i/points)*Math.PI*2;
            const displacement = Math.sin(a * frequency + phase * 4) * amplitude;
            const currentR = r + displacement;
            const x = cx + Math.cos(a)*currentR;
            const y = cy + Math.sin(a)*currentR;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        }
      }

      drawCenterSyllable(ctx, cx, cy, r, params, phase, isGlowPass) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fillStyle = params.palette[3];
        ctx.fill();
        ctx.strokeStyle = params.palette[4];
        ctx.lineWidth = 2;
        ctx.stroke();

        if (isGlowPass) return;

        const symbolSet = SCRIPT_SYMBOLS[params.scriptType] || SCRIPT_SYMBOLS.runic;
        const symbolData = symbolSet[params.symbolIndex % symbolSet.length];
        ctx.fillStyle = params.palette[2]; // Use Brass Accent
        const scriptFont = params.scriptFont || "'Segoe UI Symbol', sans-serif";
        ctx.font = `${r*0.8}px ${scriptFont}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbolData.char, cx, cy);
      }
      
      drawVajraPalace(ctx, cx, cy, r, params, phase, isGlowPass) {
        ctx.fillStyle = params.palette[1];
        if (isGlowPass) return; 

        ctx.fillRect(cx - r * 0.9, cy - r * 0.9, r * 1.8, r * 1.8);
        
        const lineCount = 12 + Math.floor(parseFloat(params.complexity) * 10);
        ctx.strokeStyle = params.palette[2];
        ctx.lineWidth = 1;
        ctx.save(); ctx.translate(cx, cy); ctx.rotate(phase * 0.005);
        for (let i = 0; i < lineCount; i++) {
          const a = (i / lineCount) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(a) * r * 2, Math.sin(a) * r * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      drawSriYantra(ctx, cx, cy, r, params, phase, isGlowPass) {
        const depth = 5 + Math.floor(parseFloat(params.complexity) * 4);
        let currentSize = r * 0.9;
        ctx.save();
        ctx.translate(cx, cy);
        let currentRotation = params.solidRotation + phase * 0.005;

        for(let i=0; i<depth; i++) {
          const color = i % 2 === 0 ? params.palette[1] : params.palette[2];
          ctx.strokeStyle = color;
          ctx.lineWidth = isGlowPass ? 5 : (2 + (depth - i) * 0.5);

          this.drawTriangle(ctx, currentRotation, currentSize);
          
          currentRotation += Math.PI / 3;
          ctx.strokeStyle = i % 2 === 0 ? params.palette[4] : params.palette[3];
          this.drawTriangle(ctx, currentRotation, currentSize);

          currentRotation -= Math.PI / 3;
          currentSize *= 0.7;
          currentRotation += phase * 0.01;
        }
        ctx.restore();
      }
      
      drawTriangle(ctx, angle, size) {
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * size, Math.sin(angle) * size);
        ctx.lineTo(Math.cos(angle + 2 * Math.PI / 3) * size, Math.sin(angle + 2 * Math.PI / 3) * size);
        ctx.lineTo(Math.cos(angle + 4 * Math.PI / 3) * size, Math.sin(angle + 4 * Math.PI / 3) * size);
        ctx.closePath();
        ctx.stroke();
      }

      drawIcosahedronGrid(ctx, cx, cy, r, params, phase, isGlowPass) {
        if (isGlowPass) return;
        
        const radius = r * 0.9;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(params.solidRotation + phase * 0.005);
        
        const goldenRatio = (1 + Math.sqrt(5)) / 2;
        const vertexPositions = [];
        const offsetAngle = phase * 0.05;

        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          vertexPositions.push({ x: radius * Math.cos(angle + offsetAngle) / goldenRatio, y: radius * Math.sin(angle + offsetAngle) / goldenRatio });
          vertexPositions.push({ x: radius * Math.cos(angle - offsetAngle + Math.PI/6) / goldenRatio, y: radius * Math.sin(angle - offsetAngle + Math.PI/6) / goldenRatio });
        }
        
        ctx.strokeStyle = params.palette[2];
        ctx.lineWidth = 1;
        for (let i = 0; i < 12; i++) {
          for (let j = i + 1; j < 12; j++) {
            const p1 = vertexPositions[i];
            const p2 = vertexPositions[j];
            const distSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
            if (distSq < (radius * 0.7) ** 2) {
              ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }
          }
        }
        
        ctx.fillStyle = params.palette[4];
        vertexPositions.forEach(p => {
          ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
        });

        ctx.restore();
      }
      
      drawFibonacciSpiral(ctx, cx, cy, r, params, phase, isGlowPass) {
          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(params.solidRotation + phase * 0.05);

          const segments = 20 + Math.floor(parseFloat(params.complexity) * 20);
          const goldenRatio = (1 + Math.sqrt(5)) / 2;
          const color = params.palette[1];
          const accent = params.palette[2];
          
          ctx.strokeStyle = color;
          ctx.lineWidth = isGlowPass ? 4 : 2;
          
          let a = 0.5; // Controls tightness
          let angle = 0;
          
          ctx.beginPath();
          for(let i=0; i<segments; i++) {
              let currentR = a * Math.exp(0.12 * angle); // Logarithmic spiral, tightness controlled by 0.12
              if (currentR > r) break;
              
              const x = Math.cos(angle) * currentR;
              const y = Math.sin(angle) * currentR;
              
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
              
              angle += Math.PI * 2 / goldenRatio; // Golden Angle step
              
              if (!isGlowPass && i % 4 === 0) {
                  // Draw small markers
                  ctx.fillStyle = accent;
                  ctx.beginPath();
                  ctx.arc(x, y, 2 + params.complexity * 2, 0, Math.PI * 2);
                  ctx.fill();
              }
          }
          ctx.stroke();

          ctx.restore();
      }

      generateIcosahedronVertices() {
        const phi = (1 + Math.sqrt(5)) / 2;
        const s = 1.0;
        return [
          [0, s, phi*s], [0, -s, phi*s], [0, s, -phi*s], [0, -s, -phi*s],
          [s, phi*s, 0], [-s, phi*s, 0], [s, -phi*s, 0], [-s, -phi*s, 0],
          [phi*s, 0, s], [-phi*s, 0, s], [phi*s, 0, -s], [-phi*s, 0, -s]
        ];
      }

      generateIcosahedronEdges() {
        const edges = [];
        const n = this.icosaVertices.length;
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const p1 = this.icosaVertices[i];
                const p2 = this.icosaVertices[j];
                const distSq = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
                if (distSq < 4.1) { 
                    edges.push([i, j]);
                }
            }
        }
        return edges;
      }

      drawPolyhedron(ctx, cx, cy, r, poly, phase, isGlowPass) {
        if (isGlowPass) return; 

        ctx.save();
        ctx.translate(cx, cy);
        
        const angle = phase * poly.rotationSpeed * 5; 
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const rotateX = ([x, y, z]) => [x, y * cos - z * sin, y * sin + z * cos];
        const rotateY = ([x, y, z]) => [x * cos - z * sin, y, x * sin + z * cos];

        let vertices = this.icosaVertices; 
        let edges = this.icosaEdges;
        let scaleFactor = r * 0.2;

        if (poly.type === 0) {} 
        else if (poly.type === 1) {
            this.drawStar(ctx, r, 5, 0.4); 
            ctx.strokeStyle = poly.color;
            ctx.lineWidth = poly.thickness;
            ctx.stroke();
            ctx.restore();
            return;
        } else if (poly.type === 2) { 
            vertices = [
                [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
                [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1]
            ];
            edges = [
                [0,1],[1,2],[2,3],[3,0], 
                [4,5],[5,6],[6,7],[7,4], 
                [0,4],[1,5],[2,6],[3,7]  
            ];
            scaleFactor = r * 0.4;
        } else if (poly.type === 3) { 
            const h = 1 / Math.sqrt(3);
            vertices = [
                [0, 0, 1.5],
                [1, 0, -h],
                [-0.5, Math.sqrt(3)/2, -h],
                [-0.5, -Math.sqrt(3)/2, -h]
            ];
            edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
            scaleFactor = r * 0.4;
        }

        const projected = vertices.map(v => {
            let v_rotated = rotateY(rotateX(v));
            const z = v_rotated[2] * scaleFactor; 
            const x = v_rotated[0] * scaleFactor;
            const y = v_rotated[1] * scaleFactor;
            return { x, y, z };
        });

        ctx.strokeStyle = poly.color;
        ctx.lineWidth = poly.thickness;

        edges.forEach(([i, j]) => {
            const v1 = projected[i];
            const v2 = projected[j];
            if (v1 && v2) {
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
            }
        });

        ctx.restore();
      }

      drawStar(ctx, r, points, innerRatio) {
          ctx.beginPath();
          for (let i = 0; i < points * 2; i++) {
              const radius = i % 2 === 0 ? r : r * innerRatio;
              const angle = (i / (points * 2)) * Math.PI * 2;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
          }
          ctx.closePath();
      }
    }


    // ====================================================================
    // 4. AUDIO ENGINE CLASS - Enhanced with Modulation Controls
    // ====================================================================

    class AudioEngine {
      constructor() {
        this.audioCtx = null;
        this.masterGain = null;
        this.leftOsc = null;
        this.rightOsc = null;
        this.leftPan = null;
        this.rightPan = null;
        this.isAudioPlaying = false;

        // Modulation nodes
        this.panLFO = null;
        this.panLFOGain = null;
        this.filter = null;

        // Harmonic oscillators (overtones)
        this.harmonicOscs = [];
        this.harmonicGain = null;

        // Interval oscillator
        this.intervalOsc = null;
        this.intervalGain = null;

        // Reverb
        this.reverbNode = null;
        this.reverbGain = null;
        this.dryGain = null;

        this.computedCarrier = 0;
        this.computedBeat = 0;
        this.currentElementData = null;
        this.currentWaveform = 'sine';
        this.currentDetune = 0;
        this.manualWaveform = 'auto';
        this.currentInterval = 0;
      }

      initAudioIfNeeded(volume) {
        if (this.audioCtx) return;
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Create filter node (lowpass)
        this.filter = this.audioCtx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 4000;
        this.filter.Q.value = 0.7;

        // Dry/Wet mixing for reverb
        this.dryGain = this.audioCtx.createGain();
        this.dryGain.gain.value = 1.0;

        this.reverbGain = this.audioCtx.createGain();
        this.reverbGain.gain.value = 0.0;

        // Create simple reverb using multiple delays
        this.reverbNode = this.createSimpleReverb();

        // Master gain
        this.masterGain = this.audioCtx.createGain();
        this.masterGain.gain.value = volume || 0.06;

        // Main oscillators
        this.leftOsc = this.audioCtx.createOscillator();
        this.leftOsc.type = this.currentWaveform;
        this.leftPan = this.audioCtx.createStereoPanner();
        this.leftPan.pan.value = -1;

        this.rightOsc = this.audioCtx.createOscillator();
        this.rightOsc.type = this.currentWaveform;
        this.rightPan = this.audioCtx.createStereoPanner();
        this.rightPan.pan.value = 1;

        // Harmonic overtones gain
        this.harmonicGain = this.audioCtx.createGain();
        this.harmonicGain.gain.value = 0;

        // Create harmonic oscillators (2nd, 3rd, 5th partials)
        [2, 3, 5].forEach((mult, i) => {
          const osc = this.audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = 100 * mult;
          const gain = this.audioCtx.createGain();
          gain.gain.value = 1 / (mult * 1.5);
          osc.connect(gain);
          gain.connect(this.harmonicGain);
          osc.start();
          this.harmonicOscs.push({ osc, gain, multiplier: mult });
        });

        // Interval oscillator (musical intervals above base)
        this.intervalOsc = this.audioCtx.createOscillator();
        this.intervalOsc.type = this.currentWaveform;
        this.intervalOsc.frequency.value = 100;
        this.intervalGain = this.audioCtx.createGain();
        this.intervalGain.gain.value = 0;
        this.intervalOsc.connect(this.intervalGain);
        this.intervalGain.connect(this.filter);
        this.intervalOsc.start();

        // Signal chain: Oscillators -> Panners -> Filter -> Dry/Reverb -> Master -> Destination
        this.leftOsc.connect(this.leftPan);
        this.leftPan.connect(this.filter);
        this.rightOsc.connect(this.rightPan);
        this.rightPan.connect(this.filter);
        this.harmonicGain.connect(this.filter);

        // Split to dry and wet paths
        this.filter.connect(this.dryGain);
        this.filter.connect(this.reverbNode.input);
        this.reverbNode.connect(this.reverbGain);

        this.dryGain.connect(this.masterGain);
        this.reverbGain.connect(this.masterGain);
        this.masterGain.connect(this.audioCtx.destination);

        this.leftOsc.start();
        this.rightOsc.start();
        this.isAudioPlaying = false;

        // Panning LFO (spatial drift)
        this.panLFO = this.audioCtx.createOscillator();
        this.panLFO.type = 'sine';
        this.panLFO.frequency.setValueAtTime(0.05, this.audioCtx.currentTime);

        this.panLFOGain = this.audioCtx.createGain();
        this.panLFOGain.gain.setValueAtTime(0.3, this.audioCtx.currentTime);

        this.panLFO.connect(this.panLFOGain);
        this.panLFOGain.connect(this.leftPan.pan);
        this.panLFOGain.connect(this.rightPan.pan);

        this.panLFO.start(0);
      }

      createSimpleReverb() {
        // Create a simple reverb using multiple feedback delays
        const input = this.audioCtx.createGain();
        const output = this.audioCtx.createGain();

        const delayTimes = [0.037, 0.041, 0.043, 0.047, 0.053, 0.061];

        delayTimes.forEach(time => {
          const delay = this.audioCtx.createDelay();
          delay.delayTime.value = time;
          const feedback = this.audioCtx.createGain();
          feedback.gain.value = 0.4;

          input.connect(delay);
          delay.connect(feedback);
          feedback.connect(delay);
          delay.connect(output);
        });

        return { input, output, connect: (dest) => output.connect(dest) };
      }

      setVolume(volume) {
        if (!this.audioCtx) return;
        this.masterGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
      }

      setFilter(frequency) {
        if (!this.filter) return;
        this.filter.frequency.setTargetAtTime(frequency, this.audioCtx.currentTime, 0.05);
      }

      setDetune(cents) {
        if (!this.leftOsc || !this.rightOsc) return;
        this.currentDetune = cents;
        this.leftOsc.detune.setTargetAtTime(cents, this.audioCtx.currentTime, 0.02);
        this.rightOsc.detune.setTargetAtTime(-cents, this.audioCtx.currentTime, 0.02); // Opposite for width
      }

      setLFORate(rate) {
        if (!this.panLFO) return;
        this.panLFO.frequency.setTargetAtTime(rate, this.audioCtx.currentTime, 0.1);
      }

      setHarmonics(amount) {
        if (!this.harmonicGain) return;
        this.harmonicGain.gain.setTargetAtTime(amount * 0.15, this.audioCtx.currentTime, 0.05);
      }

      setReverb(amount) {
        if (!this.reverbGain || !this.dryGain) return;
        // Crossfade between dry and wet
        const wet = amount;
        const dry = 1 - (amount * 0.5); // Don't completely kill dry signal
        this.reverbGain.gain.setTargetAtTime(wet * 0.6, this.audioCtx.currentTime, 0.05);
        this.dryGain.gain.setTargetAtTime(dry, this.audioCtx.currentTime, 0.05);
      }

      setWaveform(waveType) {
        this.manualWaveform = waveType;
        if (!this.leftOsc || !this.rightOsc) return;

        // If auto, use the element-based waveform
        const actualWaveform = (waveType === 'auto') ? this.currentWaveform : waveType;

        this.leftOsc.type = actualWaveform;
        this.rightOsc.type = actualWaveform;
        if (this.intervalOsc) this.intervalOsc.type = actualWaveform;
      }

      setInterval(semitones) {
        if (!this.intervalGain || !this.intervalOsc) return;
        this.currentInterval = semitones;

        if (semitones === 0) {
          this.intervalGain.gain.setTargetAtTime(0, this.audioCtx.currentTime, 0.02);
        } else {
          // Calculate frequency ratio for equal temperament intervals
          const ratio = Math.pow(2, semitones / 12);
          const intervalFreq = this.computedCarrier * ratio;
          this.intervalOsc.frequency.setTargetAtTime(intervalFreq, this.audioCtx.currentTime, 0.03);
          this.intervalGain.gain.setTargetAtTime(0.15, this.audioCtx.currentTime, 0.02);
        }
      }

      updateHarmonicFrequencies(baseFreq) {
        this.harmonicOscs.forEach(({ osc, multiplier }) => {
          osc.frequency.setTargetAtTime(baseFreq * multiplier, this.audioCtx.currentTime, 0.03);
        });
      }

      togglePlay(volume, beat) {
        this.initAudioIfNeeded(volume);
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
        this.isAudioPlaying = !this.isAudioPlaying;

        if (this.isAudioPlaying) {
          this.masterGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
          this.updateFrequencies(beat);
        } else {
          this.masterGain.gain.setTargetAtTime(0.0001, this.audioCtx.currentTime, 0.02);
        }
        return this.isAudioPlaying;
      }

      computeAudioFromSeed(seed, dateStr, elementData) {
        const elements = [elementData.year, elementData.month, elementData.day];
        const primaryElement = elements.reduce((prev, current) => {
          const prevFreq = SOUND_ELEMENT_MAPPING[prev.key].freq;
          const currentFreq = SOUND_ELEMENT_MAPPING[current.key].freq;
          return (currentFreq > prevFreq) ? current : prev;
        });

        let carrierFreq = SOUND_ELEMENT_MAPPING[primaryElement.key].freq;
        const elementalBaseFreq = carrierFreq;

        // Halve the carrier frequency to drop it an octave
        carrierFreq = carrierFreq / 2;

        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const dayOfMonth = date.getDate();
        const beat = 2.0 + (dayOfMonth / 31) * 8.0;

        const waveformType = WAVEFORM_MAP[primaryElement.key] || 'sine';

        return {
          carrier: carrierFreq,
          beat: beat,
          element: primaryElement,
          elementalBaseFreq: elementalBaseFreq,
          waveform: waveformType,
        };
      }

      updateFrequencies(beatOverride) {
        if (!this.currentElementData) return;

        const audioData = this.computeAudioFromSeed(
          this.currentElementData.seed,
          this.currentElementData.dateStr,
          this.currentElementData.elementData
        );

        this.computedCarrier = audioData.carrier;
        this.computedBeat = parseFloat(beatOverride) || audioData.beat;
        this.currentWaveform = audioData.waveform;

        const leftFreq = this.computedCarrier - (this.computedBeat / 2);
        const rightFreq = this.computedCarrier + (this.computedBeat / 2);

        if (this.leftOsc && this.rightOsc) {
          this.leftOsc.frequency.setTargetAtTime(Math.max(80, leftFreq), this.audioCtx.currentTime, 0.03);
          this.rightOsc.frequency.setTargetAtTime(Math.max(80, rightFreq), this.audioCtx.currentTime, 0.03);

          // Use manual waveform if set, otherwise use element-based waveform
          const actualWaveform = (this.manualWaveform === 'auto') ? this.currentWaveform : this.manualWaveform;
          this.leftOsc.type = actualWaveform;
          this.rightOsc.type = actualWaveform;
          if (this.intervalOsc) this.intervalOsc.type = actualWaveform;

          // Update harmonic oscillators based on carrier frequency
          this.updateHarmonicFrequencies(this.computedCarrier);

          // Update interval if active
          if (this.currentInterval > 0) {
            this.setInterval(this.currentInterval);
          }
        }
      }

      resumeContext() {
        if (this.audioCtx && this.isAudioPlaying && this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }
      }
    }


    // ====================================================================
    // 5. MAIN APPLICATION LOGIC 
    // ====================================================================
    document.addEventListener('DOMContentLoaded', () => {
      const seedInput = document.getElementById('seed-input');
      const dateInput = document.getElementById('date-input');
      const scriptSelector = document.getElementById('script-selector');
      const audioToggle = document.getElementById('audio-toggle');
      const beatRange = document.getElementById('beat-range');
      const volRange = document.getElementById('vol-range');
      const fsOverlay = document.getElementById('fullscreen-overlay');
      const fsStat = document.getElementById('fs-stat');
      const speedDisplay = document.getElementById('speed-display');
      const bloomDisplay = document.getElementById('bloom-display');
      const volumeDisplay = document.getElementById('volume-display');
      const runeDisplay = document.getElementById('rune-display');

      const renderer = new MandalaRenderer('mandala-canvas', 'fullscreen-canvas');
      const audioEngine = new AudioEngine();

      let currentMandalaParams = null;
      let currentScriptType = 'runic';

      dateInput.valueAsDate = new Date();

      // Initial call to set up the UI and initial render
      updateUI();

      // --- Core Update Function ---
      function updateUI() {
        const name = seedInput.value || "Initial Config";
        const date = dateInput.value;

        const paramsGenerator = new MandalaParams(name, date, currentScriptType);
        currentMandalaParams = paramsGenerator;
        renderer.setParams(currentMandalaParams.params);
        audioEngine.currentElementData = currentMandalaParams;

        // 2. Update Meta Displays
        runeDisplay.textContent = currentMandalaParams.runic || '‚ñµ';
        runeDisplay.style.fontFamily = currentMandalaParams.scriptMapping.font;
        document.getElementById('element-display').textContent = `${currentMandalaParams.elementData.year.name.split(' ')[0]} / ${currentMandalaParams.elementData.month.name.split(' ')[0]} / ${currentMandalaParams.elementData.day.name.split(' ')[0]}`;
        document.getElementById('archetype-display').textContent = `${currentMandalaParams.params.archetype.name.split(' ')[0]} / ${currentMandalaParams.params.complexity}`;

        // 3. Sync Audio Frequencies
        const audioData = syncAudioFrequencies(false);

        // 4. Update Explanation Panels
        updateExplanationPanels(currentMandalaParams.params, currentMandalaParams.elementData, audioData);
        
        // 5. Redraw static frame if not animating
        if (!renderer.isAnimating) {
            renderer.drawInitialFrame();
        }
      }

      function syncAudioFrequencies(isManualBeatChange) {
        if (!currentMandalaParams) return;
        
        const audioData = audioEngine.computeAudioFromSeed(
          currentMandalaParams.seed, 
          currentMandalaParams.dateStr, 
          currentMandalaParams.elementData
        );

        if (!isManualBeatChange && beatRange.dataset.touched === "0") {
          beatRange.value = audioData.beat.toFixed(1);
        }
        
        audioEngine.updateFrequencies(beatRange.value);
        
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
        
        return audioData; // Return the audioData for display
      }

      function updateExplanationPanels(params, elementData, audioData) {
        const leftPanel = document.getElementById('left-panel-content');
        const rightPanel = document.getElementById('right-panel-content');

        const primaryAudioElement = SOUND_ELEMENT_MAPPING[audioData.element.key];

        // LEFT PANEL: DATA AND COLOR SPECIFICATION
        let leftHTML = `
          <h3>INPUT SIGNATURE SPECIFICATION</h3>
          <p>The temporal and semantic inputs define three dominant elemental data types that drive the generative rendering process.</p>
          <h4>Input Source Mapping:</h4>
          <ul>
            <li><strong>Year Base:</strong> ${elementData.year.name}. ${elementData.year.meaning.split('. ')[0]}.</li>
            <li><strong>Month Vector:</strong> ${elementData.month.name}. ${elementData.month.meaning.split('. ')[0]}.</li>
            <li><strong>Day Modifier:</strong> ${elementData.day.name}. ${elementData.day.meaning.split('. ')[0]}.</li>
          </ul>
          <h4>Palette Specification: ${params.palette[0].replace('#', 'M-')}</h4>
          <p>Five blended color points are derived from your inputs, optimized for contrast and light spill:</p>
          <ul>
            <li><span class="color-block" style="background-color: ${params.palette[0]}"></span>Tone 1: Primary Structure (${params.palette[0]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[1]}"></span>Tone 2: Secondary Flow (${params.palette[1]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[2]}"></span>Tone 3: Accent / Glow (${params.palette[2]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[3]}"></span>Tone 4: Central Fill (${params.palette[3]})</li>
            <li><span class="color-block" style="background-color: ${params.palette[4]}"></span>Tone 5: Frame Detail (${params.palette[4]})</li>
          </ul>
        `;
        leftPanel.innerHTML = leftHTML;

        // RIGHT PANEL: GEOMETRY AND ACOUSTIC CONFIGURATION
        const symbolSet = SCRIPT_SYMBOLS[params.scriptType] || SCRIPT_SYMBOLS.runic;
        const primarySymbol = symbolSet[params.symbolIndex % symbolSet.length];
        const scriptName = {
          runic: 'Elder Futhark',
          tibetan: 'Tibetan Script',
          devanagari: 'Sanskrit Devanagari',
          theban: 'Theban Alphabet',
          coptic: 'Coptic Script',
          hebrew: 'Hebrew Alphabet'
        }[params.scriptType] || 'Elder Futhark';

        let rightHTML = `
          <h3>GEOMETRY & ACOUSTIC CONFIGURATION</h3>
          <p>The input string determines the structural matrix and central glyph from the ${scriptName}.</p>
          <h4>Geometry Matrix: ${params.archetype.name}</h4>
          <p>${params.archetype.meaning}</p>

          <h4>Central Symbol: ${primarySymbol.char}</h4>
          <p><strong>${primarySymbol.desc}</strong> ‚Äî ${primarySymbol.meaning}</p>

          <h4>Acoustic Configuration</h4>
          <p>Binaural carrier derived from elemental correspondence:</p>
          <ul>
            <li><strong>Waveform:</strong> ${audioEngine.manualWaveform === 'auto' ? audioData.waveform.toUpperCase() + ' (Auto)' : audioEngine.manualWaveform.toUpperCase()}</li>
            <li><strong>Carrier:</strong> ${audioData.carrier.toFixed(2)} Hz</li>
            <li><strong>Beat:</strong> ${audioEngine.computedBeat.toFixed(2)} Hz</li>
          </ul>
          <h4>Modulation Controls</h4>
          <ul>
            <li><strong>Wave:</strong> Oscillator waveform selection</li>
            <li><strong>Filter:</strong> Lowpass cutoff frequency</li>
            <li><strong>Detune:</strong> Stereo width via pitch offset</li>
            <li><strong>Drift:</strong> Spatial panning LFO rate</li>
            <li><strong>Harmonics:</strong> Overtone blend (2nd, 3rd, 5th)</li>
            <li><strong>Interval:</strong> Musical interval above base (semitones)</li>
            <li><strong>Reverb:</strong> Spatial depth and echo</li>
          </ul>
        `;
        rightPanel.innerHTML = rightHTML;
      }
      
      // --- UI Event Listeners ---
      seedInput.addEventListener('input', updateUI);
      dateInput.addEventListener('change', updateUI);

      scriptSelector.addEventListener('change', () => {
        currentScriptType = scriptSelector.value;
        updateUI();
      });

      document.getElementById('random-btn').addEventListener('click', () => {
        seedInput.value = '';
        dateInput.valueAsDate = new Date(new Date().getTime() - Math.floor(Math.random()*365*24*60*60*1000));
        updateUI();
      });

      document.getElementById('animate-btn').addEventListener('click', () => {
        const newState = !renderer.isAnimating;
        renderer.toggleAnimation(newState);
        document.getElementById('animate-btn').textContent = newState ? "Stop Flow" : "Start Flow";
      });

      document.getElementById('bloom-btn').addEventListener('click', () => {
        renderer.isBloom = !renderer.isBloom;
        document.getElementById('bloom-btn').textContent = renderer.isBloom ? "Disable Light Spill" : "Toggle Light Spill";
        updateBloomDisplay();
        if(!renderer.isAnimating) renderer.drawInitialFrame();
      });

      document.getElementById('save-btn').addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `SIG01-${seedInput.value.replace(/ /g, '-')||'config'}.png`;
        link.href = renderer.canvas.toDataURL();
        link.click();
      });

      // Audio Controls
      audioToggle.addEventListener('click', () => {
        const isPlaying = audioEngine.togglePlay(parseFloat(volRange.value), beatRange.value);
        audioToggle.textContent = isPlaying ? 'Tone ON' : 'Tone OFF';
      });

      volRange.addEventListener('input', () => {
        audioEngine.setVolume(parseFloat(volRange.value));
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      });

      beatRange.addEventListener('input', () => {
        beatRange.dataset.touched = "1";
        syncAudioFrequencies(true);
      });

      // New modulation controls
      const filterRange = document.getElementById('filter-range');
      const detuneRange = document.getElementById('detune-range');
      const lfoRange = document.getElementById('lfo-range');
      const harmonicsRange = document.getElementById('harmonics-range');

      filterRange.addEventListener('input', () => {
        audioEngine.setFilter(parseFloat(filterRange.value));
      });

      detuneRange.addEventListener('input', () => {
        audioEngine.setDetune(parseFloat(detuneRange.value));
      });

      lfoRange.addEventListener('input', () => {
        audioEngine.setLFORate(parseFloat(lfoRange.value));
      });

      harmonicsRange.addEventListener('input', () => {
        audioEngine.setHarmonics(parseFloat(harmonicsRange.value));
      });

      const intervalRange = document.getElementById('interval-range');
      const reverbRange = document.getElementById('reverb-range');
      const waveformSelect = document.getElementById('waveform-select');

      intervalRange.addEventListener('input', () => {
        audioEngine.setInterval(parseFloat(intervalRange.value));
      });

      reverbRange.addEventListener('input', () => {
        audioEngine.setReverb(parseFloat(reverbRange.value));
      });

      waveformSelect.addEventListener('change', () => {
        audioEngine.setWaveform(waveformSelect.value);
      });

      // Fullscreen Logic
      document.getElementById('fullscreen-btn').addEventListener('click', enterFullscreen);
      document.getElementById('fs-exit').addEventListener('click', exitFullscreen);

      function enterFullscreen() {
        fsOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
        if (!renderer.isAnimating) renderer.toggleAnimation(true);
      }

      function exitFullscreen() {
        fsOverlay.classList.remove('active');
        document.body.style.overflow = '';
      }

      // Stat display (for user feedback)
      function showStat(message) {
        fsStat.textContent = message;
        fsStat.classList.add('visible');
        clearTimeout(fsStat.timer);
        fsStat.timer = setTimeout(() => fsStat.classList.remove('visible'), 1000);
      }
      
      function updateBloomDisplay() {
          bloomDisplay.textContent = renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "OFF";
      }

      // --- Global Keyboard Controls ---
      document.addEventListener('keydown', (e) => {
        const inFullscreen = fsOverlay.classList.contains('active');

        // F11 toggles fullscreen from anywhere
        if (e.code === 'F11') {
          e.preventDefault();
          if (inFullscreen) exitFullscreen();
          else enterFullscreen();
          return;
        }

        if (inFullscreen) {
          e.preventDefault();
        }

        switch(e.code) {
          case 'Escape':
            if (inFullscreen) exitFullscreen();
            break;
          case 'ArrowLeft': 
            renderer.speed = Math.max(0.1, renderer.speed - 0.25);
            showStat(`Motion Index: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowRight': 
            renderer.speed = Math.min(10, renderer.speed + 0.25);
            showStat(`Motion Index: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowUp': 
            if (!renderer.isBloom) {
                renderer.isBloom = true;
                document.getElementById('bloom-btn').textContent = "Disable Light Spill";
            }
            renderer.bloomIntensity = Math.min(2.0, renderer.bloomIntensity + 0.1);
            showStat(`Light Intensity: ${renderer.bloomIntensity.toFixed(2)}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawInitialFrame();
            break;
          case 'ArrowDown': 
            renderer.bloomIntensity = Math.max(0.1, renderer.bloomIntensity - 0.1);
            if (renderer.bloomIntensity < 0.15) {
                renderer.isBloom = false;
                document.getElementById('bloom-btn').textContent = "Toggle Light Spill";
            }
            showStat(`Light Intensity: ${renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "Light OFF"}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawInitialFrame();
            break;
          case 'NumpadAdd':
          case 'Equal': 
            volRange.value = (parseFloat(volRange.value) + 0.01).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Tone Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
          case 'NumpadSubtract':
          case 'Minus': 
            volRange.value = (parseFloat(volRange.value) - 0.01).toFixed(3);
            volRange.value = Math.max(0.005, parseFloat(volRange.value)).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Tone Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
        }
      });
      
      document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
              audioEngine.resumeContext();
          }
      });

      // Initial state setup
      updateBloomDisplay();
      speedDisplay.textContent = renderer.speed.toFixed(2);
      volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      document.getElementById('bloom-btn').textContent = renderer.isBloom ? "Disable Light Spill" : "Toggle Light Spill";
    });
  </script>
</body>
</html>
