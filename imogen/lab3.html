<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mandala Generator ¬∑ Lab 3 ¬∑ Imogen</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Serif+Tibetan&display=swap" rel="stylesheet">
  <style>
    /* ---------------------------------------------------- */
    /* 1. SWEDISH WELLNESS AESTHETIC */
    /* ---------------------------------------------------- */
    :root {
      --color-primary-accent: #3A66A8; /* Muted Navy/Blue for highlight */
      --color-primary-canvas: #A8B8CC; /* Canvas highlight color (the glow) */
      --color-neutral-dark: #333333;   /* Text color */
      --color-neutral-medium: #6B7280; /* Secondary text */
      --color-bg-light: #F9F9F9;      /* Lightest background */
      --color-bg-white: #FFFFFF;      /* Pure white for elements */
      --color-border: #E0E0E0;        /* Light border color */
      --shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.05);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--color-bg-light);
      color: var(--color-neutral-dark);
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }
    .navbar {
      display: flex; justify-content: center; align-items: center;
      background: var(--color-bg-white); padding: 1.2rem 2rem;
      position: sticky; top: 0; width: 100%; z-index: 1000;
      border-bottom: 1px solid var(--color-border); box-shadow: var(--shadow-soft);
    }
    .navbar a { color: var(--color-neutral-medium); font-size: 0.9rem; font-weight: 500; text-decoration: none; margin: 0 2rem; transition: color 0.3s ease; }
    .navbar a:hover { color: var(--color-primary-accent); }

    .container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 6rem 2rem 3rem; gap: 2rem; width: 95%; max-width: 1400px; margin: 0 auto; }
    .main-content-grid { display: flex; gap: 3rem; width: 100%; align-items: flex-start; }
    .center-column { display: flex; flex-direction: column; align-items: center; gap: 2rem; flex: 0 0 600px; }

    /* Info Panels - Clean, Card Look */
    .explanation-panel { flex: 1; max-width: 400px; padding: 2rem; background: var(--color-bg-white); border-radius: 12px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); position: sticky; top: 8rem; min-height: 400px; }
    .explanation-panel h3 { color: var(--color-primary-accent); font-size: 1.2rem; font-weight: 600; border-bottom: 2px solid var(--color-border); padding-bottom: 0.75rem; margin-bottom: 1rem; }
    .explanation-panel h4 { color: var(--color-neutral-dark); font-size: 1rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.6rem; }
    .explanation-panel p, .explanation-panel ul, .explanation-panel li { font-size: 0.85rem; color: var(--color-neutral-medium); margin-bottom: 0.8rem; line-height: 1.5; list-style-position: inside; padding-left: 0; }
    .explanation-panel strong { color: var(--color-neutral-dark); font-weight: 700; }
    .color-block { display: inline-block; width: 14px; height: 14px; border-radius: 50%; margin-right: 8px; border: 1px solid var(--color-border); vertical-align: middle;}

    .header-group { text-align: center; max-width: 800px; padding: 0 1rem; margin-bottom: 1rem; }
    .title { font-size: 2.8rem; font-weight: 300; color: var(--color-neutral-dark); letter-spacing: 2px; text-transform: uppercase; margin-bottom: 0.5rem; }
    .subtitle { font-size: 1rem; color: var(--color-neutral-medium); font-weight: 400; }

    /* Input Card */
    .input-group { display: flex; flex-direction: column; gap: 1.5rem; width: 100%; background: var(--color-bg-white); padding: 2rem; border-radius: 12px; border: 1px solid var(--color-border); box-shadow: var(--shadow-soft); }
    .input-row { display: flex; gap: 1rem; }
    
    .text-input, .date-input { 
      background: var(--color-bg-light); border: 1px solid var(--color-border); border-radius: 8px; 
      color: var(--color-neutral-dark); padding: 1rem; font-family: inherit; outline: none; transition: border-color 0.3s, box-shadow 0.3s;
    }
    .text-input { flex: 2; font-size: 1.1rem; }
    .date-input { flex: 1; font-size: 1rem; text-align: center; cursor: pointer; }
    .text-input:focus, .date-input:focus { border-color: var(--color-primary-accent); box-shadow: 0 0 0 3px rgba(58, 102, 168, 0.1); background: var(--color-bg-white); }

    /* Meta Info */
    .meta-display { display: flex; justify-content: space-between; align-items: flex-end; border-top: 1px solid var(--color-border); padding-top: 1.5rem; }
    .meta-box { display: flex; flex-direction: column; }
    .meta-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1.5px; color: var(--color-neutral-medium); margin-bottom: 4px; font-weight: 500; }
    .meta-value { color: var(--color-primary-accent); font-size: 1.1rem; font-weight: 700; }
    .tibetan-font { font-family: 'Noto Serif Tibetan', serif; font-size: 1.8rem; line-height: 1; color: var(--color-primary-accent); }

    /* Canvas */
    .canvas-wrapper { position: relative; margin: 1rem 0; background: #080706; border-radius: 50%; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.2), inset 0 0 10px rgba(255, 255, 255, 0.1); }
    #mandala-canvas { border-radius: 50%; display: block; max-width: 90vw; height: auto; cursor: crosshair; }

    /* Controls */
    .controls { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; max-width: 650px; }
    .btn { background: var(--color-bg-white); border: 1px solid var(--color-border); color: var(--color-neutral-medium); padding: 0.8rem 1.4rem; border-radius: 8px; cursor: pointer; transition: all 0.3s; font-size: 0.9rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }
    .btn:hover { border-color: var(--color-primary-accent); color: var(--color-primary-accent); background: var(--color-bg-light); }

    .audio-controls { display: flex; gap: 1rem; align-items: center; padding: 0.8rem 1.2rem; border-radius: 8px; background: var(--color-bg-light); border: 1px solid var(--color-border); }
    .audio-controls label { font-size: 0.85rem; color: var(--color-neutral-medium); }
    .audio-controls input[type="range"] { width: 100px; appearance: none; height: 4px; background: var(--color-border); border-radius: 2px; }
    .audio-controls input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--color-primary-accent); cursor: pointer; }

    /* Fullscreen */
    .fullscreen-overlay { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 9999; justify-content: center; align-items: center; }
    .fullscreen-overlay.active { display: flex; cursor: none; }
    
    .fs-hover-zone { position: absolute; bottom: 0; left: 0; width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; z-index: 10000; transition: opacity 0.3s; pointer-events: none; }
    .fs-controls { background: rgba(255,255,255,0.95); padding: 15px 25px; border-radius: 25px; border: 1px solid #ccc; display: flex; gap: 15px; opacity: 0; transition: opacity 0.3s; pointer-events: auto; }
    .fs-controls .btn { background: var(--color-primary-accent); color: var(--color-bg-white); border-color: var(--color-primary-accent); }
    .fs-controls .btn:hover { background: #30588a; }
    .fullscreen-overlay.active:hover .fs-hover-zone { opacity: 1; pointer-events: auto; }
    .fs-hover-zone:hover .fs-controls { opacity: 1; }

    .fs-stat { background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 8px; position: fixed; top: 20px; right: 20px; color: var(--color-primary-canvas); font-size: 0.9rem; transition: opacity 0.3s; opacity: 0; pointer-events: none; }
    .fs-stat.visible { opacity: 1; }

    @media (max-width: 1200px) {
      .main-content-grid { flex-direction: column; align-items: center; }
      .explanation-panel { max-width: 600px; width: 100%; position: static; }
      .center-column { flex: 1; }
    }
    @media (max-width: 650px) {
      .input-row { flex-direction: column; }
      .controls { gap: 0.8rem; }
      .audio-controls { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>

<body>

  <div class="navbar">
    <a href="#creation">Creation</a>
    <a href="#harmony">Harmony Principles</a>
    <a href="#sound">Acoustic Alignment</a>
  </div>

  <div class="container">
    <div class="header-group">
      <h1 class="title">AURA: Generative Resonance</h1>
      <p class="subtitle">
        **Your personal energetic blueprint, translated into light, geometry, and sound.**<br>
        A moment of tranquility, derived from your core energetic data.
      </p>
    </div>

    <div class="main-content-grid">
      <div class="explanation-panel left-panel">
        <div id="left-panel-content">
          </div>
      </div>

      <div class="center-column">
        <div class="input-group">
          <div class="input-row">
            <input type="text" class="text-input" id="seed-input" placeholder="Your Name or Intentional Word..." autocomplete="off">
            <input type="date" class="date-input" id="date-input">
          </div>
          
          <div class="meta-display">
            <div class="meta-box">
              <span class="meta-label">Personal Resonance Key</span>
              <span class="meta-value tibetan-font" id="tibetan-display"></span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Energetic Harmony</span>
              <span class="meta-value" id="element-display">Void / Void</span>
            </div>
            <div class="meta-box" style="align-items: flex-end;">
              <span class="meta-label">Design Intention Score</span>
              <span class="meta-value" id="archetype-display">Vajra Palace / 5.0</span>
            </div>
          </div>
        </div>

        <div class="canvas-wrapper">
          <canvas id="mandala-canvas" width="600" height="600"></canvas>
        </div>

        <div class="controls">
          <button class="btn" id="random-btn">Generate Discovery</button>
          <button class="btn" id="animate-btn">Activate Motion</button>
          <button class="btn" id="bloom-btn">Enhance Light</button>
          <button class="btn" id="save-btn">Download Art</button>

          <div class="audio-controls" id="audio-controls">
            <button class="btn" id="audio-toggle">Sound Align ‚ñ∂</button>
            <label for="beat-range">Rhythm</label>
            <input id="beat-range" type="range" min="1" max="12" step="0.1" value="6" data-touched="0">
            <label for="vol-range">Focus</label>
            <input id="vol-range" type="range" min="0" max="0.3" step="0.005" value="0.06">
          </div>
          
          <button class="btn" id="fullscreen-btn">Focus Mode (F11)</button>
        </div>
      </div>

      <div class="explanation-panel right-panel">
        <div id="right-panel-content">
          </div>
      </div>

    </div>
  </div>

  <div class="fullscreen-overlay" id="fullscreen-overlay">
    <canvas id="fullscreen-canvas"></canvas>
    
    <div class="fs-stat" id="fs-stat"></div>

    <div class="fs-hover-zone">
      <div class="fs-controls">
        <button class="btn" id="fs-exit">Exit (ESC)</button>
        <div style="display:flex;flex-direction:column;align-items:flex-start;color:#333;margin-left:8px;font-size:0.8rem;">
          <div>[‚Üë/‚Üì] Light Intensity: <span id="bloom-display">0.50</span></div>
          <div>[‚Üê/‚Üí] Flow State: <span id="speed-display">1.00</span></div>
          <div>[+/-] Focus Volume: <span id="volume-display">0.06</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====================================================================
    // 1. CONSTANTS & UTILITIES (The core logic remains solid)
    // ====================================================================
    const W = 600, H = 600; 

    const LATIN_TO_TIBETAN = {
      'a': '\u0F68', 'b': '\u0F56', 'c': '\u0F45', 'd': '\u0F51', 'e': '\u0F7A', 'f': '\u0F55', 'g': '\u0F42', 'h': '\u0F67',
      'i': '\u0F72', 'j': '\u0F47', 'k': '\u0F40', 'l': '\u0F63', 'm': '\u0F58', 'n': '\u0F53', 'o': '\u0F7C', 'p': '\u0F54',
      'q': '\u0F41', 'r': '\u0F62', 's': '\u0F66', 't': '\u0F4F', 'u': '\u0F74', 'v': '\u0F5D', 'w': '\u0F5D', 'x': '\u0F6A',
      'y': '\u0F61', 'z': '\u0F5F', ' ': ' ',
      'sh': '\u0F64', 'th': '\u0F50', 'ph': '\u0F55', 'ts': '\u0F59'
    };

    // Updated Copy for Wellness Theme
    const ELEMENTS = {
      METAL: { name: 'Purity (Metal)', colors: ['#EBEFF2', '#A3B4C6', '#8FA8BE', '#D6DDE6', '#FFFFFF'], meaning: 'White/Silver. Represents Structure, Clarity, and Unwavering Focus.' },
      WATER: { name: 'Flow (Water)', colors: ['#30404C', '#576775', '#7A8C98', '#9DB0C0', '#D3E1EE'], meaning: 'Deep Blues. Represents Fluidity, Intuition, and Emotional Depth.' },
      WOOD: { name: 'Growth (Wood)', colors: ['#4F6B58', '#738C7D', '#97A99F', '#BCC8BF', '#E1EBE2'], meaning: 'Muted Greens. Represents Vitality, Expansion, and Calm Renewal.' },
      FIRE: { name: 'Intensity (Fire)', colors: ['#A04A4E', '#C66C70', '#E98E92', '#F9C2C4', '#FEE6E7'], meaning: 'Soft Reds/Pinks. Represents Transformation, Passion, and Focused Energy.' },
      EARTH: { name: 'Grounding (Earth)', colors: ['#8A735E', '#A6927C', '#C2B19F', '#DDD0C3', '#F9F5F0'], meaning: 'Warm Neutrals. Represents Stability, Foundation, and Deep Connection.' }
    };
    const MONTH_ELEMENTS = [
      ELEMENTS.EARTH, ELEMENTS.EARTH, ELEMENTS.WOOD, ELEMENTS.WOOD, ELEMENTS.FIRE, ELEMENTS.FIRE,
      ELEMENTS.METAL, ELEMENTS.METAL, ELEMENTS.WATER, ELEMENTS.WATER, ELEMENTS.EARTH, ELEMENTS.EARTH
    ];
    const SOUND_ELEMENT_MAPPING = {
      METAL: { freq: 432, note: "432 Hz Alignment", explanation: "For mental clarity and structural alignment." },
      WATER: { freq: 194.18, note: "194 Hz Earth Resonance", explanation: "For emotional flow and inner connectivity." },
      WOOD: { freq: 285, note: "285 Hz Restoration", explanation: "For cellular renewal and life vitality." },
      FIRE: { freq: 396, note: "396 Hz Liberation", explanation: "For releasing underlying fear and promoting security." },
      EARTH: { freq: 172.8, note: "172 Hz Grounding", explanation: "For deep stability and physical presence." }
    };
    const TIBETAN_SYMBOLS = [
      { char: '\u0F42', desc: 'Inner Compassion (GA)', meaning: 'A focus on empathy and primordial purity.' }, { char: '\u0F40', desc: 'Mindful Action (KA)', meaning: 'The union of body, speech, and intention.' },
      { char: '\u0F68', desc: 'The Open Void (A)', meaning: 'Symbolizing the unconditioned, ultimate state of mind.' }, { char: '\u0F4F', desc: 'Non-Duality (TA)', meaning: 'The understanding of transcendence and interconnectedness.' },
      { char: '‚öî', desc: 'Clarity Blade', meaning: 'Cutting through confusion and achieving immediate clarity.' }, { char: 'üîî', desc: 'Vajra Anchor', meaning: 'Representing diamond-like focus and structural integrity.' },
      { char: '\u0F68\u0F7A', desc: 'Void Syllable (EH)', meaning: 'The elemental seed for ultimate openness and Space.' }, 
      { char: '\u0F5D\u0F66', desc: 'Air Syllable (YAM)', meaning: 'The elemental seed for movement, breath, and purification.' }, 
      { char: '\u0F62\u0F7A\u0F58', desc: 'Fire Syllable (RAM)', meaning: 'The elemental seed for inner transformation and focused energy.' },
      { char: '\u0F63\u0F7A\u0F58', desc: 'Earth Syllable (LAM)', meaning: 'The elemental seed for deep rooting and material stability.' }, 
      { char: '\u0F56\u0F7A\u0F58', desc: 'Water Syllable (BAM)', meaning: 'The elemental seed for emotional fluidity and potential.' } 
    ];
    const ARCHETYPES = [
      { name: 'Sanctuary Grid', index: 0, meaning: 'A traditional four-gate structure, representing a protected space for meditation and self-reflection.' },
      { name: 'Cosmic Union Matrix', index: 1, meaning: 'A pattern of intersecting triangles, symbolizing the union of masculine and feminine energy and creative generation.' },
      { name: 'Universal Flow Net', index: 2, meaning: 'A crystalline structure projection, focusing on fluidity, universal connection, and deep rest.' }
    ];

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }
    
    // Smooth Color Interpolation Function
    function interpolateColor(color1, color2, factor) {
      const rgb1 = hexToRgb(color1);
      const rgb2 = hexToRgb(color2);
      const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * factor);
      const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * factor);
      const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * factor);
      return `rgb(${r},${g},${b})`;
    }

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // ====================================================================
    // 2. MANDALA PARAMETERS CLASS (No functional changes needed)
    // ====================================================================

    class MandalaParams {
      constructor(name, dateStr) {
        this.name = name;
        this.dateStr = dateStr;
        this.tibetan = this.convertToTibetan(name);
        this.seed = this.getNumericSeed(this.tibetan);
        this.rand = mulberry32(this.seed);
        this.elementData = this.getElementsFromDate(dateStr);
        this.params = this.generateParams();
      }

      convertToTibetan(text) {
        if (!text) return "";
        let lower = text.toLowerCase();
        let result = "";
        for (let i = 0; i < lower.length; i++) {
          let char = lower[i];
          if (i < lower.length - 1) {
            const digraph = lower.slice(i, i+2);
            if (LATIN_TO_TIBETAN[digraph]) {
              result += LATIN_TO_TIBETAN[digraph];
              i++; continue;
            }
          }
          result += LATIN_TO_TIBETAN[char] || "";
        }
        return result;
      }

      getNumericSeed(str) {
        let hash = 0;
        if (!str || str.length === 0) return 123456789;
        for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash |= 0; 
        }
        return Math.abs(hash);
      }

      getElementsFromDate(dateStr) {
        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const year = date.getFullYear();
        const month = date.getMonth(); 
        const day = date.getDay();

        const yearDigit = year % 10;
        let yearElement;
        if (yearDigit === 4 || yearDigit === 9) yearElement = ELEMENTS.WOOD;
        else if (yearDigit === 5 || yearDigit === 0) yearElement = ELEMENTS.FIRE;
        else if (yearDigit === 6 || yearDigit === 1) yearElement = ELEMENTS.EARTH;
        else if (yearDigit === 7 || yearDigit === 2) yearElement = ELEMENTS.METAL;
        else yearElement = ELEMENTS.WATER;

        const monthElement = MONTH_ELEMENTS[month];
        let dayElement;
        if (day === 0) dayElement = ELEMENTS.EARTH; 
        else if (day === 1) dayElement = ELEMENTS.WATER; 
        else if (day === 2) dayElement = ELEMENTS.FIRE; 
        else if (day === 3) dayElement = ELEMENTS.WOOD; 
        else if (day === 4) dayElement = ELEMENTS.WATER; 
        else if (day === 5) dayElement = ELEMENTS.METAL; 
        else dayElement = ELEMENTS.FIRE;

        return { year: yearElement, month: monthElement, day: dayElement };
      }

      generateParams() {
        const rand = this.rand;
        const seed = this.seed;
        const randomnessFactor = (rand() - 0.5) * 0.05;

        // 1. Color Palette Synthesis
        const p = [...this.elementData.year.colors];
        const m = [...this.elementData.month.colors];
        const d = [...this.elementData.day.colors];
        let colorPool = [...p, ...m, ...d].sort(() => rand() - 0.5);

        const colorStrings = [ 
          colorPool[0] || p[0], // Primary color (Ring Base)
          colorPool[1] || m[0], // Secondary color (Inner Geometry)
          colorPool[2] || d[0], // Tertiary color (Accent/Detail)
          colorPool[3] || p[1], // Accent 1 (Text/Center Fill)
          colorPool[4] || m[1]  // Accent 2 (Center outline/core)
        ];

        // 2. Geometry Parameters
        const archetypeIndex = seed % ARCHETYPES.length;
        const archetype = ARCHETYPES[archetypeIndex];

        let complexity = ((seed % 900) / 900) + 0.1;
        complexity = parseFloat((complexity + randomnessFactor).toFixed(2));
        complexity = Math.max(0.1, Math.min(1.0, complexity));

        const ringCountBase = 7 + Math.floor(complexity * 12);
        const ringCount = Math.max(5, ringCountBase + Math.floor(randomnessFactor * 10));

        const rings = [];
        for(let i=0; i<ringCount; i++) {
          rings.push({
            r: 0.1 + (i/ringCount)*0.9,
            style: Math.floor(rand() * 5), // 0: solid, 1: dots, 2: double, 3: symbols, 4: dashed
            width: (1 + rand() * 4 * complexity) * (1 + randomnessFactor * 0.5),
            colorIndex: Math.floor(rand()*3) // Primary, Secondary, Tertiary
          });
        }
        
        // 3. Symbol Selection (Bias towards elemental syllable)
        let symbolIndex = seed % TIBETAN_SYMBOLS.length;
        const elementalSyllables = { 'Purity (Metal)': 7, 'Flow (Water)': 11, 'Growth (Wood)': 8, 'Intensity (Fire)': 9, 'Grounding (Earth)': 10 };
        const yearElementKey = this.elementData.year.name;

        if (elementalSyllables[yearElementKey] && rand() < 0.35) {
            symbolIndex = elementalSyllables[yearElementKey];
        }

        // 4. Random Polyhedrons (Complex 3D-like wireframes)
        const polyCount = rand() < 0.40 ? Math.floor(rand() * 4) + 1 : 0; 
        const polyhedrons = [];
        for(let i=0; i<polyCount; i++) {
            polyhedrons.push({
                type: Math.floor(rand() * 4), // 0: Icosahedron, 1: Dodecahedron, 2: Cube, 3: Tetrahedron
                radiusFactor: 0.3 + rand() * 0.6,
                color: colorStrings[Math.floor(rand()*5)],
                thickness: 0.8 + rand() * 3,
                rotationSpeed: (rand() - 0.5) * 0.08,
            });
        }

        return {
          seed, palette: colorStrings, archetype, complexity: complexity.toFixed(2),
          rings, symbolIndex, polyhedrons, solidRotation: rand() * Math.PI * 2,
        };
      }
    }

    // ====================================================================
    // 3. MANDALA RENDERER CLASS (No functional changes needed)
    // ====================================================================
    // Note: The drawing logic remains identical to the previous ultimate version
    // to maintain the high-fidelity graphical effects (multi-pass glow).

    class MandalaRenderer {
      constructor(canvasId, fullscreenCanvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.fsCanvas = document.getElementById(fullscreenCanvasId);
        this.fsCtx = this.fsCanvas.getContext('2d');

        this.params = null;
        this.isAnimating = false;
        this.animationId = null;
        this.phase = 0;

        this.width = W;
        this.height = H;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.speed = 1.0;
        this.isBloom = true; /* Default to TRUE for the wellness aesthetic */
        this.bloomIntensity = 0.6; /* Slight increase for ethereal look */

        this.icosaVertices = this.generateIcosahedronVertices();
        this.icosaEdges = this.generateIcosahedronEdges();
      }

      setParams(params) {
        this.params = params;
      }

      toggleAnimation(state) {
        this.isAnimating = state;
        if (state) this.loop();
        else cancelAnimationFrame(this.animationId);
      }

      loop() {
        if (!this.isAnimating) return;
        this.phase += 0.01 * this.speed;

        const size = Math.min(this.canvas.width, this.canvas.height);
        this.drawFrame(this.ctx, size, size, this.phase);

        if (document.getElementById('fullscreen-overlay').classList.contains('active')) {
          const w = window.innerWidth;
          const h = window.innerHeight;
          this.fsCanvas.width = w;
          this.fsCanvas.height = h;
          this.drawFrame(this.fsCtx, w, h, this.phase);
        }

        this.animationId = requestAnimationFrame(this.loop.bind(this));
      }

      drawFrame(ctx, w, h, phase) {
        ctx.save();
        /* The canvas itself must remain dark for the glowing effect to work */
        ctx.fillStyle = '#080706'; 
        ctx.fillRect(0, 0, w, h);

        // --- 1. GLOW LAYER (Faint, broad blur) ---
        if (this.isBloom) {
          const blurSize1 = 15 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize1}px)`;
          ctx.globalAlpha = 0.4;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 2. CORE LAYER (Tighter, brighter blur) ---
        if (this.isBloom) {
          const blurSize2 = 5 * this.bloomIntensity;
          ctx.filter = `blur(${blurSize2}px)`;
          ctx.globalAlpha = 0.6;
          this.drawMandalaElements(ctx, w, h, phase, true);
        }

        // --- 3. DETAIL LAYER (Sharp, full color) ---
        ctx.filter = 'none';
        ctx.globalAlpha = 1.0;
        this.drawMandalaElements(ctx, w, h, phase, false);

        ctx.restore();
      }

      drawMandalaElements(ctx, w, h, phase, isGlowPass) {
        const cx = w / 2, cy = h / 2;
        const radius = Math.min(w, h) / 2 * 0.95;

        this.params.rings.forEach((ring, i) => {
          this.drawRing(ctx, cx, cy, radius * ring.r, ring, this.params, phase, i, isGlowPass);
        });

        this.params.polyhedrons.forEach(poly => {
          this.drawPolyhedron(ctx, cx, cy, radius * poly.radiusFactor, poly, phase, isGlowPass);
        });

        switch(this.params.archetype.index) {
          case 0: this.drawVajraPalace(ctx, cx, cy, radius * 0.4, this.params, phase, isGlowPass); break;
          case 1: this.drawSriYantra(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
          case 2: this.drawIcosahedronGrid(ctx, cx, cy, radius * 0.7, this.params, phase, isGlowPass); break;
        }

        this.drawCenterSyllable(ctx, cx, cy, radius * 0.1, this.params, phase, isGlowPass);
      }

      drawRing(ctx, cx, cy, r, ring, params, phase, idx, isGlowPass) {
        const color1 = params.palette[ring.colorIndex];
        const color2 = params.palette[(ring.colorIndex + 1) % 3];
        const factor = (r / (H / 2 * 0.95) + Math.sin(phase * 0.5) * 0.5 + 0.5) % 1;
        const interpolatedColor = interpolateColor(color1, color2, factor);
        
        ctx.strokeStyle = interpolatedColor;
        ctx.lineWidth = ring.width;
        ctx.beginPath();
        
        if (isGlowPass || ring.style === 0) { 
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
          return;
        }

        const complexityFactor = parseFloat(params.complexity) * 0.5;

        if (ring.style === 1) { 
          const dots = 36 + Math.floor(complexityFactor * 40);
          for(let i=0; i<dots; i++) {
            const a = (i/dots)*Math.PI*2 + phase*(idx%2?0.1:-0.1);
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.moveTo(x, y);
            ctx.arc(x, y, ring.width*1.5, 0, Math.PI*2);
          }
          ctx.fillStyle=interpolatedColor;
          ctx.fill();
        } else if (ring.style === 4) { 
            ctx.setLineDash([ring.width * 2, ring.width * 2]);
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]); 
        } else if (ring.style === 2) { 
          ctx.arc(cx, cy, r - ring.width/2, 0, Math.PI*2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx, cy, r + ring.width/2, 0, Math.PI*2);
          ctx.stroke();
        } else if (ring.style === 3) { 
          const symbol = TIBETAN_SYMBOLS[params.symbolIndex].char;
          const count = 15 + Math.floor(complexityFactor * 15);
          ctx.font = `${ring.width * 5}px 'Noto Serif Tibetan', sans-serif`;
          ctx.fillStyle = interpolatedColor;
          for(let i=0; i<count; i++) {
            const a = (i/count)*Math.PI*2 + phase*0.1;
            const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(a + Math.PI/2);
            ctx.fillText(symbol, 0, 0);
            ctx.restore();
          }
        }
      }

      drawCenterSyllable(ctx, cx, cy, r, params, phase, isGlowPass) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fillStyle = params.palette[3];
        ctx.fill();
        ctx.strokeStyle = params.palette[4];
        ctx.lineWidth = 2;
        ctx.stroke();

        if (isGlowPass) return;

        const symbolData = TIBETAN_SYMBOLS[params.symbolIndex];
        ctx.fillStyle = params.palette[0];
        ctx.font = `${r*0.8}px 'Noto Serif Tibetan', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbolData.char, cx, cy);
      }

      drawVajraPalace(ctx, cx, cy, r, params, phase, isGlowPass) {
        ctx.fillStyle = params.palette[1];
        if (isGlowPass) return; 

        ctx.fillRect(cx - r * 0.9, cy - r * 0.9, r * 1.8, r * 1.8);
        
        const lineCount = 12 + Math.floor(parseFloat(params.complexity) * 10);
        ctx.strokeStyle = params.palette[2];
        ctx.lineWidth = 1;
        ctx.save(); ctx.translate(cx, cy); ctx.rotate(phase * 0.005);
        for (let i = 0; i < lineCount; i++) {
          const a = (i / lineCount) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(a) * r * 2, Math.sin(a) * r * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      drawSriYantra(ctx, cx, cy, r, params, phase, isGlowPass) {
        const depth = 5 + Math.floor(parseFloat(params.complexity) * 4);
        let currentSize = r * 0.9;
        ctx.save();
        ctx.translate(cx, cy);
        let currentRotation = params.solidRotation + phase * 0.005;

        for(let i=0; i<depth; i++) {
          const color = i % 2 === 0 ? params.palette[1] : params.palette[2];
          ctx.strokeStyle = color;
          ctx.lineWidth = isGlowPass ? 5 : (2 + (depth - i) * 0.5);

          this.drawTriangle(ctx, currentRotation, currentSize);
          
          currentRotation += Math.PI / 3;
          ctx.strokeStyle = i % 2 === 0 ? params.palette[4] : params.palette[3];
          this.drawTriangle(ctx, currentRotation, currentSize);

          currentRotation -= Math.PI / 3;
          currentSize *= 0.7;
          currentRotation += phase * 0.01;
        }
        ctx.restore();
      }
      
      drawTriangle(ctx, angle, size) {
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * size, Math.sin(angle) * size);
        ctx.lineTo(Math.cos(angle + 2 * Math.PI / 3) * size, Math.sin(angle + 2 * Math.PI / 3) * size);
        ctx.lineTo(Math.cos(angle + 4 * Math.PI / 3) * size, Math.sin(angle + 4 * Math.PI / 3) * size);
        ctx.closePath();
        ctx.stroke();
      }

      drawIcosahedronGrid(ctx, cx, cy, r, params, phase, isGlowPass) {
        if (isGlowPass) return;
        
        const radius = r * 0.9;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(params.solidRotation + phase * 0.005);
        
        const goldenRatio = (1 + Math.sqrt(5)) / 2;
        const vertexPositions = [];
        const offsetAngle = phase * 0.05;

        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          vertexPositions.push({ x: radius * Math.cos(angle + offsetAngle) / goldenRatio, y: radius * Math.sin(angle + offsetAngle) / goldenRatio });
          vertexPositions.push({ x: radius * Math.cos(angle - offsetAngle + Math.PI/6) / goldenRatio, y: radius * Math.sin(angle - offsetAngle + Math.PI/6) / goldenRatio });
        }
        
        ctx.strokeStyle = params.palette[2];
        ctx.lineWidth = 1;
        for (let i = 0; i < 12; i++) {
          for (let j = i + 1; j < 12; j++) {
            const p1 = vertexPositions[i];
            const p2 = vertexPositions[j];
            const distSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
            if (distSq < (radius * 0.7) ** 2) {
              ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }
          }
        }
        
        ctx.fillStyle = params.palette[4];
        vertexPositions.forEach(p => {
          ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
        });

        ctx.restore();
      }

      generateIcosahedronVertices() {
        const phi = (1 + Math.sqrt(5)) / 2;
        const s = 1.0;
        return [
          [0, s, phi*s], [0, -s, phi*s], [0, s, -phi*s], [0, -s, -phi*s],
          [s, phi*s, 0], [-s, phi*s, 0], [s, -phi*s, 0], [-s, -phi*s, 0],
          [phi*s, 0, s], [-phi*s, 0, s], [phi*s, 0, -s], [-phi*s, 0, -s]
        ];
      }

      generateIcosahedronEdges() {
        const edges = [];
        const n = this.icosaVertices.length;
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const p1 = this.icosaVertices[i];
                const p2 = this.icosaVertices[j];
                const distSq = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
                if (distSq < 4.1) { 
                    edges.push([i, j]);
                }
            }
        }
        return edges;
      }

      drawPolyhedron(ctx, cx, cy, r, poly, phase, isGlowPass) {
        if (isGlowPass) return; 

        ctx.save();
        ctx.translate(cx, cy);
        
        const angle = phase * poly.rotationSpeed * 5; 
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const rotateX = ([x, y, z]) => [x, y * cos - z * sin, y * sin + z * cos];
        const rotateY = ([x, y, z]) => [x * cos - z * sin, y, x * sin + z * cos];

        let vertices = this.icosaVertices; 
        let edges = this.icosaEdges;
        let scaleFactor = r * 0.2;

        if (poly.type === 0) {} 
        else if (poly.type === 1) {
            this.drawStar(ctx, r, 5, 0.4); 
            ctx.strokeStyle = poly.color;
            ctx.lineWidth = poly.thickness;
            ctx.stroke();
            ctx.restore();
            return;
        } else if (poly.type === 2) { 
            vertices = [
                [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
                [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1]
            ];
            edges = [
                [0,1],[1,2],[2,3],[3,0], 
                [4,5],[5,6],[6,7],[7,4], 
                [0,4],[1,5],[2,6],[3,7]  
            ];
            scaleFactor = r * 0.4;
        } else if (poly.type === 3) { 
            const h = 1 / Math.sqrt(3);
            vertices = [
                [0, 0, 1.5],
                [1, 0, -h],
                [-0.5, Math.sqrt(3)/2, -h],
                [-0.5, -Math.sqrt(3)/2, -h]
            ];
            edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
            scaleFactor = r * 0.4;
        }

        const projected = vertices.map(v => {
            let v_rotated = rotateY(rotateX(v));
            const z = v_rotated[2] * scaleFactor; 
            const x = v_rotated[0] * scaleFactor;
            const y = v_rotated[1] * scaleFactor;
            return { x, y, z };
        });

        ctx.strokeStyle = poly.color;
        ctx.lineWidth = poly.thickness;

        edges.forEach(([i, j]) => {
            const v1 = projected[i];
            const v2 = projected[j];
            if (v1 && v2) {
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
            }
        });

        ctx.restore();
      }

      drawStar(ctx, r, points, innerRatio) {
          ctx.beginPath();
          for (let i = 0; i < points * 2; i++) {
              const radius = i % 2 === 0 ? r : r * innerRatio;
              const angle = (i / (points * 2)) * Math.PI * 2;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
          }
          ctx.closePath();
      }
    }


    // ====================================================================
    // 4. AUDIO ENGINE CLASS (No functional changes needed)
    // ====================================================================

    class AudioEngine {
      constructor() {
        this.audioCtx = null;
        this.masterGain = null;
        this.leftOsc = null;
        this.rightOsc = null;
        this.leftPan = null;
        this.rightPan = null;
        this.isAudioPlaying = false;

        this.computedCarrier = 0;
        this.computedBeat = 0;
        this.currentElementData = null;
      }

      initAudioIfNeeded(volume) {
        if (this.audioCtx) return;
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.audioCtx.createGain();
        this.masterGain.gain.value = volume || 0.06;

        this.leftOsc = this.audioCtx.createOscillator();
        this.leftOsc.type = 'sine';
        this.leftPan = this.audioCtx.createStereoPanner();
        this.leftPan.pan.value = -1; 
        this.rightOsc = this.audioCtx.createOscillator();
        this.rightOsc.type = 'sine';
        this.rightPan = this.audioCtx.createStereoPanner();
        this.rightPan.pan.value = 1; 

        this.leftOsc.connect(this.leftPan);
        this.leftPan.connect(this.masterGain);
        this.rightOsc.connect(this.rightPan);
        this.rightPan.connect(this.masterGain);
        this.masterGain.connect(this.audioCtx.destination);

        this.leftOsc.start();
        this.rightOsc.start();
        this.isAudioPlaying = false;
      }

      setVolume(volume) {
        if (!this.audioCtx) return;
        this.masterGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
      }

      togglePlay(volume, beat) {
        this.initAudioIfNeeded(volume);
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
        this.isAudioPlaying = !this.isAudioPlaying;

        if (this.isAudioPlaying) {
          this.masterGain.gain.setTargetAtTime(volume, this.audioCtx.currentTime, 0.02);
          this.updateFrequencies(beat);
        } else {
          this.masterGain.gain.setTargetAtTime(0.0001, this.audioCtx.currentTime, 0.02);
        }
        return this.isAudioPlaying;
      }

      computeAudioFromSeed(seed, dateStr, elementData) {
        const elements = [elementData.year, elementData.month, elementData.day];
        const primaryElement = elements.reduce((prev, current) => {
          const prevFreq = SOUND_ELEMENT_MAPPING[prev.name.split(' ')[0].toUpperCase()].freq;
          const currentFreq = SOUND_ELEMENT_MAPPING[current.name.split(' ')[0].toUpperCase()].freq;
          return (currentFreq > prevFreq) ? current : prev;
        });

        let carrierFreq = SOUND_ELEMENT_MAPPING[primaryElement.name.split(' ')[0].toUpperCase()].freq;
        carrierFreq = carrierFreq / 2; 

        const date = dateStr ? new Date(dateStr + "T12:00:00") : new Date();
        const dayOfMonth = date.getDate();
        const beat = 2.0 + (dayOfMonth / 31) * 8.0;

        return {
          carrier: carrierFreq,
          beat: beat,
          element: primaryElement,
        };
      }

      updateFrequencies(beatOverride) {
        if (!this.currentElementData) return;
        
        const audioData = this.computeAudioFromSeed(
          this.currentElementData.seed, 
          this.currentElementData.dateStr, 
          this.currentElementData.elementData
        );

        this.computedCarrier = audioData.carrier;
        this.computedBeat = parseFloat(beatOverride) || audioData.beat;

        const leftFreq = this.computedCarrier - (this.computedBeat / 2);
        const rightFreq = this.computedCarrier + (this.computedBeat / 2);

        if (this.leftOsc && this.rightOsc) {
          this.leftOsc.frequency.setTargetAtTime(Math.max(80, leftFreq), this.audioCtx.currentTime, 0.03);
          this.rightOsc.frequency.setTargetAtTime(Math.max(80, rightFreq), this.audioCtx.currentTime, 0.03);
        }
      }

      resumeContext() {
        if (this.audioCtx && this.isAudioPlaying && this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }
      }
    }


    // ====================================================================
    // 5. MAIN APPLICATION LOGIC (Updated Copy)
    // ====================================================================
    document.addEventListener('DOMContentLoaded', () => {
      const seedInput = document.getElementById('seed-input');
      const dateInput = document.getElementById('date-input');
      const audioToggle = document.getElementById('audio-toggle');
      const beatRange = document.getElementById('beat-range');
      const volRange = document.getElementById('vol-range');
      const fsOverlay = document.getElementById('fullscreen-overlay');
      const fsStat = document.getElementById('fs-stat');
      const speedDisplay = document.getElementById('speed-display');
      const bloomDisplay = document.getElementById('bloom-display');
      const volumeDisplay = document.getElementById('volume-display');

      const renderer = new MandalaRenderer('mandala-canvas', 'fullscreen-canvas');
      const audioEngine = new AudioEngine();
      
      let currentMandalaParams = null;

      dateInput.valueAsDate = new Date();
      updateUI();
      
      // --- Core Update Function ---
      function updateUI() {
        const name = seedInput.value || "Inner Tranquility";
        const date = dateInput.value;
        
        const paramsGenerator = new MandalaParams(name, date);
        currentMandalaParams = paramsGenerator;
        renderer.setParams(currentMandalaParams.params);
        audioEngine.currentElementData = currentMandalaParams;

        // 2. Update Meta Displays
        document.getElementById('tibetan-display').textContent = currentMandalaParams.tibetan || '\u0F0B';
        document.getElementById('element-display').textContent = `${currentMandalaParams.elementData.year.name.split(' ')[0]} / ${currentMandalaParams.elementData.month.name.split(' ')[0]} / ${currentMandalaParams.elementData.day.name.split(' ')[0]}`;
        document.getElementById('archetype-display').textContent = `${currentMandalaParams.params.archetype.name} / ${currentMandalaParams.params.complexity}`;

        // 3. Sync Audio Frequencies
        syncAudioFrequencies(false);

        // 4. Update Explanation Panels
        updateExplanationPanels(currentMandalaParams.params, currentMandalaParams.elementData);

        // 5. Draw Static Frame
        if (!renderer.isAnimating) {
            renderer.drawFrame(renderer.ctx, W, H, renderer.phase);
        }
      }

      function syncAudioFrequencies(isManualBeatChange) {
        if (!currentMandalaParams) return;
        
        const audioData = audioEngine.computeAudioFromSeed(
          currentMandalaParams.seed, 
          currentMandalaParams.dateStr, 
          currentMandalaParams.elementData
        );

        if (!isManualBeatChange && beatRange.dataset.touched === "0") {
          beatRange.value = audioData.beat.toFixed(1);
        }
        
        audioEngine.updateFrequencies(beatRange.value);
        
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      }

      /* --- Copy Overhaul for Wellness Look --- */
      function updateExplanationPanels(params, elementData) {
        const leftPanel = document.getElementById('left-panel-content');
        const rightPanel = document.getElementById('right-panel-content');
        
        const primaryElementKey = audioEngine.currentElementData.elementData.year.name.split(' ')[0].toUpperCase();
        const primaryAudioElement = SOUND_ELEMENT_MAPPING[primaryElementKey];

        // LEFT PANEL: COLOR & ELEMENT
        let leftHTML = `
          <h3>Core Energetic Harmony</h3>
          <p>Your date of reflection determines the three dominant energetic forces that shape your personal color frequency. This creates a deeply resonant visual experience.</p>
          <h4>Your Dominant Elements:</h4>
          <ul>
            <li><strong>Year:</strong> ${elementData.year.name}. ${elementData.year.meaning.split('. ')[0]}.</li>
            <li><strong>Month:</strong> ${elementData.month.name}. ${elementData.month.meaning.split('. ')[0]}.</li>
            <li><strong>Day:</strong> ${elementData.day.name}. ${elementData.day.meaning.split('. ')[0]}.</li>
          </ul>
          <h4>Design Palette: Soothing Tones</h4>
          <p>These five blended shades are harmonized from your elements, designed to induce a state of calm and focus:</p>
          <ul>
            <li><span class="color-block" style="background-color: ${params.palette[0]}"></span>Tone 1: Primary Resonance</li>
            <li><span class="color-block" style="background-color: ${params.palette[1]}"></span>Tone 2: Inner Flow</li>
            <li><span class="color-block" style="background-color: ${params.palette[2]}"></span>Tone 3: Detail Accent</li>
            <li><span class="color-block" style="background-color: ${params.palette[3]}"></span>Tone 4: Foundation Base</li>
            <li><span class="color-block" style="background-color: ${params.palette[4]}"></span>Tone 5: Core Integrity</li>
          </ul>
        `;
        leftPanel.innerHTML = leftHTML;

        // RIGHT PANEL: GEOMETRY, SYMBOL, & AUDIO
        const primarySymbol = TIBETAN_SYMBOLS[params.symbolIndex];
        let rightHTML = `
          <h3>Geometry of Intention</h3>
          <p>Your entered phrase acts as a signature, defining the foundational geometry and the central point of reflection.</p>
          <h4>Design Archetype: ${params.archetype.name} (Intention Score: ${params.complexity})</h4>
          <p>${params.archetype.meaning}</p>
          
          <h4>Central Focus Symbol</h4>
          <p>The core image holds a powerful, singular intention drawn from your signature:</p>
          <ul>
            <li><strong>${primarySymbol.desc}:</strong> ${primarySymbol.meaning}</li>
          </ul>

          <h4>Acoustic Alignment Tone</h4>
          <p>The most dominant element provides the carrier frequency for a subtle binaural beat, designed to gently guide your brain into a meditative state.</p>
          <ul>
            <li><strong>Source Element:</strong> ${primaryAudioElement.note} (${(audioEngine.computedCarrier*2).toFixed(2)} Hz)</li>
            <li><strong>Carrier Frequency:</strong> ${audioEngine.computedCarrier.toFixed(2)} Hz (Set low for background comfort)</li>
            <li><strong>Binaural Rhythm:</strong> ${audioEngine.computedBeat.toFixed(2)} Hz (Controls your meditative pace)</li>
          </ul>
        `;
        rightPanel.innerHTML = rightHTML;
      }
      
      // --- UI Event Listeners ---
      seedInput.addEventListener('input', updateUI);
      dateInput.addEventListener('change', updateUI);

      document.getElementById('random-btn').addEventListener('click', () => {
        seedInput.value = '';
        dateInput.valueAsDate = new Date(new Date().getTime() - Math.floor(Math.random()*365*24*60*60*1000));
        updateUI();
      });

      document.getElementById('animate-btn').addEventListener('click', () => {
        const newState = !renderer.isAnimating;
        renderer.toggleAnimation(newState);
        document.getElementById('animate-btn').textContent = newState ? "Pause Motion" : "Activate Motion";
      });

      document.getElementById('bloom-btn').addEventListener('click', () => {
        renderer.isBloom = !renderer.isBloom;
        updateBloomDisplay();
        if(!renderer.isAnimating) renderer.drawFrame(renderer.ctx, W, H, renderer.phase);
      });

      document.getElementById('save-btn').addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `aura-resonance-${seedInput.value.replace(/ /g, '-')||'tranquility'}.png`;
        link.href = renderer.canvas.toDataURL();
        link.click();
      });

      // Audio Controls
      audioToggle.addEventListener('click', () => {
        const isPlaying = audioEngine.togglePlay(parseFloat(volRange.value), beatRange.value);
        audioToggle.textContent = isPlaying ? 'Sound Align ‚è∏' : 'Sound Align ‚ñ∂';
      });

      volRange.addEventListener('input', () => {
        audioEngine.setVolume(parseFloat(volRange.value));
        volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
      });

      beatRange.addEventListener('input', () => {
        beatRange.dataset.touched = "1";
        syncAudioFrequencies(true); 
      });

      // Fullscreen Logic
      document.getElementById('fullscreen-btn').addEventListener('click', enterFullscreen);
      document.getElementById('fs-exit').addEventListener('click', exitFullscreen);

      function enterFullscreen() {
        fsOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
        if (!renderer.isAnimating) renderer.toggleAnimation(true);
      }

      function exitFullscreen() {
        fsOverlay.classList.remove('active');
        document.body.style.overflow = '';
      }

      // Stat display (for user feedback)
      function showStat(message) {
        fsStat.textContent = message;
        fsStat.classList.add('visible');
        clearTimeout(fsStat.timer);
        fsStat.timer = setTimeout(() => fsStat.classList.remove('visible'), 1000);
      }
      
      function updateBloomDisplay() {
          bloomDisplay.textContent = renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "OFF";
      }

      // --- Global Keyboard Controls (in Fullscreen) ---
      document.addEventListener('keydown', (e) => {
        const inFullscreen = fsOverlay.classList.contains('active');
        
        if (inFullscreen) {
            e.preventDefault(); 
        }

        switch(e.code) {
          case 'Escape':
            if (inFullscreen) exitFullscreen();
            break;
          case 'ArrowLeft': 
            renderer.speed = Math.max(0.1, renderer.speed - 0.25);
            showStat(`Flow State: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowRight': 
            renderer.speed = Math.min(10, renderer.speed + 0.25);
            showStat(`Flow State: ${renderer.speed.toFixed(2)}`);
            speedDisplay.textContent = renderer.speed.toFixed(2);
            break;
          case 'ArrowUp': 
            if (!renderer.isBloom) {
                renderer.isBloom = true;
            }
            renderer.bloomIntensity = Math.min(2.0, renderer.bloomIntensity + 0.1);
            showStat(`Light Intensity: ${renderer.bloomIntensity.toFixed(2)}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawFrame(renderer.ctx, W, H, renderer.phase);
            break;
          case 'ArrowDown': 
            renderer.bloomIntensity = Math.max(0.1, renderer.bloomIntensity - 0.1);
            if (renderer.bloomIntensity < 0.15) renderer.isBloom = false;
            showStat(`Light Intensity: ${renderer.isBloom ? renderer.bloomIntensity.toFixed(2) : "Light OFF"}`);
            updateBloomDisplay();
            if(!renderer.isAnimating) renderer.drawFrame(renderer.ctx, W, H, renderer.phase);
            break;
          case 'NumpadAdd':
          case 'Equal': 
            volRange.value = (parseFloat(volRange.value) + 0.01).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Focus Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
          case 'NumpadSubtract':
          case 'Minus': 
            volRange.value = (parseFloat(volRange.value) - 0.01).toFixed(3);
            volRange.value = Math.max(0.005, parseFloat(volRange.value)).toFixed(3);
            audioEngine.setVolume(parseFloat(volRange.value));
            showStat(`Focus Volume: ${parseFloat(volRange.value).toFixed(2)}`);
            volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
            break;
        }
      });
      
      document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
              audioEngine.resumeContext();
          }
      });

      // Initial state setup
      updateBloomDisplay();
      speedDisplay.textContent = renderer.speed.toFixed(2);
      volumeDisplay.textContent = parseFloat(volRange.value).toFixed(2);
    });
  </script>
</body>
</html>
